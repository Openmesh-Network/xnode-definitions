[
    {
        "name": "GNUnet",
        "desc": "GNU's decentralized anonymous and censorship-resistant P2P framework",
        "tags": [
            "Communication - Custom Communication Systems"
        ],
        "website": "https://gnunet.org/",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "gnunet",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to run the GNUnet daemon. GNUnet is GNU\u2019s anonymouspeer-to-peer communication and file sharing framework.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraOptions",
                "desc": "Additional options that will be copied verbatim in gnunet.conf . See   gnunet.conf(5)   fordetails.",
                "nixName": "extraOptions",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "fileSharing.quota",
                "desc": "Maximum file system usage (in MiB) for file sharing.",
                "nixName": "fileSharing.quota",
                "type": "signed integer",
                "value": "1024"
            },
            {
                "name": "load.hardNetUpBandwidth",
                "desc": "Hard bandwidth limit (in bits per second) when uploading data.",
                "nixName": "load.hardNetUpBandwidth",
                "type": "signed integer",
                "value": "0"
            },
            {
                "name": "load.maxNetDownBandwidth",
                "desc": "Maximum bandwidth usage (in bits per second) for GNUnet whendownloading data.",
                "nixName": "load.maxNetDownBandwidth",
                "type": "signed integer",
                "value": "50000"
            },
            {
                "name": "load.maxNetUpBandwidth",
                "desc": "Maximum bandwidth usage (in bits per second) for GNUnet whendownloading data.",
                "nixName": "load.maxNetUpBandwidth",
                "type": "signed integer",
                "value": "50000"
            },
            {
                "name": "package",
                "desc": "The gnunet package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.gnunet"
            },
            {
                "name": "tcp.port",
                "desc": "The TCP port for use by GNUnet.",
                "nixName": "tcp.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "2086"
            },
            {
                "name": "udp.port",
                "desc": "The UDP port for use by GNUnet.",
                "nixName": "udp.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "2086"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "AWStats ",
        "desc": "Real-time logfile analyzer to get advanced statistics",
        "tags": [
            "Analytics"
        ],
        "website": "https://awstats.org",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "awstats",
        "options": [
            {
                "name": "configs",
                "desc": "Attribute set of domains to collect stats for.",
                "nixName": "configs",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "configs.<name>.domain",
                "desc": "The domain name to collect stats for.",
                "nixName": "configs.<name>.domain",
                "type": "string",
                "value": "\"\u2039name\u203a\""
            },
            {
                "name": "configs.<name>.extraConfig",
                "desc": "Extra configuration to be appended to awstats.${name}.conf.",
                "nixName": "configs.<name>.extraConfig",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "configs.<name>.hostAliases",
                "desc": "List of aliases the site has.",
                "nixName": "configs.<name>.hostAliases",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "configs.<name>.logFile",
                "desc": "The log file to be scanned.  For mail, set this to   journalctl $OLD_CURSOR -u postfix.service | ${pkgs.perl}/bin/perl ${pkgs.awstats.out}/share/awstats/tools/maillogconvert.pl standard |",
                "nixName": "configs.<name>.logFile",
                "type": "string",
                "value": null
            },
            {
                "name": "configs.<name>.logFormat",
                "desc": "The log format being used.  For mail, set this to   %time2 %email %email_r %host %host_r %method %url %code %bytesd",
                "nixName": "configs.<name>.logFormat",
                "type": "string",
                "value": "\"1\""
            },
            {
                "name": "configs.<name>.type",
                "desc": "The type of log being collected.",
                "nixName": "configs.<name>.type",
                "type": "one of \"mail\", \"web\"",
                "value": "\"web\""
            },
            {
                "name": "configs.<name>.webService.enable",
                "desc": "Whether to enable awstats web service.",
                "nixName": "configs.<name>.webService.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "configs.<name>.webService.hostname",
                "desc": "The hostname the web service appears under.",
                "nixName": "configs.<name>.webService.hostname",
                "type": "string",
                "value": "\"\u2039name\u203a\""
            },
            {
                "name": "configs.<name>.webService.urlPrefix",
                "desc": "The URL prefix under which the awstats pages appear.",
                "nixName": "configs.<name>.webService.urlPrefix",
                "type": "string",
                "value": "\"/awstats\""
            },
            {
                "name": "dataDir",
                "desc": "The directory where awstats data will be stored.",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/awstats\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable awstats, a real-time logfile analyzer.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "updateAt",
                "desc": "Specification of the time at which awstats will get updated. (in theformat described by   systemd.time(7)  )",
                "nixName": "updateAt",
                "type": "null or string",
                "value": "null"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Metabase",
        "desc": "The easy, open source way for everyone in your company to ask questions and learn from data",
        "tags": [
            "Analytics"
        ],
        "website": "https://metabase.com",
        "logo": "https://metabase.com/images/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "metabase",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable Metabase service.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "listen.ip",
                "desc": "IP address that Metabase should listen on.",
                "nixName": "listen.ip",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "listen.port",
                "desc": "Listen port for Metabase.",
                "nixName": "listen.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "3000"
            },
            {
                "name": "openFirewall",
                "desc": "Open ports in the firewall for Metabase.",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "ssl.enable",
                "desc": "Whether to enable SSL (https) support.",
                "nixName": "ssl.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "ssl.keystore",
                "desc": "JavaKeyStore  file containing the certificates.",
                "nixName": "ssl.keystore",
                "type": "null or path",
                "value": "\"/var/lib/metabase/metabase.jks\""
            },
            {
                "name": "ssl.port",
                "desc": "Listen port over SSL (https) for Metabase.",
                "nixName": "ssl.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8443"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Matomo",
        "desc": "A real-time web analytics application",
        "tags": [
            "Analytics"
        ],
        "website": "https://matomo.org/",
        "logo": "https://m-img.org/spai/q_lossless+ret_img+to_webp/matomo.org/wp-content/uploads/2018/11/cropped-DefaultIcon-32x32.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "matomo",
        "options": [
            {
                "name": "enable",
                "desc": "Enable Matomo web analytics with php-fpm backend. Either the nginxoption or the webServerUser option is mandatory.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "hostname",
                "desc": "URL of the host, without https prefix. You may want to change it ifyou run Matomo on a different URL than matomo.yourdomain.",
                "nixName": "hostname",
                "type": "string",
                "value": "\"matomo.${config.networking.fqdnOrHostName}\"\n"
            },
            {
                "name": "nginx",
                "desc": "With this option, you can customize an nginx virtualHost whichalready has sensible defaults for Matomo. Either this option or thewebServerUser option is mandatory. Set this to {} to just enable thevirtualHost if you don\u2019t need any customization. If enabled, then bydefault, the  serverName  is ${user}.${config.networking.hostName}.${config.networking.domain} ,SSL is active, and certificates are acquired via ACME. If this is set tonull (the default), no nginx virtualHost will be configured.",
                "nixName": "nginx",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "nginx.acmeFallbackHost",
                "desc": "Host which to proxy requests to if ACME challenge is not found.Useful if you want multiple hosts to be able to verify the same domainname.  With this option, you could request certificates for the presentdomain with an ACME client that is running on another host, which youwould specify here.",
                "nixName": "nginx.acmeFallbackHost",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "nginx.acmeRoot",
                "desc": "Directory for the ACME challenge, which is  public .Don\u2019t put certs or keys in here. Set to null to inherit fromconfig.security.acme.",
                "nixName": "nginx.acmeRoot",
                "type": "null or string",
                "value": "\"/var/lib/acme/acme-challenge\""
            },
            {
                "name": "nginx.addSSL",
                "desc": "Whether to enable HTTPS in addition to plain HTTP. This will setdefaults for  listen  to listen on all interfaces on therespective default ports (80, 443).",
                "nixName": "nginx.addSSL",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.basicAuth",
                "desc": "Basic Auth protection for a vhost.  WARNING: This is implemented to store the password in plain text inthe Nix store.",
                "nixName": "nginx.basicAuth",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "nginx.basicAuthFile",
                "desc": "Basic Auth password file for a vhost. Can be created via:  htpasswd -c <filename> <username> .  WARNING: The generate file contains the users\u2019 passwords in anon-cryptographically-securely hashed way.",
                "nixName": "nginx.basicAuthFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "nginx.default",
                "desc": "Makes this vhost the default.",
                "nixName": "nginx.default",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.enableACME",
                "desc": "Whether to ask Let\u2019s Encrypt to sign a certificate for this vhost.Alternately, you can use an existing certificate through  useACMEHost .",
                "nixName": "nginx.enableACME",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "nginx.extraConfig",
                "desc": "These lines go to the end of the vhost verbatim.",
                "nixName": "nginx.extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "nginx.forceSSL",
                "desc": "Whether to add a separate nginx server block that redirects (defaultsto 301, configurable with  redirectCode ) all plain HTTPtraffic to HTTPS. This will set defaults for  listen  tolisten on all interfaces on the respective default ports (80, 443),where the non-SSL listens are used for the redirect vhosts.",
                "nixName": "nginx.forceSSL",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "nginx.globalRedirect",
                "desc": "If set, all requests for this host are redirected (defaults to 301,configurable with  redirectCode ) to the given hostname.",
                "nixName": "nginx.globalRedirect",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "nginx.http2",
                "desc": "Whether to enable the HTTP/2 protocol. Note that (as of writing) dueto nginx\u2019s implementation, to disable HTTP/2 you have to disable it onall vhosts that use a given IP address / port. If there is one serverblock configured to enable http2, then it is enabled for all serverblocks on this IP. See  https://stackoverflow.com/a/39466948/263061 .",
                "nixName": "nginx.http2",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "nginx.http3",
                "desc": "Whether to enable the HTTP/3 protocol. This requires using pkgs.nginxQuic  package which can be achieved by setting services.nginx.package = pkgs.nginxQuic;  and activate theQUIC transport protocol services.nginx.virtualHosts.<name>.quic = true; . Notethat HTTP/3 support is experimental and  not  yet recommended forproduction. Read more at  https://quic.nginx.org/  HTTP/3availability must be manually advertised, preferably in each locationblock.",
                "nixName": "nginx.http3",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "nginx.http3_hq",
                "desc": "Whether to enable the HTTP/0.9 protocol negotiation used in QUICinteroperability tests. This requires using  pkgs.nginxQuic package which can be achieved by setting services.nginx.package = pkgs.nginxQuic;  and activate theQUIC transport protocol services.nginx.virtualHosts.<name>.quic = true; . Notethat special application protocol support is experimental and not  yet recommended for production. Read more at  https://quic.nginx.org/",
                "nixName": "nginx.http3_hq",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.kTLS",
                "desc": "Whether to enable kTLS support. Implementing TLS in the kernel (kTLS)improves performance by significantly reducing the need for copyingoperations between user space and the kernel. Required Nginx version1.21.4 or later.",
                "nixName": "nginx.kTLS",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.listen",
                "desc": "Listen addresses and ports for this virtual host. IPv6 addresses mustbe enclosed in square brackets. Note: this option overrides addSSL  and  onlySSL .  If you only want to set the addresses manually and not the ports,take a look at  listenAddresses .",
                "nixName": "nginx.listen",
                "type": "list of (submodule)",
                "value": "[ ]"
            },
            {
                "name": "nginx.listen.*.addr",
                "desc": "Listen address.",
                "nixName": "nginx.listen.*.addr",
                "type": "string",
                "value": null
            },
            {
                "name": "nginx.listen.*.extraParameters",
                "desc": "Extra parameters of this listen directive.",
                "nixName": "nginx.listen.*.extraParameters",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "nginx.listen.*.port",
                "desc": "Port number to listen on. If unset and the listen address is not asocket then nginx defaults to 80.",
                "nixName": "nginx.listen.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "nginx.listen.*.proxyProtocol",
                "desc": "Enable PROXY protocol.",
                "nixName": "nginx.listen.*.proxyProtocol",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.listen.*.ssl",
                "desc": "Enable SSL.",
                "nixName": "nginx.listen.*.ssl",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.listenAddresses",
                "desc": "Listen addresses for this virtual host. Compared to listen  this only sets the addresses and the ports arechosen automatically.  Note: This option overrides  enableIPv6",
                "nixName": "nginx.listenAddresses",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "nginx.locations",
                "desc": "Declarative location config",
                "nixName": "nginx.locations",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "nginx.locations.<name>.alias",
                "desc": "Alias directory for requests.",
                "nixName": "nginx.locations.<name>.alias",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "nginx.locations.<name>.basicAuth",
                "desc": "Basic Auth protection for a vhost.  WARNING: This is implemented to store the password in plain text inthe Nix store.",
                "nixName": "nginx.locations.<name>.basicAuth",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "nginx.locations.<name>.basicAuthFile",
                "desc": "Basic Auth password file for a vhost. Can be created via:  htpasswd -c <filename> <username> .  WARNING: The generate file contains the users\u2019 passwords in anon-cryptographically-securely hashed way.",
                "nixName": "nginx.locations.<name>.basicAuthFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "nginx.locations.<name>.extraConfig",
                "desc": "These lines go to the end of the location verbatim.",
                "nixName": "nginx.locations.<name>.extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "nginx.locations.<name>.fastcgiParams",
                "desc": "FastCGI parameters to override. Unlike in the Nginx configurationfile, overriding only some default parameters won\u2019t unset the defaultvalues for other parameters.",
                "nixName": "nginx.locations.<name>.fastcgiParams",
                "type": "attribute set of (string or path)",
                "value": "{ }"
            },
            {
                "name": "nginx.locations.<name>.index",
                "desc": "Adds index directive.",
                "nixName": "nginx.locations.<name>.index",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "nginx.locations.<name>.priority",
                "desc": "Order of this location block in relation to the others in the vhost.The semantics are the same as with  lib.mkOrder . Smallervalues have a greater priority.",
                "nixName": "nginx.locations.<name>.priority",
                "type": "signed integer",
                "value": "1000"
            },
            {
                "name": "nginx.locations.<name>.proxyPass",
                "desc": "Adds proxy_pass directive and sets recommended proxy headers ifrecommendedProxySettings is enabled.",
                "nixName": "nginx.locations.<name>.proxyPass",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "nginx.locations.<name>.proxyWebsockets",
                "desc": "Whether to support proxying websocket connections with HTTP/1.1.",
                "nixName": "nginx.locations.<name>.proxyWebsockets",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.locations.<name>.recommendedProxySettings",
                "desc": "Enable recommended proxy settings.",
                "nixName": "nginx.locations.<name>.recommendedProxySettings",
                "type": "boolean",
                "value": "config.services.nginx.recommendedProxySettings"
            },
            {
                "name": "nginx.locations.<name>.return",
                "desc": "Adds a return directive, for e.g. redirections.",
                "nixName": "nginx.locations.<name>.return",
                "type": "null or string or signed integer",
                "value": "null"
            },
            {
                "name": "nginx.locations.<name>.root",
                "desc": "Root directory for requests.",
                "nixName": "nginx.locations.<name>.root",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "nginx.locations.<name>.tryFiles",
                "desc": "Adds try_files directive.",
                "nixName": "nginx.locations.<name>.tryFiles",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "nginx.onlySSL",
                "desc": "Whether to enable HTTPS and reject plain HTTP connections. This willset defaults for  listen  to listen on all interfaces on port443.",
                "nixName": "nginx.onlySSL",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.quic",
                "desc": "Whether to enable the QUIC transport protocol. This requires using pkgs.nginxQuic  package which can be achieved by setting services.nginx.package = pkgs.nginxQuic; . Note that QUICsupport is experimental and  not  yet recommended for production.Read more at  https://quic.nginx.org/",
                "nixName": "nginx.quic",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.redirectCode",
                "desc": "HTTP status used by  globalRedirect  and forceSSL . Possible usecases include temporary (302, 307)redirects, keeping the request method and body (307, 308), or explicitlyresetting the method to GET (303). See  https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections .",
                "nixName": "nginx.redirectCode",
                "type": "integer between 300 and 399 (both inclusive)",
                "value": "301"
            },
            {
                "name": "nginx.rejectSSL",
                "desc": "Whether to listen for and reject all HTTPS connections to this vhost.Useful in  default server blocks to avoid serving the certificate for another vhost. Usesthe  ssl_reject_handshake  directive available in nginxversions 1.19.4 and above.",
                "nixName": "nginx.rejectSSL",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.reuseport",
                "desc": "Create an individual listening socket . It is required to specifyonly once on one of the hosts.",
                "nixName": "nginx.reuseport",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.root",
                "desc": "The path of the web root directory.",
                "nixName": "nginx.root",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "nginx.serverAliases",
                "desc": "Additional names of virtual hosts served by this virtual hostconfiguration.",
                "nixName": "nginx.serverAliases",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "nginx.serverName",
                "desc": "Name of this virtual host. Defaults to attribute name invirtualHosts.",
                "nixName": "nginx.serverName",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "nginx.sslCertificate",
                "desc": "Path to server SSL certificate.",
                "nixName": "nginx.sslCertificate",
                "type": "path",
                "value": null
            },
            {
                "name": "nginx.sslCertificateKey",
                "desc": "Path to server SSL certificate key.",
                "nixName": "nginx.sslCertificateKey",
                "type": "path",
                "value": null
            },
            {
                "name": "nginx.sslTrustedCertificate",
                "desc": "Path to root SSL certificate for stapling and clientcertificates.",
                "nixName": "nginx.sslTrustedCertificate",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "nginx.useACMEHost",
                "desc": "A host of an existing Let\u2019s Encrypt certificate to use. This isuseful if you have many subdomains and want to avoid hitting the  rate limit .Alternately, you can generate a certificate through  enableACME .  Note thatthis option does not create any certificates, nor it does add subdomainsto existing ones \u2013 you will need to create them manually using  security.acme.certs .",
                "nixName": "nginx.useACMEHost",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "package",
                "desc": "The matomo package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.matomo"
            },
            {
                "name": "periodicArchiveProcessing",
                "desc": "Enable periodic archive processing, which generates aggregatedreports from the visits.  This means that you can safely disable browser triggers for Matomoarchiving, and safely enable to delete old visitor logs. Before deletingvisitor logs, make sure though that you run systemctl start matomo-archive-processing.service  at leastonce without errors if you have already collected data before.",
                "nixName": "periodicArchiveProcessing",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "webServerUser",
                "desc": "Name of the web server user that forwards requests to  services.phpfpm.pools.<name>.socket  thefastcgi socket for Matomo if the nginx option is not used. Either thisoption or the nginx option is mandatory. If you want to use anotherwebserver than nginx, you need to set this to that server\u2019s user andpass fastcgi requests to  index.php ,  matomo.php and  piwik.php  (legacy name) to this socket.",
                "nixName": "webServerUser",
                "type": "null or string",
                "value": "null"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Plausible Analytics",
        "desc": "Simple, open-source, lightweight (< 1 KB) and privacy-friendly web analytics alternative to Google Analytics",
        "tags": [
            "Analytics"
        ],
        "website": "https://plausible.io/",
        "logo": "https://plausible.io/assets/images/icon/favicon-16x16.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "plausible",
        "options": [
            {
                "name": "adminUser.activate",
                "desc": "Whether to enable activating the freshly created admin-user.",
                "nixName": "adminUser.activate",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "adminUser.email",
                "desc": "Email-address of the admin-user.",
                "nixName": "adminUser.email",
                "type": "string",
                "value": null
            },
            {
                "name": "adminUser.name",
                "desc": "Name of the admin user that plausible will created on initialstartup.",
                "nixName": "adminUser.name",
                "type": "string",
                "value": "\"admin\""
            },
            {
                "name": "adminUser.passwordFile",
                "desc": "Path to the file which contains the password of the admin user.",
                "nixName": "adminUser.passwordFile",
                "type": "string or path",
                "value": null
            },
            {
                "name": "database.clickhouse.setup",
                "desc": "Whether to enable creating a clickhouse instance.",
                "nixName": "database.clickhouse.setup",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "database.clickhouse.url",
                "desc": "The URL to be used to connect to  clickhouse .",
                "nixName": "database.clickhouse.url",
                "type": "string",
                "value": "\"http://localhost:8123/default\""
            },
            {
                "name": "database.postgres.dbname",
                "desc": "Name of the database to use.",
                "nixName": "database.postgres.dbname",
                "type": "string",
                "value": "\"plausible\""
            },
            {
                "name": "database.postgres.setup",
                "desc": "Whether to enable creating a postgresql instance.",
                "nixName": "database.postgres.setup",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "database.postgres.socket",
                "desc": "Path to the UNIX domain-socket to communicate with postgres .",
                "nixName": "database.postgres.socket",
                "type": "string",
                "value": "\"/run/postgresql\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable plausible.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "mail.email",
                "desc": "The email id to use for as  from  address of allcommunications from Plausible.",
                "nixName": "mail.email",
                "type": "string",
                "value": "\"hello@plausible.local\""
            },
            {
                "name": "mail.smtp.enableSSL",
                "desc": "Whether to enable SSL when connecting to the SMTP server.",
                "nixName": "mail.smtp.enableSSL",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "mail.smtp.hostAddr",
                "desc": "The host address of your smtp server.",
                "nixName": "mail.smtp.hostAddr",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "mail.smtp.hostPort",
                "desc": "The port of your smtp server.",
                "nixName": "mail.smtp.hostPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "25"
            },
            {
                "name": "mail.smtp.passwordFile",
                "desc": "The path to the file with the password in case SMTP auth isenabled.",
                "nixName": "mail.smtp.passwordFile",
                "type": "null or string or path",
                "value": "null"
            },
            {
                "name": "mail.smtp.retries",
                "desc": "Number of retries to make until mailer gives up.",
                "nixName": "mail.smtp.retries",
                "type": "unsigned integer, meaning >=0",
                "value": "2"
            },
            {
                "name": "mail.smtp.user",
                "desc": "The username/email in case SMTP auth is enabled.",
                "nixName": "mail.smtp.user",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "package",
                "desc": "The plausible package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.plausible"
            },
            {
                "name": "server.baseUrl",
                "desc": "Public URL where plausible is available.  Note that  /path  components are currently ignored:   https://github.com/plausible/analytics/issues/1182  .",
                "nixName": "server.baseUrl",
                "type": "string",
                "value": null
            },
            {
                "name": "server.disableRegistration",
                "desc": "Whether to prohibit creating an account in plausible\u2019s UI or allow on invite_only .",
                "nixName": "server.disableRegistration",
                "type": "one of true, false, \"invite_only\"",
                "value": "true"
            },
            {
                "name": "server.listenAddress",
                "desc": "The IP address on which the server is listening.",
                "nixName": "server.listenAddress",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "server.port",
                "desc": "Port where the service should be available.",
                "nixName": "server.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8000"
            },
            {
                "name": "server.secretKeybaseFile",
                "desc": "Path to the secret used by the  phoenix -framework.Instructions how to generate one are documented in the  framework docs .",
                "nixName": "server.secretKeybaseFile",
                "type": "path or string",
                "value": null
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Ollama",
        "desc": "Get up and running with large language models locally",
        "tags": [
            "Analytics"
        ],
        "website": "https://github.com/ollama/ollama",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "ollama",
        "options": [
            {
                "name": "acceleration",
                "desc": "What interface to use for hardware acceleration.    null : default behavior  if  nixpkgs.config.rocmSupport  is enabled, uses \"rocm\"   if  nixpkgs.config.cudaSupport  is enabled, uses \"cuda\"   otherwise defaults to  false      false : disable GPU, only use CPU   \"rocm\" : supported by most modern AMD GPUs  may require overriding gpu type with services.ollama.rocmOverrideGfx  if rocm doesn\u2019t detect yourAMD gpu     \"cuda\" : supported by most modern NVIDIA GPUs",
                "nixName": "acceleration",
                "type": "null or one of false, \"rocm\", \"cuda\"",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable ollama server for local large language models.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "environmentVariables",
                "desc": "Set arbitrary environment variables for the ollama service.  Be aware that these are only seen by the ollama server (systemdservice), not normal invocations like  ollama run . Since ollama run  is mostly a shell around the ollama server, thisis usually sufficient.",
                "nixName": "environmentVariables",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "home",
                "desc": "The home directory that the ollama service is started in.  See also  services.ollama.writablePaths  and services.ollama.sandbox .",
                "nixName": "home",
                "type": "string",
                "value": "\"%S/ollama\""
            },
            {
                "name": "host",
                "desc": "The host address which the ollama server HTTP interface listensto.",
                "nixName": "host",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "loadModels",
                "desc": "The models to download as soon as the service starts. Search formodels of your choice from:  https://ollama.com/library",
                "nixName": "loadModels",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "models",
                "desc": "The directory that the ollama service will read models from anddownload new models to.  See also  services.ollama.writablePaths  and services.ollama.sandbox  if downloading models or othermutation of the filesystem is required.",
                "nixName": "models",
                "type": "string",
                "value": "\"%S/ollama/models\""
            },
            {
                "name": "openFirewall",
                "desc": "Whether to open the firewall for ollama. This adds services.ollama.port  to networking.firewall.allowedTCPPorts .",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The ollama package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.ollama"
            },
            {
                "name": "port",
                "desc": "Which port the ollama server listens to.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "11434"
            },
            {
                "name": "rocmOverrideGfx",
                "desc": "Override what rocm will detect your gpu model as. For example, makerocm treat your RX 5700 XT (or any other model) as an RX 6900 XT using avalue of  \"10.3.0\"  (gfx 1030).  This sets the value of  HSA_OVERRIDE_GFX_VERSION . See  ollama\u2019sdocs  for details.",
                "nixName": "rocmOverrideGfx",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "sandbox",
                "desc": "Whether to enable systemd\u2019s sandboxing capabilities.  This sets   DynamicUser  ,which runs the server as a unique user with read-only access to most ofthe filesystem.  See also  services.ollama.writablePaths .",
                "nixName": "sandbox",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "writablePaths",
                "desc": "Paths that the server should have write access to.  This sets   ReadWritePaths  ,which allows specified paths to be written to through the defaultsandboxing.  See also  services.ollama.sandbox .",
                "nixName": "writablePaths",
                "type": "list of string",
                "value": "[ ]"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "changedetection.io",
        "desc": "Self-hosted free open source website change detection tracking, monitoring and notification service",
        "tags": [
            "Automation"
        ],
        "website": "https://github.com/dgtlmoon/changedetection.io",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "changedetection-io",
        "options": [
            {
                "name": "baseURL",
                "desc": "The base url used in notifications and  {base_url} token.",
                "nixName": "baseURL",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "behindProxy",
                "desc": "Enable this option when changedetection-io runs behind a reverseproxy, so that it trusts X-* headers. It is recommend to runchangedetection-io behind a TLS reverse proxy.",
                "nixName": "behindProxy",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "chromePort",
                "desc": "A free port on which webDriverSupport or playwrightSupport listen onlocalhost.",
                "nixName": "chromePort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "4444"
            },
            {
                "name": "datastorePath",
                "desc": "The directory used to store all data for changedetection-io.",
                "nixName": "datastorePath",
                "type": "string",
                "value": "\"/var/lib/changedetection-io\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable changedetection-io.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "environmentFile",
                "desc": "Securely pass environment variabels to changedetection-io.  This can be used to set for example a frontend password reproduciblevia  SALTED_PASS  which convinetly also deactivates nagsabout the hosted version.  SALTED_PASS  should be 64characters long while the first 32 are the salt and the second thefrontend password. It can easily be retrieved from the settings filewhen first set via the frontend with the following command: jq -r .settings.application.password /var/lib/changedetection-io/url-watches.json",
                "nixName": "environmentFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "group",
                "desc": "Group account under which changedetection-io runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"changedetection-io\""
            },
            {
                "name": "listenAddress",
                "desc": "Address the server will listen on.",
                "nixName": "listenAddress",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "playwrightSupport",
                "desc": "Enable support for fetching web pages using playwright and Chromium.This starts a headless Chromium controlled by puppeteer in an ocicontainer.   Playwright can currently leak memory. See  https://github.com/dgtlmoon/changedetection.io/wiki/Playwright-content-fetcher#playwright-memory-leak",
                "nixName": "playwrightSupport",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "port",
                "desc": "Port the server will listen on.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "5000"
            },
            {
                "name": "user",
                "desc": "User account under which changedetection-io runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"changedetection-io\""
            },
            {
                "name": "webDriverSupport",
                "desc": "Enable support for fetching web pages using WebDriver and Chromium.This starts a headless chromium controlled by puppeteer in an ocicontainer.   Playwright can currently leak memory. See  https://github.com/dgtlmoon/changedetection.io/wiki/Playwright-content-fetcher#playwright-memory-leak",
                "nixName": "webDriverSupport",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Lidarr is a music collection manager for Usenet and BitTorrent users.",
        "desc": "A Usenet/BitTorrent music downloader",
        "tags": [
            "Automation"
        ],
        "website": "https://lidarr.audio/",
        "logo": "https://lidarr.audio/img/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "lidarr",
        "options": [
            {
                "name": "dataDir",
                "desc": "The directory where Lidarr stores its data files.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"/var/lib/lidarr/.config/Lidarr\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Lidarr, a Usenet/BitTorrent music downloader.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which Lidarr runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"lidarr\""
            },
            {
                "name": "openFirewall",
                "desc": "Open ports in the firewall for Lidarr",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The lidarr package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.lidarr"
            },
            {
                "name": "user",
                "desc": "User account under which Lidarr runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"lidarr\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Headphones",
        "desc": "Automatic music downloader for SABnzbd",
        "tags": [
            "Automation"
        ],
        "website": "https://github.com/rembo10/headphones",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "headphones",
        "options": [
            {
                "name": "configFile",
                "desc": "Path to config file.",
                "nixName": "configFile",
                "type": "path",
                "value": "\"${config.services.headphones.dataDir}/config.ini\""
            },
            {
                "name": "dataDir",
                "desc": "Path where to store data files.",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/headphones\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable the headphones server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group to run the service as",
                "nixName": "group",
                "type": "string",
                "value": "\"headphones\""
            },
            {
                "name": "host",
                "desc": "Host to listen on.",
                "nixName": "host",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "port",
                "desc": "Port to bind to.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8181"
            },
            {
                "name": "user",
                "desc": "User to run the service as",
                "nixName": "user",
                "type": "string",
                "value": "\"headphones\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Sonarr ",
        "desc": "Smart PVR for newsgroup and bittorrent users",
        "tags": [
            "Automation"
        ],
        "website": "https://sonarr.tv/",
        "logo": "https://sonarr.tv/img/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "sonarr",
        "options": [
            {
                "name": "dataDir",
                "desc": "The directory where Sonarr stores its data files.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"/var/lib/sonarr/.config/NzbDrone\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Sonarr.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which Sonaar runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"sonarr\""
            },
            {
                "name": "openFirewall",
                "desc": "Open ports in the firewall for the Sonarr web interface",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The sonarr package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.sonarr"
            },
            {
                "name": "user",
                "desc": "User account under which Sonaar runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"sonarr\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Radarr",
        "desc": "A Usenet/BitTorrent movie downloader",
        "tags": [
            "Automation"
        ],
        "website": "https://radarr.video/",
        "logo": "https://radarr.video/img/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "radarr",
        "options": [
            {
                "name": "dataDir",
                "desc": "The directory where Radarr stores its data files.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"/var/lib/radarr/.config/Radarr\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Radarr, a UsetNet/BitTorrent movie downloader.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which Radarr runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"radarr\""
            },
            {
                "name": "openFirewall",
                "desc": "Open ports in the firewall for the Radarr web interface.",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The radarr package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.radarr"
            },
            {
                "name": "user",
                "desc": "User account under which Radarr runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"radarr\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Healthchecks",
        "desc": "A cron monitoring tool written in Python & Django",
        "tags": [
            "Monitoring"
        ],
        "website": "https://github.com/healthchecks/healthchecks",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "healthchecks",
        "options": [
            {
                "name": "dataDir",
                "desc": "The directory used to store all data for healthchecks.   If left as the default value this directory will automatically becreated before the healthchecks server starts, otherwise you areresponsible for ensuring the directory exists with appropriate ownershipand permissions.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"/var/lib/healthchecks\""
            },
            {
                "name": "enable",
                "desc": "Enable healthchecks. It is expected to be run behind a HTTP reverseproxy.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group account under which healthchecks runs.   If left as the default value this group will automatically be createdon system activation, otherwise you are responsible for ensuring thegroup exists before the healthchecks service starts.",
                "nixName": "group",
                "type": "string",
                "value": "\"healthchecks\""
            },
            {
                "name": "listenAddress",
                "desc": "Address the server will listen on.",
                "nixName": "listenAddress",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "package",
                "desc": "The healthchecks package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.healthchecks"
            },
            {
                "name": "port",
                "desc": "Port the server will listen on.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8000"
            },
            {
                "name": "settings",
                "desc": "Environment variables which are read by healthchecks (local)_settings.py .  Settings which are explicitly covered in options below, aretype-checked and/or transformed before added to the environment,everything else is passed as a string.  See  https://healthchecks.io/docs/self_hosted_configuration/ for a full documentation of settings.  We add additional variables to this list inside the packages local_settings.py.     STATIC_ROOT  to set a state directory for dynamicallygenerated static files.   SECRET_KEY_FILE  to read  SECRET_KEY  from afile at runtime and keep it out of /nix/store.   _FILE  variants for several values that hold sensitiveinformation in  Healthchecksconfiguration  so that they also can be read from a file and kept outof /nix/store. To see which values have support for a  _FILE variant, run:   nix-instantiate --eval --expr '(import <nixpkgs> {}).healthchecks.secrets'   or  nix eval 'nixpkgs#healthchecks.secrets'  if the flakesupport has been enabled.     If the same variable is set in both  settings  and settingsFile  the value from  settingsFile  haspriority.",
                "nixName": "settings",
                "type": "attribute set of string",
                "value": null
            },
            {
                "name": "settings.ALLOWED_HOSTS",
                "desc": "The host/domain names that this site can serve.",
                "nixName": "settings.ALLOWED_HOSTS",
                "type": "list of string",
                "value": "[\n  \"*\"\n]"
            },
            {
                "name": "settings.DB",
                "desc": "Database engine to use.",
                "nixName": "settings.DB",
                "type": "one of \"sqlite\", \"postgres\", \"mysql\"",
                "value": "\"sqlite\""
            },
            {
                "name": "settings.DB_NAME",
                "desc": "Database name.",
                "nixName": "settings.DB_NAME",
                "type": "string",
                "value": "if config.services.healthchecks.settings.DB == \"sqlite\"\nthen \"${config.services.healthchecks.dataDir}/healthchecks.sqlite\"\nelse \"hc\"\n"
            },
            {
                "name": "settings.DEBUG",
                "desc": "Enable debug mode.",
                "nixName": "settings.DEBUG",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.REGISTRATION_OPEN",
                "desc": "A boolean that controls whether site visitors can create newaccounts. Set it to false if you are setting up a private Healthchecksinstance, but it needs to be publicly accessible (so, for example, yourcloud services can send pings to it). If you close new userregistration, you can still selectively invite users to your teamaccount.",
                "nixName": "settings.REGISTRATION_OPEN",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.SECRET_KEY_FILE",
                "desc": "Path to a file containing the secret key.",
                "nixName": "settings.SECRET_KEY_FILE",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "settingsFile",
                "desc": "Environment variables which are read by healthchecks (local)_settings.py .  Settings which are explicitly covered in options below, aretype-checked and/or transformed before added to the environment,everything else is passed as a string.  See  https://healthchecks.io/docs/self_hosted_configuration/ for a full documentation of settings.  We add additional variables to this list inside the packages local_settings.py.     STATIC_ROOT  to set a state directory for dynamicallygenerated static files.   SECRET_KEY_FILE  to read  SECRET_KEY  from afile at runtime and keep it out of /nix/store.   _FILE  variants for several values that hold sensitiveinformation in  Healthchecksconfiguration  so that they also can be read from a file and kept outof /nix/store. To see which values have support for a  _FILE variant, run:   nix-instantiate --eval --expr '(import <nixpkgs> {}).healthchecks.secrets'   or  nix eval 'nixpkgs#healthchecks.secrets'  if the flakesupport has been enabled.     If the same variable is set in both  settings  and settingsFile  the value from  settingsFile  haspriority.",
                "nixName": "settingsFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "user",
                "desc": "User account under which healthchecks runs.   If left as the default value this user will automatically be createdon system activation, otherwise you are responsible for ensuring theuser exists before the healthchecks service starts.",
                "nixName": "user",
                "type": "string",
                "value": "\"healthchecks\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Syncthing",
        "desc": "Open Source Continuous File Synchronization",
        "tags": [
            "File Transfer & Synchronization"
        ],
        "website": "https://syncthing.net/",
        "logo": "https://syncthing.net/img/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "syncthing",
        "options": [
            {
                "name": "all_proxy",
                "desc": "Overwrites the all_proxy environment variable for the Syncthingprocess to the given value. This is normally used to let Syncthingconnect through a SOCKS5 proxy server. See  https://docs.syncthing.net/users/proxying.html .",
                "nixName": "all_proxy",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "cert",
                "desc": "Path to the  cert.pem  file, which will be copied intoSyncthing\u2019s  configDir .",
                "nixName": "cert",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "configDir",
                "desc": "The path where the settings and keys will exist.",
                "nixName": "configDir",
                "type": "path",
                "value": "<rendered-html><ul>\n<li><p>if <code>stateVersion &gt;= 19.03</code>:</p>\n<pre><code>config.services.syncthing.dataDir + &quot;/.config/syncthing&quot;</code></pre></li>\n<li><p>otherwise:</p>\n<pre><code>config.services.syncthing.dataDir</code></pre></li>\n</ul>\n</rendered-html>"
            },
            {
                "name": "dataDir",
                "desc": "The path where synchronised directories will exist.",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/syncthing\""
            },
            {
                "name": "databaseDir",
                "desc": "The directory containing the database and logs.",
                "nixName": "databaseDir",
                "type": "path",
                "value": "config.services.syncthing.configDir"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Syncthing, a self-hosted open-source alternative toDropbox and Bittorrent Sync.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraFlags",
                "desc": "Extra flags passed to the syncthing command in the servicedefinition.",
                "nixName": "extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "The group to run Syncthing under. By default, a group named syncthing  will be created.",
                "nixName": "group",
                "type": "string",
                "value": "\"syncthing\""
            },
            {
                "name": "guiAddress",
                "desc": "The address to serve the web interface at.",
                "nixName": "guiAddress",
                "type": "string",
                "value": "\"127.0.0.1:8384\""
            },
            {
                "name": "key",
                "desc": "Path to the  key.pem  file, which will be copied intoSyncthing\u2019s  configDir .",
                "nixName": "key",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "openDefaultPorts",
                "desc": "Whether to open the default ports in the firewall: TCP/UDP 22000 fortransfers and UDP 21027 for discovery.  If multiple users are running Syncthing on this machine, you willneed to manually open a set of ports for each instance and leave thisdisabled. Alternatively, if you are running only a single instance onthis machine using the default ports, enable this.",
                "nixName": "openDefaultPorts",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "overrideDevices",
                "desc": "Whether to delete the devices which are not configured via the  devices option. If set to  false , devices added via the webinterface will persist and will have to be deleted manually.",
                "nixName": "overrideDevices",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "overrideFolders",
                "desc": "Whether to delete the folders which are not configured via the  folders option. If set to  false , folders added via the webinterface will persist and will have to be deleted manually.",
                "nixName": "overrideFolders",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "package",
                "desc": "The syncthing package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.syncthing"
            },
            {
                "name": "relay.enable",
                "desc": "Whether to enable Syncthing relay service.",
                "nixName": "relay.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "relay.extraOptions",
                "desc": "Extra command line arguments to pass to strelaysrv.",
                "nixName": "relay.extraOptions",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "relay.globalRateBps",
                "desc": "Global bandwidth rate limit in bytes per second.",
                "nixName": "relay.globalRateBps",
                "type": "null or (positive integer, meaning >0)",
                "value": "null"
            },
            {
                "name": "relay.listenAddress",
                "desc": "Address to listen on for relay traffic.",
                "nixName": "relay.listenAddress",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "relay.perSessionRateBps",
                "desc": "Per session bandwidth rate limit in bytes per second.",
                "nixName": "relay.perSessionRateBps",
                "type": "null or (positive integer, meaning >0)",
                "value": "null"
            },
            {
                "name": "relay.pools",
                "desc": "Relay pools to join. If null, uses the default global pool.",
                "nixName": "relay.pools",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "relay.port",
                "desc": "Port to listen on for relay traffic. This port should be added to networking.firewall.allowedTCPPorts .",
                "nixName": "relay.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "22067"
            },
            {
                "name": "relay.providedBy",
                "desc": "Human-readable description of the provider of the relay (you).",
                "nixName": "relay.providedBy",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "relay.statusListenAddress",
                "desc": "Address to listen on for serving the relay status API.",
                "nixName": "relay.statusListenAddress",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "relay.statusPort",
                "desc": "Port to listen on for serving the relay status API. This port shouldbe added to  networking.firewall.allowedTCPPorts .",
                "nixName": "relay.statusPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "22070"
            },
            {
                "name": "settings",
                "desc": "Extra configuration options for Syncthing. See  https://docs.syncthing.net/users/config.html .Note that this attribute set does not exactly match the documented xmlformat. Instead, this is the format of the json rest api. There areslight differences. For example, this xml:       < options >      < listenAddress >default</ listenAddress >      < minHomeDiskFree   unit=  \"%\" >1</ minHomeDiskFree >    </ options >     corresponds to the json:        {        options  :   {          listenAddresses   =   [            \"default\"          ];          minHomeDiskFree   =   {            unit   =   \"%\"  ;            value   =   1;          }  ;        }  ;      }",
                "nixName": "settings",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "settings.devices",
                "desc": "Peers/devices which Syncthing should communicate with.  Note that you can still add devices manually, but those changes willbe reverted on restart if  overrideDevices is enabled.",
                "nixName": "settings.devices",
                "type": "attribute set of (JSON value)",
                "value": "{ }"
            },
            {
                "name": "settings.devices.<name>.autoAcceptFolders",
                "desc": "Automatically create or share folders that this device advertises atthe default path. See  https://docs.syncthing.net/users/config.html?highlight=autoaccept#config-file-format .",
                "nixName": "settings.devices.<name>.autoAcceptFolders",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.devices.<name>.id",
                "desc": "The device ID. See  https://docs.syncthing.net/dev/device-ids.html .",
                "nixName": "settings.devices.<name>.id",
                "type": "string",
                "value": null
            },
            {
                "name": "settings.devices.<name>.name",
                "desc": "The name of the device.",
                "nixName": "settings.devices.<name>.name",
                "type": "string",
                "value": "\"\u2039name\u203a\""
            },
            {
                "name": "settings.folders",
                "desc": "Folders which should be shared by Syncthing.  Note that you can still add folders manually, but those changes willbe reverted on restart if  overrideFolders is enabled.",
                "nixName": "settings.folders",
                "type": "attribute set of (JSON value)",
                "value": "{ }"
            },
            {
                "name": "settings.folders.<name>.copyOwnershipFromParent",
                "desc": "On Unix systems, tries to copy file/folder ownership from the parentdirectory (the directory it\u2019s located in). Requires running Syncthing asa privileged user, or granting it additional capabilities (e.g.CAP_CHOWN on Linux).",
                "nixName": "settings.folders.<name>.copyOwnershipFromParent",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.folders.<name>.devices",
                "desc": "The devices this folder should be shared with. Each device must bedefined in the  devices option.",
                "nixName": "settings.folders.<name>.devices",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "settings.folders.<name>.enable",
                "desc": "Whether to share this folder. This option is useful when you want todefine all folders in one place, but not every machine should share allfolders.",
                "nixName": "settings.folders.<name>.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings.folders.<name>.id",
                "desc": "The ID of the folder. Must be the same on all devices.",
                "nixName": "settings.folders.<name>.id",
                "type": "string",
                "value": "\"\u2039name\u203a\""
            },
            {
                "name": "settings.folders.<name>.label",
                "desc": "The label of the folder.",
                "nixName": "settings.folders.<name>.label",
                "type": "string",
                "value": "\"\u2039name\u203a\""
            },
            {
                "name": "settings.folders.<name>.path",
                "desc": "The path to the folder which should be shared. Only absolute paths(starting with  / ) and paths relative to the  user \u2019shome directory (starting with  ~/ ) are allowed.",
                "nixName": "settings.folders.<name>.path",
                "type": "string starting with / or ~/",
                "value": "\"\u2039name\u203a\""
            },
            {
                "name": "settings.folders.<name>.versioning",
                "desc": "How to keep changed/deleted files with Syncthing. There are 4different types of versioning with different parameters. See  https://docs.syncthing.net/users/versioning.html .",
                "nixName": "settings.folders.<name>.versioning",
                "type": "null or (JSON value)",
                "value": "null"
            },
            {
                "name": "settings.folders.<name>.versioning.type",
                "desc": "The type of versioning. See  https://docs.syncthing.net/users/versioning.html .",
                "nixName": "settings.folders.<name>.versioning.type",
                "type": "one of \"external\", \"simple\", \"staggered\", \"trashcan\"",
                "value": null
            },
            {
                "name": "settings.options",
                "desc": "The options element contains all other global configurationoptions",
                "nixName": "settings.options",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "settings.options.limitBandwidthInLan",
                "desc": "Whether to apply bandwidth limits to devices in the same broadcastdomain as the local device.",
                "nixName": "settings.options.limitBandwidthInLan",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "settings.options.localAnnounceEnabled",
                "desc": "Whether to send announcements to the local LAN, also use suchannouncements to find other devices.",
                "nixName": "settings.options.localAnnounceEnabled",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "settings.options.localAnnouncePort",
                "desc": "The port on which to listen and send IPv4 broadcast announcementsto.",
                "nixName": "settings.options.localAnnouncePort",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "settings.options.maxFolderConcurrency",
                "desc": "This option controls how many folders may concurrently be inI/O-intensive operations such as syncing or scanning. The mechanism isdescribed in detail in a  separatechapter .",
                "nixName": "settings.options.maxFolderConcurrency",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "settings.options.relaysEnabled",
                "desc": "When true, relays will be connected to and potentially used fordevice to device connections.",
                "nixName": "settings.options.relaysEnabled",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "settings.options.urAccepted",
                "desc": "Whether the user has accepted to submit anonymous usage data. Thedefault, 0, mean the user has not made a choice, and Syncthing will askat some point in the future. \u201c-1\u201d means no, a number above zero meansthat that version of usage reporting has been accepted.",
                "nixName": "settings.options.urAccepted",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "systemService",
                "desc": "Whether to auto-launch Syncthing as a system service.",
                "nixName": "systemService",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "user",
                "desc": "The user to run Syncthing as. By default, a user named syncthing  will be created whose home directory is  dataDir .",
                "nixName": "user",
                "type": "string",
                "value": "\"syncthing\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Stalwart JMAP",
        "desc": "Secure & Modern All-in-One Mail Server (IMAP, JMAP, SMTP)",
        "tags": [
            "Communication - Email - Mail Delivery Agents"
        ],
        "website": "https://github.com/stalwartlabs/mail-server",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "stalwart-mail",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable the Stalwart all-in-one email server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The stalwart-mail package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.stalwart-mail"
            },
            {
                "name": "settings",
                "desc": "Configuration options for the Stalwart email server. See  https://stalw.art/docs/category/configuration for available options.  By default, the module is configured to store everything locally.",
                "nixName": "settings",
                "type": "TOML value",
                "value": "{ }"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Discourse",
        "desc": "Discourse is an open source discussion platform",
        "tags": [
            "Communication - Social Networks and Forums"
        ],
        "website": "https://www.discourse.org/",
        "logo": "https://www.discourse.org/a/img/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "discourse",
        "options": [
            {
                "name": "admin.email",
                "desc": "The admin user email address.",
                "nixName": "admin.email",
                "type": "string",
                "value": null
            },
            {
                "name": "admin.fullName",
                "desc": "The admin user\u2019s full name.",
                "nixName": "admin.fullName",
                "type": "string",
                "value": null
            },
            {
                "name": "admin.passwordFile",
                "desc": "A path to a file containing the admin user\u2019s password.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "admin.passwordFile",
                "type": "path",
                "value": null
            },
            {
                "name": "admin.skipCreate",
                "desc": "Do not create the admin account, instead rely on other existing adminaccounts.",
                "nixName": "admin.skipCreate",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "admin.username",
                "desc": "The admin user username.",
                "nixName": "admin.username",
                "type": "string",
                "value": null
            },
            {
                "name": "backendSettings",
                "desc": "Additional settings to put in the  discourse.conf  file.  Look in the  discourse_defaults.conf file in the upstream distribution to find available options.  Setting an option to  null  means \u201cdefine variable, butleave right-hand side empty\u201d.",
                "nixName": "backendSettings",
                "type": "attribute set of (null or string or signed integer or boolean or floating point number)",
                "value": "{ }"
            },
            {
                "name": "database.createLocally",
                "desc": "Whether a database should be automatically created on the local host.Set this to  false  if you plan on provisioning a localdatabase yourself. This has no effect if  services.discourse.database.host  is customized.",
                "nixName": "database.createLocally",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "database.host",
                "desc": "Discourse database hostname.  null  means \u201cprefer localunix socket connection\u201d.",
                "nixName": "database.host",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "database.ignorePostgresqlVersion",
                "desc": "Whether to allow other versions of PostgreSQL than the recommendedone. Only effective when  services.discourse.database.createLocally  isenabled.",
                "nixName": "database.ignorePostgresqlVersion",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "database.name",
                "desc": "Discourse database name.",
                "nixName": "database.name",
                "type": "string",
                "value": "\"discourse\""
            },
            {
                "name": "database.passwordFile",
                "desc": "File containing the Discourse database user password.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "database.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "database.pool",
                "desc": "Database connection pool size.",
                "nixName": "database.pool",
                "type": "signed integer",
                "value": "8"
            },
            {
                "name": "database.username",
                "desc": "Discourse database user.",
                "nixName": "database.username",
                "type": "string",
                "value": "\"discourse\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Discourse, an open source discussion platform.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableACME",
                "desc": "Whether an ACME certificate should be used to secure connections tothe server.",
                "nixName": "enableACME",
                "type": "boolean",
                "value": "<rendered-html><p><code>true</code>, unless <code class=\"interpreted-text\"\nrole=\"option\">services.discourse.sslCertificate</code> and <code\nclass=\"interpreted-text\"\nrole=\"option\">services.discourse.sslCertificateKey</code> are set.</p>\n</rendered-html>"
            },
            {
                "name": "hostname",
                "desc": "The hostname to serve Discourse on.",
                "nixName": "hostname",
                "type": "string",
                "value": "config.networking.fqdnOrHostName"
            },
            {
                "name": "mail.contactEmailAddress",
                "desc": "Email address of key contact responsible for this site. Used forcritical notifications, as well as on the  /about  contactform for urgent matters.",
                "nixName": "mail.contactEmailAddress",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "mail.incoming.apiKeyFile",
                "desc": "A file containing the Discourse API key used to add posts andmessages from mail. If left at its default value  null , onewill be automatically generated.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "mail.incoming.apiKeyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "mail.incoming.enable",
                "desc": "Whether to set up Postfix to receive incoming mail.",
                "nixName": "mail.incoming.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "mail.incoming.mailReceiverPackage",
                "desc": "The discourse-mail-receiver package to use.",
                "nixName": "mail.incoming.mailReceiverPackage",
                "type": "package",
                "value": "pkgs.discourse-mail-receiver"
            },
            {
                "name": "mail.incoming.replyEmailAddress",
                "desc": "Template for reply by email incoming email address, for example:%{reply_key}@reply.example.com or replies+%{reply_key}@example.com",
                "nixName": "mail.incoming.replyEmailAddress",
                "type": "string",
                "value": "\"%{reply_key}@${config.services.discourse.hostname}\""
            },
            {
                "name": "mail.notificationEmailAddress",
                "desc": "The  from:  email address used when sending all essentialsystem emails. The domain specified here must have SPF, DKIM and reversePTR records set correctly for email to arrive.",
                "nixName": "mail.notificationEmailAddress",
                "type": "string",
                "value": "\"${if config.services.discourse.mail.incoming.enable then \"notifications\" else \"noreply\"}@${config.services.discourse.hostname}\"\n"
            },
            {
                "name": "mail.outgoing.authentication",
                "desc": "Authentication type to use, see  https://api.rubyonrails.org/classes/ActionMailer/Base.html",
                "nixName": "mail.outgoing.authentication",
                "type": "null or one of \"plain\", \"login\", \"cram_md5\"",
                "value": "null"
            },
            {
                "name": "mail.outgoing.domain",
                "desc": "HELO domain to use for outgoing mail.",
                "nixName": "mail.outgoing.domain",
                "type": "string",
                "value": "config.services.discourse.hostname"
            },
            {
                "name": "mail.outgoing.enableStartTLSAuto",
                "desc": "Whether to try to use StartTLS.",
                "nixName": "mail.outgoing.enableStartTLSAuto",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "mail.outgoing.forceTLS",
                "desc": "Force implicit TLS as per RFC 8314 3.3.",
                "nixName": "mail.outgoing.forceTLS",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "mail.outgoing.opensslVerifyMode",
                "desc": "How OpenSSL checks the certificate, see  https://api.rubyonrails.org/classes/ActionMailer/Base.html",
                "nixName": "mail.outgoing.opensslVerifyMode",
                "type": "string",
                "value": "\"peer\""
            },
            {
                "name": "mail.outgoing.passwordFile",
                "desc": "A file containing the password of the SMTP server account.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "mail.outgoing.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "mail.outgoing.port",
                "desc": "The port of the SMTP server Discourse should use to send email.",
                "nixName": "mail.outgoing.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "25"
            },
            {
                "name": "mail.outgoing.serverAddress",
                "desc": "The address of the SMTP server Discourse should use to sendemail.",
                "nixName": "mail.outgoing.serverAddress",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "mail.outgoing.username",
                "desc": "The username of the SMTP server.",
                "nixName": "mail.outgoing.username",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "nginx.enable",
                "desc": "Whether an  nginx  virtual host should be set up to serveDiscourse. Only disable if you\u2019re planning to use a different webserver, which is not recommended.",
                "nixName": "nginx.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "package",
                "desc": "The discourse package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.discourse"
            },
            {
                "name": "plugins",
                "desc": "Plugins to install as part of Discourse, expressed as a list ofderivations.",
                "nixName": "plugins",
                "type": "list of package",
                "value": "[ ]"
            },
            {
                "name": "redis.dbNumber",
                "desc": "Redis database number.",
                "nixName": "redis.dbNumber",
                "type": "signed integer",
                "value": "0"
            },
            {
                "name": "redis.host",
                "desc": "Redis server hostname.",
                "nixName": "redis.host",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "redis.passwordFile",
                "desc": "File containing the Redis password.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "redis.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "redis.useSSL",
                "desc": "Connect to Redis with SSL.",
                "nixName": "redis.useSSL",
                "type": "boolean",
                "value": "config.services.discourse.redis.host != \"localhost\""
            },
            {
                "name": "secretKeyBaseFile",
                "desc": "The path to a file containing the  secret_key_base secret.  Discourse uses  secret_key_base  to encrypt the cookiestore, which contains session data, and to digest user auth tokens.  Needs to be a 64 byte long string of hexadecimal characters. You cangenerate one by running   openssl rand -hex 64 >/path/to/secret_key_base_file   This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "secretKeyBaseFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "sidekiqProcesses",
                "desc": "How many Sidekiq processes should be spawned.",
                "nixName": "sidekiqProcesses",
                "type": "signed integer",
                "value": "1"
            },
            {
                "name": "siteSettings",
                "desc": "Discourse site settings. These are the settings that can be changedfrom the UI. This only defines their default values: they can still beoverridden from the UI.  Available settings can be found by looking in the  site_settings.yml file of the upstream distribution. To find a setting\u2019s path, you onlyneed to care about the first two levels; i.e. its category and name. Seethe example.  Settings containing secret data should be set to an attribute setcontaining the attribute  _secret  - a string pointing to afile containing the value the option should be set to. See the exampleto get a better picture of this: in the resulting  config/nixos_site_settings.json  file, the login.github_client_secret  key will be set to the contentsof the  /run/keys/discourse_github_client_secret  file.",
                "nixName": "siteSettings",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "sslCertificate",
                "desc": "The path to the server SSL certificate. Set this to enable SSL.",
                "nixName": "sslCertificate",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "sslCertificateKey",
                "desc": "The path to the server SSL certificate key. Set this to enableSSL.",
                "nixName": "sslCertificateKey",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "unicornTimeout",
                "desc": "Time in seconds before a request to Unicorn times out.  This can be raised if the system Discourse is running on is too slowto handle many requests within 30 seconds.",
                "nixName": "unicornTimeout",
                "type": "signed integer",
                "value": "30"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Mastodon",
        "desc": "Self-hosted, globally interconnected microblogging software based on ActivityPub",
        "tags": [
            "Communication - Social Networks and Forums"
        ],
        "website": "https://joinmastodon.org",
        "logo": "https://joinmastodon.org/_next/static/media/favicon-32x32.3a702fe9.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "mastodon",
        "options": [
            {
                "name": "automaticMigrations",
                "desc": "Do automatic database migrations.",
                "nixName": "automaticMigrations",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "configureNginx",
                "desc": "Configure nginx as a reverse proxy for mastodon. Note that this makessome assumptions on your setup, and sets settings that will affect othervirtualHosts running on your nginx instance, if any. Alternatively youcan configure a reverse-proxy of your choice to serve these paths:   / -> $(nix-instantiate --eval '<nixpkgs>' -A mastodon.outPath)/public    / -> 127.0.0.1:{{ webPort }}  (If there was no file inthe directory above.)   /system/ -> /var/lib/mastodon/public-system/    /api/v1/streaming/ -> 127.0.0.1:{{ streamingPort }}   Make sure that websockets are forwarded properly. You might want toset up caching of some requests. Take a look at mastodon\u2019s providednginx configuration at https://github.com/mastodon/mastodon/blob/master/dist/nginx.conf .",
                "nixName": "configureNginx",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "database.createLocally",
                "desc": "Configure local PostgreSQL database server for Mastodon.",
                "nixName": "database.createLocally",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "database.host",
                "desc": "Database host address or unix socket.",
                "nixName": "database.host",
                "type": "string",
                "value": "\"/run/postgresql\""
            },
            {
                "name": "database.name",
                "desc": "Database name.",
                "nixName": "database.name",
                "type": "string",
                "value": "\"mastodon\""
            },
            {
                "name": "database.passwordFile",
                "desc": "A file containing the password corresponding to  database.user .",
                "nixName": "database.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "database.port",
                "desc": "Database host port.",
                "nixName": "database.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "if config.services.mastodon.database.createLocally\nthen null\nelse 5432\n"
            },
            {
                "name": "database.user",
                "desc": "Database user.",
                "nixName": "database.user",
                "type": "string",
                "value": "\"mastodon\""
            },
            {
                "name": "elasticsearch.host",
                "desc": "Elasticsearch host. If it is not null, Elasticsearch full text searchwill be enabled.",
                "nixName": "elasticsearch.host",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "elasticsearch.passwordFile",
                "desc": "Path to file containing password for optionally authenticating withElasticsearch.",
                "nixName": "elasticsearch.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "elasticsearch.port",
                "desc": "Elasticsearch port.",
                "nixName": "elasticsearch.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9200"
            },
            {
                "name": "elasticsearch.preset",
                "desc": "It controls the ElasticSearch indices configuration (number of shardsand replica).",
                "nixName": "elasticsearch.preset",
                "type": "one of \"single_node_cluster\", \"small_cluster\", \"large_cluster\"",
                "value": "\"single_node_cluster\""
            },
            {
                "name": "elasticsearch.user",
                "desc": "Used for optionally authenticating with Elasticsearch.",
                "nixName": "elasticsearch.user",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Mastodon, a federated social network server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableUnixSocket",
                "desc": "Instead of binding to an IP address like 127.0.0.1, you may bind to aUnix socket. This variable is process-specific, e.g. you need differentvalues for every process, and it works for both web (Puma) processes andstreaming API (Node.js) processes.",
                "nixName": "enableUnixSocket",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "extraConfig",
                "desc": "Extra environment variables to pass to all mastodon services.",
                "nixName": "extraConfig",
                "type": "attribute set",
                "value": "{ }"
            },
            {
                "name": "extraEnvFiles",
                "desc": "Extra environment files to pass to all mastodon services. Useful forpassing down environmental secrets.",
                "nixName": "extraEnvFiles",
                "type": "list of path",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "Group under which mastodon runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"mastodon\""
            },
            {
                "name": "localDomain",
                "desc": "The domain serving your Mastodon instance.",
                "nixName": "localDomain",
                "type": "string",
                "value": null
            },
            {
                "name": "mediaAutoRemove.enable",
                "desc": "Automatically remove remote media attachments and preview cards olderthan the configured amount of days.  Recommended in  https://docs.joinmastodon.org/admin/setup/ .",
                "nixName": "mediaAutoRemove.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "mediaAutoRemove.olderThanDays",
                "desc": "How old remote media needs to be in order to be removed.",
                "nixName": "mediaAutoRemove.olderThanDays",
                "type": "signed integer",
                "value": "30"
            },
            {
                "name": "mediaAutoRemove.startAt",
                "desc": "How often to remove remote media.  The format is described in   systemd.time(7)  .",
                "nixName": "mediaAutoRemove.startAt",
                "type": "string",
                "value": "\"daily\""
            },
            {
                "name": "otpSecretFile",
                "desc": "Path to file containing the OTP secret. A new OTP secret can begenerated by running:   nix build -f '<nixpkgs>' mastodon; cd result; bin/rake secret   If this file does not exist, it will be created with a new OTPsecret.",
                "nixName": "otpSecretFile",
                "type": "string",
                "value": "\"/var/lib/mastodon/secrets/otp-secret\""
            },
            {
                "name": "package",
                "desc": "Mastodon package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.mastodon"
            },
            {
                "name": "redis.createLocally",
                "desc": "Configure local Redis server for Mastodon.",
                "nixName": "redis.createLocally",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "redis.enableUnixSocket",
                "desc": "Use Unix socket",
                "nixName": "redis.enableUnixSocket",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "redis.host",
                "desc": "Redis host.",
                "nixName": "redis.host",
                "type": "null or string",
                "value": "if config.services.mastodon.redis.createLocally && !config.services.mastodon.redis.enableUnixSocket then \"127.0.0.1\" else null\n"
            },
            {
                "name": "redis.passwordFile",
                "desc": "A file containing the password for Redis database.",
                "nixName": "redis.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "redis.port",
                "desc": "Redis port.",
                "nixName": "redis.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "if config.services.mastodon.redis.createLocally && !config.services.mastodon.redis.enableUnixSocket then 31637 else null\n"
            },
            {
                "name": "secretKeyBaseFile",
                "desc": "Path to file containing the secret key base. A new secret key basecan be generated by running:   nix build -f '<nixpkgs>' mastodon; cd result; bin/rake secret   If this file does not exist, it will be created with a new secret keybase.",
                "nixName": "secretKeyBaseFile",
                "type": "string",
                "value": "\"/var/lib/mastodon/secrets/secret-key-base\""
            },
            {
                "name": "sidekiqPort",
                "desc": "TCP port used by the mastodon-sidekiq service.",
                "nixName": "sidekiqPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "55002"
            },
            {
                "name": "sidekiqProcesses",
                "desc": "How many Sidekiq processes should be used to handle background jobs,and which job classes they handle.  Read the  upstreamdocumentation  before configuring this!",
                "nixName": "sidekiqProcesses",
                "type": "attribute set of (submodule)",
                "value": "{\n  all = {\n    jobClasses = [ ];\n    threads = null;\n  };\n}"
            },
            {
                "name": "sidekiqProcesses.<name>.jobClasses",
                "desc": "If not empty, which job classes should be executed by this process. Only one process should handle the \u2018scheduler\u2019 class. If left empty,this process will handle the \u2018scheduler\u2019 class.",
                "nixName": "sidekiqProcesses.<name>.jobClasses",
                "type": "list of (one of \"default\", \"push\", \"pull\", \"mailers\", \"scheduler\", \"ingress\")",
                "value": null
            },
            {
                "name": "sidekiqProcesses.<name>.threads",
                "desc": "Number of threads this process should use for executing jobs. Ifnull, the configured  sidekiqThreads  are used.",
                "nixName": "sidekiqProcesses.<name>.threads",
                "type": "null or signed integer",
                "value": null
            },
            {
                "name": "sidekiqThreads",
                "desc": "Worker threads used by the mastodon-sidekiq-all service. If sidekiqProcesses  is configured and any processes specifynull  threads , this value is used.",
                "nixName": "sidekiqThreads",
                "type": "signed integer",
                "value": "25"
            },
            {
                "name": "smtp.authenticate",
                "desc": "Authenticate with the SMTP server using username and password.",
                "nixName": "smtp.authenticate",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "smtp.createLocally",
                "desc": "Configure local Postfix SMTP server for Mastodon.",
                "nixName": "smtp.createLocally",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "smtp.fromAddress",
                "desc": "\u201cFrom\u201d address used when sending Emails to users.",
                "nixName": "smtp.fromAddress",
                "type": "string",
                "value": null
            },
            {
                "name": "smtp.host",
                "desc": "SMTP host used when sending emails to users.",
                "nixName": "smtp.host",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "smtp.passwordFile",
                "desc": "Path to file containing the SMTP password.",
                "nixName": "smtp.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "smtp.port",
                "desc": "SMTP port used when sending emails to users.",
                "nixName": "smtp.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "25"
            },
            {
                "name": "smtp.user",
                "desc": "SMTP login name.",
                "nixName": "smtp.user",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "streamingProcesses",
                "desc": "Number of processes used by the mastodon-streaming service. Pleasedefine this explicitly, recommended is the amount of your CPU coresminus one.",
                "nixName": "streamingProcesses",
                "type": "positive integer, meaning >0",
                "value": null
            },
            {
                "name": "trustedProxy",
                "desc": "You need to set it to the IP from which your reverse proxy sendsrequests to Mastodon\u2019s web process, otherwise Mastodon will record thereverse proxy\u2019s own IP as the IP of all requests, which would be badbecause IP addresses are used for important rate limits and securityfunctions.",
                "nixName": "trustedProxy",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "user",
                "desc": "User under which mastodon runs. If it is set to \u201cmastodon\u201d, that userwill be created, otherwise it should be set to the name of a usercreated elsewhere. In both cases, the  mastodon  package willbe added to the user\u2019s package set and a tootctl wrapper to systempackages that switches to the configured account and load the rightenvironment.",
                "nixName": "user",
                "type": "string",
                "value": "\"mastodon\""
            },
            {
                "name": "vapidPrivateKeyFile",
                "desc": "Path to file containing the private key used for Web Push VoluntaryApplication Server Identification. A new keypair can be generated byrunning:   nix build -f '<nixpkgs>' mastodon; cd result; bin/rake webpush:generate_keys   If this file does not exist, it will be created with a new privatekey.",
                "nixName": "vapidPrivateKeyFile",
                "type": "string",
                "value": "\"/var/lib/mastodon/secrets/vapid-private-key\""
            },
            {
                "name": "vapidPublicKeyFile",
                "desc": "Path to file containing the public key used for Web Push VoluntaryApplication Server Identification. A new keypair can be generated byrunning:   nix build -f '<nixpkgs>' mastodon; cd result; bin/rake webpush:generate_keys   If  mastodon.vapidPrivateKeyFile does not exist, it andthis file will be created with a new keypair.",
                "nixName": "vapidPublicKeyFile",
                "type": "string",
                "value": "\"/var/lib/mastodon/secrets/vapid-public-key\""
            },
            {
                "name": "webPort",
                "desc": "TCP port used by the mastodon-web service.",
                "nixName": "webPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "55001"
            },
            {
                "name": "webProcesses",
                "desc": "Processes used by the mastodon-web service.",
                "nixName": "webProcesses",
                "type": "signed integer",
                "value": "2"
            },
            {
                "name": "webThreads",
                "desc": "Threads per process used by the mastodon-web service.",
                "nixName": "webThreads",
                "type": "signed integer",
                "value": "5"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Jitsi Meet",
        "desc": "Secure, Simple and Scalable Video Conferences",
        "tags": [
            "Communication - Video Conferencing"
        ],
        "website": "https://github.com/jitsi/jitsi-meet",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "jitsi-meet",
        "options": [
            {
                "name": "caddy.enable",
                "desc": "Whether to enable caddy reverse proxy to expose jitsi-meet.",
                "nixName": "caddy.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "config",
                "desc": "Client-side web application settings that override the defaults in config.js .  See  https://github.com/jitsi/jitsi-meet/blob/master/config.js for default configuration with comments.",
                "nixName": "config",
                "type": "attribute set",
                "value": "{ }"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Jitsi Meet - Secure, Simple and Scalable VideoConferences.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "excalidraw.enable",
                "desc": "Whether to enable Excalidraw collaboration backend for Jitsi.",
                "nixName": "excalidraw.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "excalidraw.port",
                "desc": "The port which the Excalidraw backend for Jitsi should listen to.",
                "nixName": "excalidraw.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "3002"
            },
            {
                "name": "extraConfig",
                "desc": "Text to append to  config.js  web application config file.  Can be used to insert JavaScript logic to determine user\u2019s region incascading bridges setup.",
                "nixName": "extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "hostName",
                "desc": "FQDN of the Jitsi Meet instance.",
                "nixName": "hostName",
                "type": "string",
                "value": null
            },
            {
                "name": "interfaceConfig",
                "desc": "Client-side web-app interface settings that override the defaults in interface_config.js .  See  https://github.com/jitsi/jitsi-meet/blob/master/interface_config.js for default configuration with comments.",
                "nixName": "interfaceConfig",
                "type": "attribute set",
                "value": "{ }"
            },
            {
                "name": "jibri.enable",
                "desc": "Whether to enable a Jibri instance and configure it to connect toProsody.  Additional configuration is possible with  services.jibri , and  services.jibri.finalizeScript  is especiallyuseful.",
                "nixName": "jibri.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "jicofo.enable",
                "desc": "Whether to enable JiCoFo instance and configure it to connect toProsody.  Additional configuration is possible with  services.jicofo .",
                "nixName": "jicofo.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "jigasi.enable",
                "desc": "Whether to enable jigasi instance and configure it to connect toProsody.  Additional configuration is possible with services.jigasi .",
                "nixName": "jigasi.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "nginx.enable",
                "desc": "Whether to enable nginx virtual host that will serve the javascriptapplication and act as a proxy for the XMPP server. Further nginxconfiguration can be done by adapting  services.nginx.virtualHosts.<hostName> . Whenthis is enabled, ACME will be used to retrieve a TLS certificate bydefault. To disable this, set the  services.nginx.virtualHosts.<hostName>.enableACME to  false  and if appropriate do the same for  services.nginx.virtualHosts.<hostName>.forceSSL .",
                "nixName": "nginx.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "prosody.enable",
                "desc": "Whether to configure Prosody to relay XMPP messages between JitsiMeet components. Turn this off if you want to configure it manually.",
                "nixName": "prosody.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "secureDomain.authentication",
                "desc": "The authentication type to be used by jitsi",
                "nixName": "secureDomain.authentication",
                "type": "string",
                "value": "\"internal_hashed\""
            },
            {
                "name": "secureDomain.enable",
                "desc": "Whether to enable Authenticated room creation.",
                "nixName": "secureDomain.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "videobridge.enable",
                "desc": "Jitsi Videobridge instance and configure it to connect toProsody.  Additional configuration is possible with  services.jitsi-videobridge",
                "nixName": "videobridge.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "videobridge.passwordFile",
                "desc": "File containing password to the Prosody account for videobridge.  If  null , a file with password will be generatedautomatically. Setting this option is useful if you plan to connectadditional videobridges to the XMPP server.",
                "nixName": "videobridge.passwordFile",
                "type": "null or string",
                "value": "null"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "BorgBackup",
        "desc": "Deduplicating archiver with compression and encryption",
        "tags": [
            "Backup"
        ],
        "website": "https://www.borgbackup.org",
        "logo": "https://www.borgbackup.org/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "borgbackup",
        "options": [
            {
                "name": "jobs",
                "desc": "Deduplicating backups using BorgBackup. Adding a job will cause aborg-job-NAME wrapper to be added to your system path, so that you canperform maintenance easily. See also the chapter about BorgBackup in theNixOS manual.",
                "nixName": "jobs",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "jobs.<name>.appendFailedSuffix",
                "desc": "Append a  .failed  suffix to the archive name, which isonly removed if  borg create  has a zero exit status.",
                "nixName": "jobs.<name>.appendFailedSuffix",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "jobs.<name>.archiveBaseName",
                "desc": "How to name the created archives. A timestamp, whose format isdetermined by  dateFormat , will be appended. The full name can bemodified at runtime ( $archiveName ). Placeholders like {hostname}  must not be used. Use  null  for nobase name.",
                "nixName": "jobs.<name>.archiveBaseName",
                "type": "null or string matching the pattern [^/{}]+",
                "value": "\"${config.networking.hostName}-<name>\""
            },
            {
                "name": "jobs.<name>.compression",
                "desc": "Compression method to use. Refer to  borg help compression  for all availableoptions.",
                "nixName": "jobs.<name>.compression",
                "type": "string matching the pattern none|(auto,)?(lz4|zstd|zlib|lzma)(,[[:digit:]]{1,2})?",
                "value": "\"lz4\""
            },
            {
                "name": "jobs.<name>.dateFormat",
                "desc": "Arguments passed to  date  to create a timestamp suffix for the archivename.",
                "nixName": "jobs.<name>.dateFormat",
                "type": "string",
                "value": "\"+%Y-%m-%dT%H:%M:%S\""
            },
            {
                "name": "jobs.<name>.doInit",
                "desc": "Run  borg init  ifthe specified  repo does not exist. You should set this to  false  if therepository is located on an external drive that might not always bemounted.",
                "nixName": "jobs.<name>.doInit",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "jobs.<name>.dumpCommand",
                "desc": "Backup the stdout of this program instead of filesystem paths.Mutually exclusive with  paths .",
                "nixName": "jobs.<name>.dumpCommand",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "jobs.<name>.encryption.mode",
                "desc": "Encryption mode to use. Setting a mode other than  \"none\" requires you to specify a  passCommand  or a  passphrase .",
                "nixName": "jobs.<name>.encryption.mode",
                "type": "one of \"repokey\", \"keyfile\", \"repokey-blake2\", \"keyfile-blake2\", \"authenticated\", \"authenticated-blake2\", \"none\"",
                "value": null
            },
            {
                "name": "jobs.<name>.encryption.passCommand",
                "desc": "A command which prints the passphrase to stdout. Mutually exclusivewith  passphrase .",
                "nixName": "jobs.<name>.encryption.passCommand",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "jobs.<name>.encryption.passphrase",
                "desc": "The passphrase the backups are encrypted with. Mutually exclusivewith  passCommand . Ifyou do not want the passphrase to be stored in the world-readable Nixstore, use  passCommand .",
                "nixName": "jobs.<name>.encryption.passphrase",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "jobs.<name>.environment",
                "desc": "Environment variables passed to the backup script. You can forexample specify which SSH key to use.",
                "nixName": "jobs.<name>.environment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "jobs.<name>.exclude",
                "desc": "Exclude paths matching any of the given patterns. See  borg help patterns  forpattern syntax.",
                "nixName": "jobs.<name>.exclude",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "jobs.<name>.extraArgs",
                "desc": "Additional arguments for all  borg  calls the service has. Handle with care.",
                "nixName": "jobs.<name>.extraArgs",
                "type": "string or (list of string) convertible to it",
                "value": "[ ]"
            },
            {
                "name": "jobs.<name>.extraCompactArgs",
                "desc": "Additional arguments for  borg compact . Can also be set at runtime using $extraCompactArgs .",
                "nixName": "jobs.<name>.extraCompactArgs",
                "type": "string or (list of string) convertible to it",
                "value": "[ ]"
            },
            {
                "name": "jobs.<name>.extraCreateArgs",
                "desc": "Additional arguments for  borg create . Can also be set at runtime using $extraCreateArgs .",
                "nixName": "jobs.<name>.extraCreateArgs",
                "type": "string or (list of string) convertible to it",
                "value": "[ ]"
            },
            {
                "name": "jobs.<name>.extraInitArgs",
                "desc": "Additional arguments for  borg init . Can also be set at runtime using $extraInitArgs .",
                "nixName": "jobs.<name>.extraInitArgs",
                "type": "string or (list of string) convertible to it",
                "value": "[ ]"
            },
            {
                "name": "jobs.<name>.extraPruneArgs",
                "desc": "Additional arguments for  borg prune . Can also be set at runtime using $extraPruneArgs .",
                "nixName": "jobs.<name>.extraPruneArgs",
                "type": "string or (list of string) convertible to it",
                "value": "[ ]"
            },
            {
                "name": "jobs.<name>.failOnWarnings",
                "desc": "Fail the whole backup job if any borg command returns a warning (exitcode 1), for example because a file changed during backup.",
                "nixName": "jobs.<name>.failOnWarnings",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "jobs.<name>.group",
                "desc": "The group borg is run as. User or group needs read permission for thespecified  paths .",
                "nixName": "jobs.<name>.group",
                "type": "string",
                "value": "\"root\""
            },
            {
                "name": "jobs.<name>.inhibitsSleep",
                "desc": "Prevents the system from sleeping while backing up.",
                "nixName": "jobs.<name>.inhibitsSleep",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "jobs.<name>.paths",
                "desc": "Path(s) to back up. Mutually exclusive with  dumpCommand .",
                "nixName": "jobs.<name>.paths",
                "type": "null or ((list of string) or string convertible to it)",
                "value": "null"
            },
            {
                "name": "jobs.<name>.patterns",
                "desc": "Include/exclude paths matching the given patterns. The first matchingpatterns is used, so if an include pattern (prefix  + )matches before an exclude pattern (prefix  - ), the file isbacked up. See   borg help patterns  for pattern syntax.",
                "nixName": "jobs.<name>.patterns",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "jobs.<name>.persistentTimer",
                "desc": "Set the  Persistent  option for the   systemd.timer(5)  which triggers the backup immediately if the last trigger was missed(e.g. if the system was powered down).",
                "nixName": "jobs.<name>.persistentTimer",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "jobs.<name>.postCreate",
                "desc": "Shell commands to run after  borg create . The name of the created archive isstored in  $archiveName .",
                "nixName": "jobs.<name>.postCreate",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "jobs.<name>.postHook",
                "desc": "Shell commands to run just before exit. They are executed even if aprevious command exits with a non-zero exit code. The latter isavailable as  $exitStatus .",
                "nixName": "jobs.<name>.postHook",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "jobs.<name>.postInit",
                "desc": "Shell commands to run after  borg init .",
                "nixName": "jobs.<name>.postInit",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "jobs.<name>.postPrune",
                "desc": "Shell commands to run after  borg prune .",
                "nixName": "jobs.<name>.postPrune",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "jobs.<name>.preHook",
                "desc": "Shell commands to run before the backup. This can for example be usedto mount file systems.",
                "nixName": "jobs.<name>.preHook",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "jobs.<name>.privateTmp",
                "desc": "Set the  PrivateTmp  option for the systemd-service. Setto false if you need sockets or other files from global /tmp.",
                "nixName": "jobs.<name>.privateTmp",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "jobs.<name>.prune.keep",
                "desc": "Prune a repository by deleting all archives not matching any of thespecified retention options. See  borg help prune  for the available options.",
                "nixName": "jobs.<name>.prune.keep",
                "type": "attribute set of (signed integer or string matching the pattern [[:digit:]]+[Hdwmy])",
                "value": "{ }"
            },
            {
                "name": "jobs.<name>.prune.prefix",
                "desc": "Only consider archive names starting with this prefix for pruning. Bydefault, only archives created by this job are considered. Use \"\"  or  null  to consider all archives.",
                "nixName": "jobs.<name>.prune.prefix",
                "type": "null or string",
                "value": "archiveBaseName"
            },
            {
                "name": "jobs.<name>.readWritePaths",
                "desc": "By default, borg cannot write anywhere on the system but $HOME/.config/borg  and  $HOME/.cache/borg . If,for example, your preHook script needs to dump files somewhere, putthose directories here.",
                "nixName": "jobs.<name>.readWritePaths",
                "type": "list of path",
                "value": "[ ]"
            },
            {
                "name": "jobs.<name>.removableDevice",
                "desc": "Whether the repo (which must be local) is a removable device.",
                "nixName": "jobs.<name>.removableDevice",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "jobs.<name>.repo",
                "desc": "Remote or local repository to back up to.",
                "nixName": "jobs.<name>.repo",
                "type": "string",
                "value": null
            },
            {
                "name": "jobs.<name>.startAt",
                "desc": "When or how often the backup should run. Must be in the formatdescribed in   systemd.time(7)  . Ifyou do not want the backup to start automatically, use  [ ] .It will generate a systemd service borgbackup-job-NAME. You may triggerit manually via systemctl restart borgbackup-job-NAME.",
                "nixName": "jobs.<name>.startAt",
                "type": "string or list of string",
                "value": "\"daily\""
            },
            {
                "name": "jobs.<name>.user",
                "desc": "The user  borg  isrun as. User or group need read permission for the specified  paths .",
                "nixName": "jobs.<name>.user",
                "type": "string",
                "value": "\"root\""
            },
            {
                "name": "package",
                "desc": "The borgbackup package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.borgbackup"
            },
            {
                "name": "repos",
                "desc": "Serve BorgBackup repositories to given public SSH keys, restrictingtheir access to the repository only. See also the chapter aboutBorgBackup in the NixOS manual. Also, clients do not need to specify theabsolute path when accessing the repository, i.e. user@machine:.  is enough. (Note colon and dot.)",
                "nixName": "repos",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "repos.<name>.allowSubRepos",
                "desc": "Allow clients to create repositories in subdirectories of thespecified  path .These can be accessed using  user@machine:path/to/subrepo .Note that a  quota applies to repositories independently. Therefore, if this is enabled,clients can create multiple repositories and upload an arbitrary amountof data.",
                "nixName": "repos.<name>.allowSubRepos",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "repos.<name>.authorizedKeys",
                "desc": "Public SSH keys that are given full write access to this repository.You should use a different SSH key for each repository you write to,because the specified keys are restricted to running  borg serve  and can onlyaccess this single repository.",
                "nixName": "repos.<name>.authorizedKeys",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "repos.<name>.authorizedKeysAppendOnly",
                "desc": "Public SSH keys that can only be used to append new data (archives)to the repository. Note that archives can still be marked as deleted andare subsequently removed from disk upon accessing the repo with fullwrite access, e.g. when pruning.",
                "nixName": "repos.<name>.authorizedKeysAppendOnly",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "repos.<name>.group",
                "desc": "The group  borg serve  is run as. User or group needs writepermission for the specified  path .",
                "nixName": "repos.<name>.group",
                "type": "string",
                "value": "\"borg\""
            },
            {
                "name": "repos.<name>.path",
                "desc": "Where to store the backups. Note that the directory is createdautomatically, with correct permissions.",
                "nixName": "repos.<name>.path",
                "type": "path",
                "value": "\"/var/lib/borgbackup\""
            },
            {
                "name": "repos.<name>.quota",
                "desc": "Storage quota for the repository. This quota is ensured for allsub-repositories if  allowSubRepos  is enabled but not for the overallstorage space used.",
                "nixName": "repos.<name>.quota",
                "type": "null or string matching the pattern [[:digit:].]+[KMGTP]?",
                "value": "null"
            },
            {
                "name": "repos.<name>.user",
                "desc": "The user  borg serve  is run as. User or group needs writepermission for the specified  path .",
                "nixName": "repos.<name>.user",
                "type": "string",
                "value": "\"borg\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Duplicati",
        "desc": "A free backup client that securely stores encrypted, incremental, compressed backups on cloud storage services and remote file servers",
        "tags": [
            "Backup"
        ],
        "website": "https://www.duplicati.com/",
        "logo": "https://framerusercontent.com/images/X7jKnThcZvMtDy6jL3AneV66g.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "duplicati",
        "options": [
            {
                "name": "dataDir",
                "desc": "The directory where Duplicati stores its data files.   If left as the default value this directory will automatically becreated before the Duplicati server starts, otherwise you areresponsible for ensuring the directory exists with appropriate ownershipand permissions.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"/var/lib/duplicati\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Duplicati.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "interface",
                "desc": "Listening interface for the web UI Set it to \u201cany\u201d to listen on allavailable interfaces",
                "nixName": "interface",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "package",
                "desc": "The duplicati package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.duplicati"
            },
            {
                "name": "port",
                "desc": "Port serving the web interface",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8200"
            },
            {
                "name": "user",
                "desc": "Duplicati runs as it\u2019s own user. It will only be able to backupworld-readable files. Run as root with special care.",
                "nixName": "user",
                "type": "string",
                "value": "\"duplicati\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Duplicity",
        "desc": "Encrypted bandwidth-efficient backup using the rsync algorithm",
        "tags": [
            "Backup"
        ],
        "website": "https://duplicity.gitlab.io/duplicity-web/",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "duplicity",
        "options": [
            {
                "name": "cleanup.maxAge",
                "desc": "If non-null, delete all backup sets older than the given time. Oldbackup sets will not be deleted if backup sets newer than time depend onthem.",
                "nixName": "cleanup.maxAge",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "cleanup.maxFull",
                "desc": "If non-null, delete all backups sets that are older than the count:thlast full backup (in other words, keep the last count full backups andassociated incremental sets).",
                "nixName": "cleanup.maxFull",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "cleanup.maxIncr",
                "desc": "If non-null, delete incremental sets of all backups sets that areolder than the count:th last full backup (in other words, keep only oldfull backups and not their increments).",
                "nixName": "cleanup.maxIncr",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable backups with duplicity.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exclude",
                "desc": "List of paths to exclude from backups. See the FILE SELECTION sectionin  duplicity(1)  fordetails on the syntax.",
                "nixName": "exclude",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "extraFlags",
                "desc": "Extra command-line flags passed to duplicity. See  duplicity(1) .",
                "nixName": "extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "frequency",
                "desc": "Run duplicity with the given frequency (see   systemd.time(7)   forthe format). If null, do not run automatically.",
                "nixName": "frequency",
                "type": "null or string",
                "value": "\"daily\""
            },
            {
                "name": "fullIfOlderThan",
                "desc": "If  \"never\"  (the default) always do incremental backups(the first backup will be a full backup, of course). If \"always\"  always do full backups. Otherwise, this must be astring representing a duration. Full backups will be made when thelatest full backup is older than this duration. If this is not the case,an incremental backup is performed.",
                "nixName": "fullIfOlderThan",
                "type": "string",
                "value": "\"never\""
            },
            {
                "name": "include",
                "desc": "List of paths to include into the backups. See the FILE SELECTIONsection in  duplicity(1)  for details on the syntax.",
                "nixName": "include",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "root",
                "desc": "Root directory to backup.",
                "nixName": "root",
                "type": "path",
                "value": "\"/\""
            },
            {
                "name": "secretFile",
                "desc": "Path of a file containing secrets (gpg passphrase, access key\u2026) inthe format of EnvironmentFile as described by   systemd.exec(5)  . Forexample:   PASSPHRASE=\u00ab...\u00bbAWS_ACCESS_KEY_ID=\u00ab...\u00bbAWS_SECRET_ACCESS_KEY=\u00ab...\u00bb",
                "nixName": "secretFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "targetUrl",
                "desc": "Target url to backup to. See the URL FORMAT section in  duplicity(1)  forsupported urls.",
                "nixName": "targetUrl",
                "type": "string",
                "value": null
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Restic",
        "desc": "A backup program that is fast, efficient and secure",
        "tags": [
            "Backup"
        ],
        "website": "https://restic.net",
        "logo": "https://restic.net/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "restic",
        "options": [
            {
                "name": "backups",
                "desc": "Periodic backups to create with Restic.",
                "nixName": "backups",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "backups.<name>.backupCleanupCommand",
                "desc": "A script that must run after finishing the backup process.",
                "nixName": "backups.<name>.backupCleanupCommand",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "backups.<name>.backupPrepareCommand",
                "desc": "A script that must run before starting the backup process.",
                "nixName": "backups.<name>.backupPrepareCommand",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "backups.<name>.checkOpts",
                "desc": "A list of options for \u2018restic check\u2019.",
                "nixName": "backups.<name>.checkOpts",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "backups.<name>.createWrapper",
                "desc": "Whether to generate and add a script to the system path, that has thesame environment variables set as the systemd service. This can be usedto e.g. mount snapshots or perform other opterations, without having tomanually specify most options.",
                "nixName": "backups.<name>.createWrapper",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "backups.<name>.dynamicFilesFrom",
                "desc": "A script that produces a list of files to back up. The results ofthis command are given to the \u2018\u2013files-from\u2019 option. The result is mergedwith paths specified via  paths .",
                "nixName": "backups.<name>.dynamicFilesFrom",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "backups.<name>.environmentFile",
                "desc": "file containing the credentials to access the repository, in theformat of an EnvironmentFile as described by systemd.exec(5)",
                "nixName": "backups.<name>.environmentFile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "backups.<name>.exclude",
                "desc": "Patterns to exclude when backing up. See  https://restic.readthedocs.io/en/latest/040_backup.html#excluding-files for details on syntax.",
                "nixName": "backups.<name>.exclude",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "backups.<name>.extraBackupArgs",
                "desc": "Extra arguments passed to restic backup.",
                "nixName": "backups.<name>.extraBackupArgs",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "backups.<name>.extraOptions",
                "desc": "Extra extended options to be passed to the restic \u2013option flag.",
                "nixName": "backups.<name>.extraOptions",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "backups.<name>.initialize",
                "desc": "Create the repository if it doesn\u2019t exist.",
                "nixName": "backups.<name>.initialize",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "backups.<name>.package",
                "desc": "The restic package to use.",
                "nixName": "backups.<name>.package",
                "type": "package",
                "value": "pkgs.restic"
            },
            {
                "name": "backups.<name>.passwordFile",
                "desc": "Read the repository password from a file.",
                "nixName": "backups.<name>.passwordFile",
                "type": "string",
                "value": null
            },
            {
                "name": "backups.<name>.paths",
                "desc": "Which paths to backup, in addition to ones specified via dynamicFilesFrom . If null or an empty array and dynamicFilesFrom  is also null, no backup command will berun. This can be used to create a prune-only job.",
                "nixName": "backups.<name>.paths",
                "type": "null or (list of string)",
                "value": "[ ]"
            },
            {
                "name": "backups.<name>.pruneOpts",
                "desc": "A list of options (\u2013keep-* et al.) for \u2018restic forget \u2013prune\u2019, toautomatically prune old snapshots. The \u2018forget\u2019 command is run after  the \u2018backup\u2019 command, so keep that in mind whenconstructing the \u2013keep-* options.",
                "nixName": "backups.<name>.pruneOpts",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "backups.<name>.rcloneConfig",
                "desc": "Configuration for the rclone remote being used for backup. See theremote\u2019s specific options under rclone\u2019s docs at  https://rclone.org/docs/ . Whenspecifying option names, use the \u201cconfig\u201d name specified in the docs.For example, to set  --b2-hard-delete  for a B2 remote, use hard_delete = true  in the attribute set. Warning: Secretsset in here will be world-readable in the Nix store! Consider using the rcloneConfigFile  option instead to specify secret valuesseparately. Note that options set here will override those set in theconfig file.",
                "nixName": "backups.<name>.rcloneConfig",
                "type": "null or (attribute set of (string or boolean))",
                "value": "null"
            },
            {
                "name": "backups.<name>.rcloneConfigFile",
                "desc": "Path to the file containing rclone configuration. This file mustcontain configuration for the remote specified in this backup set andalso must be readable by root. Options set in  rcloneConfig will override those set in this file.",
                "nixName": "backups.<name>.rcloneConfigFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "backups.<name>.rcloneOptions",
                "desc": "Options to pass to rclone to control its behavior. See  https://rclone.org/docs/#options for available options. When specifying option names, strip the leading -- . To set a flag such as  --drive-use-trash ,which does not take a value, set the value to the Boolean true .",
                "nixName": "backups.<name>.rcloneOptions",
                "type": "null or (attribute set of (string or boolean))",
                "value": "null"
            },
            {
                "name": "backups.<name>.repository",
                "desc": "repository to backup to.",
                "nixName": "backups.<name>.repository",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "backups.<name>.repositoryFile",
                "desc": "Path to the file containing the repository location to backup to.",
                "nixName": "backups.<name>.repositoryFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "backups.<name>.runCheck",
                "desc": "Whether to run the  check  command with the provided checkOpts  options.",
                "nixName": "backups.<name>.runCheck",
                "type": "boolean",
                "value": "builtins.length config.services.backups.\u2039name\u203a.checkOpts > 0"
            },
            {
                "name": "backups.<name>.timerConfig",
                "desc": "When to run the backup. See   systemd.timer(5)   fordetails. If null no timer is created and the backup will only run whenexplicitly started.",
                "nixName": "backups.<name>.timerConfig",
                "type": "null or (attribute set of (systemd option))",
                "value": "{\n  OnCalendar = \"daily\";\n  Persistent = true;\n}"
            },
            {
                "name": "backups.<name>.user",
                "desc": "As which user the backup should run.",
                "nixName": "backups.<name>.user",
                "type": "string",
                "value": "\"root\""
            },
            {
                "name": "server.appendOnly",
                "desc": "Enable append only mode. This mode allows creation of new backups butprevents deletion and modification of existing backups. This can beuseful when backing up systems that have a potential of beinghacked.",
                "nixName": "server.appendOnly",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "server.dataDir",
                "desc": "The directory for storing the restic repository.",
                "nixName": "server.dataDir",
                "type": "path",
                "value": "\"/var/lib/restic\""
            },
            {
                "name": "server.enable",
                "desc": "Whether to enable Restic REST Server.",
                "nixName": "server.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "server.extraFlags",
                "desc": "Extra commandline options to pass to Restic REST server.",
                "nixName": "server.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "server.listenAddress",
                "desc": "Listen on a specific IP address and port.",
                "nixName": "server.listenAddress",
                "type": "string",
                "value": "\"8000\""
            },
            {
                "name": "server.package",
                "desc": "The restic-rest-server package to use.",
                "nixName": "server.package",
                "type": "package",
                "value": "pkgs.restic-rest-server"
            },
            {
                "name": "server.privateRepos",
                "desc": "Enable private repos. Grants access only when a subdirectory with thesame name as the user is specified in the repository URL.",
                "nixName": "server.privateRepos",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "server.prometheus",
                "desc": "Enable Prometheus metrics at /metrics.",
                "nixName": "server.prometheus",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Rsnapshot ",
        "desc": "A filesystem snapshot utility for making backups of local and remote systems",
        "tags": [
            "Backup"
        ],
        "website": "https://rsnapshot.org/",
        "logo": "https://rsnapshot.org/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "rsnapshot",
        "options": [
            {
                "name": "cronIntervals",
                "desc": "Periodicity at which intervals should be run by cron. Note that theintervals also have to exist in configuration as retain options.",
                "nixName": "cronIntervals",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "enable",
                "desc": "Whether to enable rsnapshot backups.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableManualRsnapshot",
                "desc": "Whether to enable manual usage of the rsnapshot command with thismodule.",
                "nixName": "enableManualRsnapshot",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "extraConfig",
                "desc": "rsnapshot configuration option in addition to the defaults fromrsnapshot and this module.  Note that tabs are required to separate option arguments, anddirectory names require trailing slashes.  The \u201cextra\u201d in the option name might be a little misleading rightnow, as it is required to get a functional configuration.",
                "nixName": "extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "GoToSocial",
        "desc": "Fast, fun, ActivityPub server, powered by Go",
        "tags": [
            "Communication - Social Networks and Forums"
        ],
        "website": "https://gotosocial.org",
        "logo": "https://gotosocial.org/assets/logo.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "gotosocial",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable ActivityPub social network server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "environmentFile",
                "desc": "File path containing environment variables for configuring theGoToSocial service in the format of an EnvironmentFile as described bysystemd.exec(5).  This option could be used to pass sensitive configuration to theGoToSocial daemon.  Please refer to the Environment Variables section in the  documentation .",
                "nixName": "environmentFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "openFirewall",
                "desc": "Open the configured port in the firewall. Using a reverse proxyinstead is highly recommended.",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The gotosocial package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.gotosocial"
            },
            {
                "name": "settings",
                "desc": "Contents of the GoToSocial YAML config.  Please refer to the  documentation and  exampleconfig .  Please note that the  host  option cannot be changed laterso it is important to configure this correctly before you startGoToSocial.",
                "nixName": "settings",
                "type": "YAML value",
                "value": "{\n  application-name = \"gotosocial\";\n  bind-address = \"127.0.0.1\";\n  db-address = \"/var/lib/gotosocial/database.sqlite\";\n  db-type = \"sqlite\";\n  port = 8080;\n  protocol = \"https\";\n  storage-local-base-path = \"/var/lib/gotosocial/storage\";\n}"
            },
            {
                "name": "setupPostgresqlDB",
                "desc": "Whether to setup a local postgres database and populate the db-type  fields in services.gotosocial.settings .",
                "nixName": "setupPostgresqlDB",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Isso",
        "desc": "A commenting server similar to Disqus",
        "tags": [
            "Communication - Social Networks and Forums"
        ],
        "website": "https://posativ.org/isso/",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "isso",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable isso, a commenting server similar to Disqus.  Note: The application\u2019s author suppose to run isso behind a reverseproxy. The embedded solution offered by NixOS is also only suitable forsmall installations below 20 requests per second .",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings",
                "desc": "Configuration for  isso .  See  Isso ServerConfiguration  for supported values.",
                "nixName": "settings",
                "type": "attribute set of section of an INI file (attrs of INI atom (null, bool, int, float or string))",
                "value": null
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Libreddit ",
        "desc": "Private front-end for Reddit",
        "tags": [
            "Communication - Social Networks and Forums"
        ],
        "website": "https://github.com/libreddit/libreddit",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "libreddit",
        "options": [
            {
                "name": "address",
                "desc": "The address to listen on",
                "nixName": "address",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Private front-end for Reddit.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "openFirewall",
                "desc": "Open ports in the firewall for the libreddit web interface",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The libreddit package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.libreddit"
            },
            {
                "name": "port",
                "desc": "The port to listen on",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Nitter ",
        "desc": "Alternative Twitter front-end",
        "tags": [
            "Communication - Social Networks and Forums"
        ],
        "website": "https://github.com/zedeus/nitter",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "nitter",
        "options": [
            {
                "name": "cache.listMinutes",
                "desc": "How long to cache list info (not the tweets, so keep it high).",
                "nixName": "cache.listMinutes",
                "type": "signed integer",
                "value": "240"
            },
            {
                "name": "cache.redisConnections",
                "desc": "Redis connection pool size.",
                "nixName": "cache.redisConnections",
                "type": "signed integer",
                "value": "20"
            },
            {
                "name": "cache.redisHost",
                "desc": "Redis host.",
                "nixName": "cache.redisHost",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "cache.redisMaxConnections",
                "desc": "Maximum number of connections to Redis.  New connections are opened when none are available, but if the poolsize goes above this, they are closed when released, do not worry aboutthis unless you receive tons of requests per second.",
                "nixName": "cache.redisMaxConnections",
                "type": "signed integer",
                "value": "30"
            },
            {
                "name": "cache.redisPort",
                "desc": "Redis port.",
                "nixName": "cache.redisPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "6379"
            },
            {
                "name": "cache.rssMinutes",
                "desc": "How long to cache RSS queries.",
                "nixName": "cache.rssMinutes",
                "type": "signed integer",
                "value": "10"
            },
            {
                "name": "config.base64Media",
                "desc": "Use base64 encoding for proxied media URLs.",
                "nixName": "config.base64Media",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "config.enableDebug",
                "desc": "Whether to enable request logs and debug endpoints.",
                "nixName": "config.enableDebug",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "config.enableRSS",
                "desc": "Whether to enable RSS feeds.",
                "nixName": "config.enableRSS",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "config.proxy",
                "desc": "URL to a HTTP/HTTPS proxy.",
                "nixName": "config.proxy",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "config.proxyAuth",
                "desc": "Credentials for proxy.",
                "nixName": "config.proxyAuth",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "config.tokenCount",
                "desc": "Minimum amount of usable tokens.  Tokens are used to authorize API requests, but they expire after ~1hour, and have a limit of 187 requests. The limit gets reset every 15minutes, and the pool is filled up so there is always at leasttokenCount usable tokens. Only increase this if you receive major burstsall the time.",
                "nixName": "config.tokenCount",
                "type": "signed integer",
                "value": "10"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Nitter, an alternative Twitter front-end.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "guestAccounts",
                "desc": "Path to the guest accounts file.  This file contains a list of guest accounts that can be used toaccess the instance without logging in. The file is in JSONL format,where each line is a JSON object with the following fields:  {\u201coauth_token\u201d:\u201csome_token\u201d,\u201coauth_token_secret\u201d:\u201csome_secret_key\u201d}  See  https://github.com/zedeus/nitter/wiki/Guest-Account-Branch-Deployment for more information on guest accounts and how to generate them.",
                "nixName": "guestAccounts",
                "type": "path",
                "value": "\"/var/lib/nitter/guest_accounts.jsonl\""
            },
            {
                "name": "openFirewall",
                "desc": "Open ports in the firewall for Nitter web interface.",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The nitter package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.nitter"
            },
            {
                "name": "preferences.autoplayGifs",
                "desc": "Autoplay GIFs.",
                "nixName": "preferences.autoplayGifs",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "preferences.bidiSupport",
                "desc": "Support bidirectional text (makes clicking on tweets harder).",
                "nixName": "preferences.bidiSupport",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "preferences.hideBanner",
                "desc": "Hide profile banner.",
                "nixName": "preferences.hideBanner",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "preferences.hidePins",
                "desc": "Hide pinned tweets.",
                "nixName": "preferences.hidePins",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "preferences.hideReplies",
                "desc": "Hide tweet replies.",
                "nixName": "preferences.hideReplies",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "preferences.hideTweetStats",
                "desc": "Hide tweet stats (replies, retweets, likes).",
                "nixName": "preferences.hideTweetStats",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "preferences.hlsPlayback",
                "desc": "Enable HLS video streaming (requires JavaScript).",
                "nixName": "preferences.hlsPlayback",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "preferences.infiniteScroll",
                "desc": "Infinite scrolling (requires JavaScript, experimental!).",
                "nixName": "preferences.infiniteScroll",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "preferences.mp4Playback",
                "desc": "Enable MP4 video playback.",
                "nixName": "preferences.mp4Playback",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "preferences.muteVideos",
                "desc": "Mute videos by default.",
                "nixName": "preferences.muteVideos",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "preferences.proxyVideos",
                "desc": "Proxy video streaming through the server (might be slow).",
                "nixName": "preferences.proxyVideos",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "preferences.replaceReddit",
                "desc": "Replace Reddit links with links to this instance (blank todisable).",
                "nixName": "preferences.replaceReddit",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "preferences.replaceTwitter",
                "desc": "Replace Twitter links with links to this instance (blank todisable).",
                "nixName": "preferences.replaceTwitter",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "preferences.replaceYouTube",
                "desc": "Replace YouTube links with links to this instance (blank todisable).",
                "nixName": "preferences.replaceYouTube",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "preferences.squareAvatars",
                "desc": "Square profile pictures.",
                "nixName": "preferences.squareAvatars",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "preferences.stickyProfile",
                "desc": "Make profile sidebar stick to top.",
                "nixName": "preferences.stickyProfile",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "preferences.theme",
                "desc": "Instance theme.",
                "nixName": "preferences.theme",
                "type": "string",
                "value": "\"Nitter\""
            },
            {
                "name": "redisCreateLocally",
                "desc": "Configure local Redis server for Nitter.",
                "nixName": "redisCreateLocally",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "server.address",
                "desc": "The address to listen on.",
                "nixName": "server.address",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "server.hostname",
                "desc": "Hostname of the instance.",
                "nixName": "server.hostname",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "server.httpMaxConnections",
                "desc": "Maximum number of HTTP connections.",
                "nixName": "server.httpMaxConnections",
                "type": "signed integer",
                "value": "100"
            },
            {
                "name": "server.https",
                "desc": "Set secure attribute on cookies. Keep it disabled to enable cookieswhen not using HTTPS.",
                "nixName": "server.https",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "server.port",
                "desc": "The port to listen on.",
                "nixName": "server.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            },
            {
                "name": "server.staticDir",
                "desc": "Path to the static files directory.",
                "nixName": "server.staticDir",
                "type": "path",
                "value": "\"${config.services.nitter.package}/share/nitter/public\""
            },
            {
                "name": "server.title",
                "desc": "Title of the instance.",
                "nixName": "server.title",
                "type": "string",
                "value": "\"nitter\""
            },
            {
                "name": "settings",
                "desc": "Add settings here to override NixOS module generated settings.  Check the official repository for the available settings:  https://github.com/zedeus/nitter/blob/master/nitter.example.conf",
                "nixName": "settings",
                "type": "attribute set",
                "value": "{ }"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Pleroma",
        "desc": "ActivityPub microblogging server",
        "tags": [
            "Communication - Social Networks and Forums"
        ],
        "website": "https://git.pleroma.social/pleroma/pleroma",
        "logo": "https://git.pleroma.social/uploads/-/system/appearance/favicon/1/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "pleroma",
        "options": [
            {
                "name": "configs",
                "desc": "Pleroma public configuration.  This list gets appended from left to right into/etc/pleroma/config.exs. Elixir evaluates its configurationimperatively, meaning you can override a setting by appending a new strto this NixOS option list.   DO NOT STORE ANY PLEROMA SECRET HERE , use  services.pleroma.secretConfigFile instead.  This setting is going to be stored in a file part of the Nix store.The Nix store being world-readable, it\u2019s not the right place to storeany secret  Have a look to Pleroma section in the NixOS manual for moreinformation.",
                "nixName": "configs",
                "type": "list of string",
                "value": null
            },
            {
                "name": "enable",
                "desc": "Whether to enable pleroma.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group account under which pleroma runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"pleroma\""
            },
            {
                "name": "package",
                "desc": "The pleroma package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.pleroma"
            },
            {
                "name": "secretConfigFile",
                "desc": "Path to the file containing your secret pleroma configuration.   DO NOT POINT THIS OPTION TO THE NIX STORE , the store beingworld-readable, it\u2019ll compromise all your secrets.",
                "nixName": "secretConfigFile",
                "type": "string",
                "value": "\"/var/lib/pleroma/secrets.exs\""
            },
            {
                "name": "stateDir",
                "desc": "Directory where the pleroma service will save the uploads and staticfiles.",
                "nixName": "stateDir",
                "type": "string",
                "value": "\"/var/lib/pleroma\""
            },
            {
                "name": "user",
                "desc": "User account under which pleroma runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"pleroma\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Galene",
        "desc": "Videoconferencing server that is easy to deploy, written in Go",
        "tags": [
            "Communication - Video Conferencing"
        ],
        "website": "https://github.com/jech/galene",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "galene",
        "options": [
            {
                "name": "certFile",
                "desc": "Path to the server\u2019s certificate. The file is copied at runtime toGalene\u2019s data directory where it needs to reside.",
                "nixName": "certFile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "dataDir",
                "desc": "Data directory.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"${config.services.galene.stateDir}/data\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Galene Service.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which galene runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"galene\""
            },
            {
                "name": "groupsDir",
                "desc": "Web server directory.",
                "nixName": "groupsDir",
                "type": "string",
                "value": "\"${config.services.galene.stateDir}/groups\""
            },
            {
                "name": "httpAddress",
                "desc": "HTTP listen address for galene.",
                "nixName": "httpAddress",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "httpPort",
                "desc": "HTTP listen port.",
                "nixName": "httpPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8443"
            },
            {
                "name": "insecure",
                "desc": "Whether Galene should listen in http or in https. If left as thedefault value (false), Galene needs to be fed a private key and acertificate.",
                "nixName": "insecure",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "keyFile",
                "desc": "Path to the server\u2019s private key. The file is copied at runtime toGalene\u2019s data directory where it needs to reside.",
                "nixName": "keyFile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "package",
                "desc": "The galene package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.galene"
            },
            {
                "name": "recordingsDir",
                "desc": "Recordings directory.",
                "nixName": "recordingsDir",
                "type": "string",
                "value": "\"${config.services.galene.stateDir}/recordings\""
            },
            {
                "name": "stateDir",
                "desc": "The directory where Galene stores its internal state. If left as thedefault value this directory will automatically be created before theGalene server starts, otherwise the sysadmin is responsible for ensuringthe directory exists with appropriate ownership and permissions.",
                "nixName": "stateDir",
                "type": "string",
                "value": "\"/var/lib/galene\""
            },
            {
                "name": "staticDir",
                "desc": "Web server directory.",
                "nixName": "staticDir",
                "type": "string",
                "value": "\"${package.static}/static\""
            },
            {
                "name": "user",
                "desc": "User account under which galene runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"galene\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "DRBD",
        "desc": "Distributed Replicated Block Device, a distributed storage system for Linux (userspace utilities)",
        "tags": [
            "File Transfer - Distributed Filesystems"
        ],
        "website": "https://linbit.com/drbd/",
        "logo": "https://linbit.com/wp-content/uploads/2019/07/cropped-Linbit_Site_Icon-32x32.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "drbd",
        "options": [
            {
                "name": "config",
                "desc": "Contents of the  drbd.conf  configuration file.",
                "nixName": "config",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable support for DRBD, the Distributed Replicated BlockDevice.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "GlusterFS",
        "desc": "Distributed storage system",
        "tags": [
            "File Transfer - Distributed Filesystems"
        ],
        "website": "https://www.gluster.org",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "glusterfs",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable GlusterFS Daemon.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableGlustereventsd",
                "desc": "Whether to enable the GlusterFS Events Daemon",
                "nixName": "enableGlustereventsd",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "extraFlags",
                "desc": "Extra flags passed to the GlusterFS daemon",
                "nixName": "extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "killMode",
                "desc": "The systemd KillMode to use for glusterd.  glusterd spawns other daemons like gsyncd. If you want these to stopwhen glusterd is stopped (e.g. to ensure that NixOS config changes arereflected even for these sub-daemons), set this to \u2018control-group\u2019. Ifhowever you want running volume processes (glusterfsd) and thus glustermounts not be interrupted when glusterd is restarted (for example, whenyou want to restart them manually at a later time), set this to\u2018process\u2019.",
                "nixName": "killMode",
                "type": "one of \"control-group\", \"process\", \"mixed\", \"none\"",
                "value": "\"control-group\""
            },
            {
                "name": "logLevel",
                "desc": "Log level used by the GlusterFS daemon",
                "nixName": "logLevel",
                "type": "one of \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\", \"TRACE\", \"NONE\"",
                "value": "\"INFO\""
            },
            {
                "name": "stopKillTimeout",
                "desc": "The systemd TimeoutStopSec to use.  After this time after having been asked to shut down, glusterd (anddepending on the killMode setting also its child processes) are killedby systemd.  The default is set low because GlusterFS (as of 3.10) is known to nottell its children (like gsyncd) to terminate at all.",
                "nixName": "stopKillTimeout",
                "type": "string",
                "value": "\"5s\""
            },
            {
                "name": "tlsSettings",
                "desc": "Make the server communicate via TLS. This means it will only connectto other gluster servers having certificates signed by the same CA.  Enabling this will create a file  /var/lib/glusterd/secure-access . Disabling willdelete this file again.  See also:  https://gluster.readthedocs.io/en/latest/Administrator%20Guide/SSL/",
                "nixName": "tlsSettings",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "tlsSettings.caCert",
                "desc": "Path certificate authority used to sign the cluster certificates.",
                "nixName": "tlsSettings.caCert",
                "type": "path",
                "value": null
            },
            {
                "name": "tlsSettings.tlsKeyPath",
                "desc": "Path to the private key used for TLS.",
                "nixName": "tlsSettings.tlsKeyPath",
                "type": "string",
                "value": null
            },
            {
                "name": "tlsSettings.tlsPem",
                "desc": "Path to the certificate used for TLS.",
                "nixName": "tlsSettings.tlsPem",
                "type": "path",
                "value": null
            },
            {
                "name": "useRpcbind",
                "desc": "Enable use of rpcbind. This is required for Gluster\u2019s NFSfunctionality.  You may want to turn it off to reduce the attack surface for DDoSreflection attacks.  See  https://davelozier.com/glusterfs-and-rpcbind-portmap-ddos-reflection-attacks/ and  https://bugzilla.redhat.com/show_bug.cgi?id=1426842 for details.",
                "nixName": "useRpcbind",
                "type": "boolean",
                "value": "true"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Kubo",
        "desc": "An IPFS implementation in Go",
        "tags": [
            "File Transfer - Distributed Filesystems"
        ],
        "website": "https://ipfs.io/",
        "logo": "https://ipfs.io/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "kubo",
        "options": [
            {
                "name": "autoMigrate",
                "desc": "Whether Kubo should try to run the fs-repo-migration at startup.",
                "nixName": "autoMigrate",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "autoMount",
                "desc": "Whether Kubo should try to mount /ipfs and /ipns at startup.",
                "nixName": "autoMount",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "dataDir",
                "desc": "The data dir for Kubo",
                "nixName": "dataDir",
                "type": "string",
                "value": "if versionAtLeast config.system.stateVersion \"17.09\"\nthen \"/var/lib/ipfs\"\nelse \"/var/lib/ipfs/.ipfs\"\n"
            },
            {
                "name": "defaultMode",
                "desc": "systemd service that is enabled by default",
                "nixName": "defaultMode",
                "type": "one of \"online\", \"offline\", \"norouting\"",
                "value": "\"online\""
            },
            {
                "name": "emptyRepo",
                "desc": "If set to false, the repo will be initialized with help files",
                "nixName": "emptyRepo",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "enable",
                "desc": "Whether to enable the Interplanetary File System (WARNING: may causesevere network degradation). NOTE: after enabling this option andrebuilding your system, you need to log out and back in for the IPFS_PATH  environment variable to be present in your shell.Until you do that, the CLI tools won\u2019t be able to talk to the daemon bydefault .",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableGC",
                "desc": "Whether to enable automatic garbage collection",
                "nixName": "enableGC",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraFlags",
                "desc": "Extra flags passed to the Kubo daemon",
                "nixName": "extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "Group under which the Kubo daemon runs",
                "nixName": "group",
                "type": "string",
                "value": "\"ipfs\""
            },
            {
                "name": "localDiscovery",
                "desc": "Whether to enable local discovery for the Kubo daemon. This willallow Kubo to scan ports on your local network. Some hosting serviceswill ban you if you do this.",
                "nixName": "localDiscovery",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The kubo package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.kubo"
            },
            {
                "name": "serviceFdlimit",
                "desc": "The fdlimit for the Kubo systemd unit or  null  to havethe daemon attempt to manage it",
                "nixName": "serviceFdlimit",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "settings",
                "desc": "Attrset of daemon configuration. See [ https://github.com/ipfs/kubo/blob/master/docs/config.md](https://github.com/ipfs/kubo/blob/master/docs/config.md) for reference. You can\u2019t set  Identity  or Pinning .",
                "nixName": "settings",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "settings.Addresses.API",
                "desc": "Multiaddr or array of multiaddrs describing the address to serve thelocal HTTP API on. In addition to the multiaddrs listed here, the daemonwill also listen on a Unix domain socket. To allow the ipfs CLI tools tocommunicate with the daemon over that socket, add your user to thecorrect group, e.g. users.users.alice.extraGroups = [ config.services.kubo.group ];",
                "nixName": "settings.Addresses.API",
                "type": "string or list of string",
                "value": "[ ]"
            },
            {
                "name": "settings.Addresses.Gateway",
                "desc": "Where the IPFS Gateway can be reached",
                "nixName": "settings.Addresses.Gateway",
                "type": "string or list of string",
                "value": "\"/ip4/127.0.0.1/tcp/8080\""
            },
            {
                "name": "settings.Addresses.Swarm",
                "desc": "Where Kubo listens for incoming p2p connections",
                "nixName": "settings.Addresses.Swarm",
                "type": "list of string",
                "value": "[\n  \"/ip4/0.0.0.0/tcp/4001\"\n  \"/ip6/::/tcp/4001\"\n  \"/ip4/0.0.0.0/udp/4001/quic-v1\"\n  \"/ip4/0.0.0.0/udp/4001/quic-v1/webtransport\"\n  \"/ip6/::/udp/4001/quic-v1\"\n  \"/ip6/::/udp/4001/quic-v1/webtransport\"\n]"
            },
            {
                "name": "settings.Mounts.IPFS",
                "desc": "Where to mount the IPFS namespace to",
                "nixName": "settings.Mounts.IPFS",
                "type": "string",
                "value": "\"/ipfs\""
            },
            {
                "name": "settings.Mounts.IPNS",
                "desc": "Where to mount the IPNS namespace to",
                "nixName": "settings.Mounts.IPNS",
                "type": "string",
                "value": "\"/ipns\""
            },
            {
                "name": "startWhenNeeded",
                "desc": "Whether to use socket activation to start Kubo when needed.",
                "nixName": "startWhenNeeded",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "user",
                "desc": "User under which the Kubo daemon runs",
                "nixName": "user",
                "type": "string",
                "value": "\"ipfs\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "MooseFS",
        "desc": "Open Source, Petabyte, Fault-Tolerant, Highly Performing, Scalable Network Distributed File System",
        "tags": [
            "File Transfer - Distributed Filesystems"
        ],
        "website": "https://moosefs.com",
        "logo": "https://moosefs.com/wp-content/themes/Moose/img/android-icon-192x192.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "moosefs",
        "options": [
            {
                "name": "chunkserver.enable",
                "desc": "Whether to enable Moosefs chunkserver daemon.",
                "nixName": "chunkserver.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "chunkserver.hdds",
                "desc": "Mount points to be used by chunkserver for storage (seemfshdd.cfg).",
                "nixName": "chunkserver.hdds",
                "type": "list of string",
                "value": "null"
            },
            {
                "name": "chunkserver.openFirewall",
                "desc": "Whether to automatically open the necessary ports in thefirewall.",
                "nixName": "chunkserver.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "chunkserver.settings",
                "desc": "Contents of chunkserver config file (mfschunkserver.cfg).",
                "nixName": "chunkserver.settings",
                "type": "attribute set of (Flat key-value file)",
                "value": null
            },
            {
                "name": "chunkserver.settings.DATA_PATH",
                "desc": "Directory for lock file.",
                "nixName": "chunkserver.settings.DATA_PATH",
                "type": "string",
                "value": "\"/var/lib/mfs\""
            },
            {
                "name": "client.enable",
                "desc": "Whether to enable Moosefs client.",
                "nixName": "client.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "master.enable",
                "desc": "Enable Moosefs master daemon.  You need to run  mfsmaster-init  on a freshly installedmaster server to initialize the  DATA_PATH  directory.",
                "nixName": "master.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "master.exports",
                "desc": "Paths to export (see mfsexports.cfg).",
                "nixName": "master.exports",
                "type": "list of string",
                "value": "null"
            },
            {
                "name": "master.openFirewall",
                "desc": "Whether to automatically open the necessary ports in thefirewall.",
                "nixName": "master.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "master.settings",
                "desc": "Contents of config file (mfsmaster.cfg).",
                "nixName": "master.settings",
                "type": "attribute set of (Flat key-value file)",
                "value": null
            },
            {
                "name": "master.settings.DATA_PATH",
                "desc": "Data storage directory.",
                "nixName": "master.settings.DATA_PATH",
                "type": "string",
                "value": "\"/var/lib/mfs\""
            },
            {
                "name": "masterHost",
                "desc": "IP or DNS name of master host.",
                "nixName": "masterHost",
                "type": "string",
                "value": "null"
            },
            {
                "name": "metalogger.enable",
                "desc": "Whether to enable Moosefs metalogger daemon.",
                "nixName": "metalogger.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "metalogger.settings",
                "desc": "Contents of metalogger config file (mfsmetalogger.cfg).",
                "nixName": "metalogger.settings",
                "type": "attribute set of (Flat key-value file)",
                "value": null
            },
            {
                "name": "metalogger.settings.DATA_PATH",
                "desc": "Data storage directory",
                "nixName": "metalogger.settings.DATA_PATH",
                "type": "string",
                "value": "\"/var/lib/mfs\""
            },
            {
                "name": "runAsUser",
                "desc": "Run daemons as user moosefs instead of root.",
                "nixName": "runAsUser",
                "type": "boolean",
                "value": "true"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "SFTPGo ",
        "desc": "Fully featured and highly configurable SFTP server",
        "tags": [
            "File Transfer - Object Storage & File Servers"
        ],
        "website": "https://github.com/drakkan/sftpgo",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "sftpgo",
        "options": [
            {
                "name": "dataDir",
                "desc": "The directory where SFTPGo stores its data files.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"/var/lib/sftpgo\""
            },
            {
                "name": "enable",
                "desc": "sftpgo",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraArgs",
                "desc": "Additional command line arguments to pass to the sftpgo daemon.",
                "nixName": "extraArgs",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "Group name under which SFTPGo runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"sftpgo\""
            },
            {
                "name": "loadDataFile",
                "desc": "Path to a json file containing users and folders to load (or update)on startup. Check the  documentation for the  --loaddata-from  command line argument for moreinfo.",
                "nixName": "loadDataFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "package",
                "desc": "The sftpgo package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.sftpgo"
            },
            {
                "name": "settings",
                "desc": "The primary sftpgo configuration. See the  configurationreference  for possible values.",
                "nixName": "settings",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "settings.ftpd.bindings",
                "desc": "Configure listen addresses and ports for ftpd.",
                "nixName": "settings.ftpd.bindings",
                "type": "list of (JSON value)",
                "value": "[ ]"
            },
            {
                "name": "settings.ftpd.bindings.*.address",
                "desc": "Network listen address. Leave blank to listen on all availablenetwork interfaces. On *NIX you can specify an absolute path to listenon a Unix-domain socket.",
                "nixName": "settings.ftpd.bindings.*.address",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "settings.ftpd.bindings.*.port",
                "desc": "The port for serving FTP requests.  Setting the port to  0  disables listening on thisinterface binding.",
                "nixName": "settings.ftpd.bindings.*.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "0"
            },
            {
                "name": "settings.httpd.bindings",
                "desc": "Configure listen addresses and ports for httpd.",
                "nixName": "settings.httpd.bindings",
                "type": "list of (JSON value)",
                "value": "[ ]"
            },
            {
                "name": "settings.httpd.bindings.*.address",
                "desc": "Network listen address. Leave blank to listen on all availablenetwork interfaces. On *NIX you can specify an absolute path to listenon a Unix-domain socket.",
                "nixName": "settings.httpd.bindings.*.address",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "settings.httpd.bindings.*.enable_web_admin",
                "desc": "Enable the built-in web admin for this interface binding.",
                "nixName": "settings.httpd.bindings.*.enable_web_admin",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings.httpd.bindings.*.enable_web_client",
                "desc": "Enable the built-in web client for this interface binding.",
                "nixName": "settings.httpd.bindings.*.enable_web_client",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings.httpd.bindings.*.port",
                "desc": "The port for serving HTTP(S) requests.  Setting the port to  0  disables listening on thisinterface binding.",
                "nixName": "settings.httpd.bindings.*.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            },
            {
                "name": "settings.sftpd.bindings",
                "desc": "Configure listen addresses and ports for sftpd.",
                "nixName": "settings.sftpd.bindings",
                "type": "list of (JSON value)",
                "value": "[ ]"
            },
            {
                "name": "settings.sftpd.bindings.*.address",
                "desc": "Network listen address. Leave blank to listen on all availablenetwork interfaces. On *NIX you can specify an absolute path to listenon a Unix-domain socket.",
                "nixName": "settings.sftpd.bindings.*.address",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "settings.sftpd.bindings.*.port",
                "desc": "The port for serving SFTP requests.  Setting the port to  0  disables listening on thisinterface binding.",
                "nixName": "settings.sftpd.bindings.*.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "0"
            },
            {
                "name": "settings.smtp",
                "desc": "SMTP configuration section.",
                "nixName": "settings.smtp",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "settings.smtp.auth_type",
                "desc": "0 : Plain   1 : Login   2 : CRAM-MD5",
                "nixName": "settings.smtp.auth_type",
                "type": "one of 0, 1, 2",
                "value": "0"
            },
            {
                "name": "settings.smtp.encryption",
                "desc": "Encryption scheme:    0 : No encryption   1 : TLS   2 : STARTTLS",
                "nixName": "settings.smtp.encryption",
                "type": "one of 0, 1, 2",
                "value": "1"
            },
            {
                "name": "settings.smtp.from",
                "desc": "From address.",
                "nixName": "settings.smtp.from",
                "type": "string",
                "value": "\"SFTPGo <sftpgo@example.com>\""
            },
            {
                "name": "settings.smtp.host",
                "desc": "Location of SMTP email server. Leave empty to disable email sendingcapabilities.",
                "nixName": "settings.smtp.host",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "settings.smtp.port",
                "desc": "Port of the SMTP Server.",
                "nixName": "settings.smtp.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "465"
            },
            {
                "name": "settings.smtp.user",
                "desc": "SMTP username.",
                "nixName": "settings.smtp.user",
                "type": "string",
                "value": "\"sftpgo\""
            },
            {
                "name": "settings.webdavd.bindings",
                "desc": "Configure listen addresses and ports for webdavd.",
                "nixName": "settings.webdavd.bindings",
                "type": "list of (JSON value)",
                "value": "[ ]"
            },
            {
                "name": "settings.webdavd.bindings.*.address",
                "desc": "Network listen address. Leave blank to listen on all availablenetwork interfaces. On *NIX you can specify an absolute path to listenon a Unix-domain socket.",
                "nixName": "settings.webdavd.bindings.*.address",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "settings.webdavd.bindings.*.port",
                "desc": "The port for serving WebDAV requests.  Setting the port to  0  disables listening on thisinterface binding.",
                "nixName": "settings.webdavd.bindings.*.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "0"
            },
            {
                "name": "user",
                "desc": "User account name under which SFTPGo runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"sftpgo\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Transmission ",
        "desc": "A collection of games made with raylib",
        "tags": [
            "File Transfer - Peer-to-peer Filesharing"
        ],
        "website": "https://www.raylib.com/games.html",
        "logo": "https://www.raylib.com/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "transmission",
        "options": [
            {
                "name": "credentialsFile",
                "desc": "Path to a JSON file to be merged with the settings. Useful to merge afile which is better kept out of the Nix store to set secret configparameters like  rpc-password .",
                "nixName": "credentialsFile",
                "type": "path",
                "value": "\"/dev/null\""
            },
            {
                "name": "downloadDirPermissions",
                "desc": "If not  null , is used as the permissions set by system.activationScripts.transmission-daemon  on thedirectories  services.transmission.settings.download-dir , services.transmission.settings.incomplete-dir .and  services.transmission.settings.watch-dir .Note that you may also want to change  services.transmission.settings.umask .",
                "nixName": "downloadDirPermissions",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable the headless Transmission BitTorrent daemon.  Transmission daemon can be controlled via the RPC interface usingtransmission-remote, the WebUI ( http://127.0.0.1:9091/  by default), orother clients like stig or tremc.  Torrents are downloaded to  services.transmission.home /Downloadsby default and are accessible to users in the \u201ctransmission\u201d group.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraFlags",
                "desc": "Extra flags passed to the transmission command in the servicedefinition.",
                "nixName": "extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "Group account under which Transmission runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"transmission\""
            },
            {
                "name": "home",
                "desc": "The directory where Transmission will create .config/transmission-daemon . as well as Downloads/  unless  services.transmission.settings.download-dir is changed, and  .incomplete/  unless  services.transmission.settings.incomplete-dir is changed.",
                "nixName": "home",
                "type": "path",
                "value": "\"/var/lib/transmission\""
            },
            {
                "name": "openFirewall",
                "desc": "Alias of  services.transmission.openPeerPorts .",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": null
            },
            {
                "name": "openPeerPorts",
                "desc": "Whether to enable opening of the peer port(s) in the firewall.",
                "nixName": "openPeerPorts",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "openRPCPort",
                "desc": "Whether to enable opening of the RPC port in the firewall.",
                "nixName": "openRPCPort",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The transmission package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.transmission_3"
            },
            {
                "name": "performanceNetParameters",
                "desc": "Whether to enable tweaking of kernel parameters to open many moreconnections at the same time.  Note that you may also want to increase peer-limit-global . And be aware that these settings arequite aggressive and might not suite your regular desktop use. Forinstance, SSH sessions may time out more easily.",
                "nixName": "performanceNetParameters",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings",
                "desc": "Settings whose options overwrite fields in .config/transmission-daemon/settings.json  (each time theservice starts).  See  Transmission\u2019sWiki  for documentation of settings not explicitly covered by thismodule.",
                "nixName": "settings",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "settings.download-dir",
                "desc": "Directory where to download torrents.",
                "nixName": "settings.download-dir",
                "type": "path",
                "value": "\"${config.services.transmission.home}/Downloads\""
            },
            {
                "name": "settings.incomplete-dir",
                "desc": "When enabled with services.transmission.home  services.transmission.settings.incomplete-dir-enabled ,new torrents will download the files to this directory. When complete,the files will be moved to download-dir  services.transmission.settings.download-dir .",
                "nixName": "settings.incomplete-dir",
                "type": "path",
                "value": "\"${config.services.transmission.home}/.incomplete\""
            },
            {
                "name": "settings.incomplete-dir-enabled",
                "desc": "",
                "nixName": "settings.incomplete-dir-enabled",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings.message-level",
                "desc": "Set verbosity of transmission messages.",
                "nixName": "settings.message-level",
                "type": "integer between 0 and 6 (both inclusive)",
                "value": "2"
            },
            {
                "name": "settings.peer-port",
                "desc": "The peer port to listen for incoming connections.",
                "nixName": "settings.peer-port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "51413"
            },
            {
                "name": "settings.peer-port-random-high",
                "desc": "The maximum peer port to listen to for incoming connections when  services.transmission.settings.peer-port-random-on-start is enabled.",
                "nixName": "settings.peer-port-random-high",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "65535"
            },
            {
                "name": "settings.peer-port-random-low",
                "desc": "The minimal peer port to listen to for incoming connections when  services.transmission.settings.peer-port-random-on-start is enabled.",
                "nixName": "settings.peer-port-random-low",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "65535"
            },
            {
                "name": "settings.peer-port-random-on-start",
                "desc": "Randomize the peer port.",
                "nixName": "settings.peer-port-random-on-start",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.rpc-bind-address",
                "desc": "Where to listen for RPC connections. Use  0.0.0.0  tolisten on all interfaces.",
                "nixName": "settings.rpc-bind-address",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "settings.rpc-port",
                "desc": "The RPC port to listen to.",
                "nixName": "settings.rpc-port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9091"
            },
            {
                "name": "settings.script-torrent-done-enabled",
                "desc": "Whether to run  services.transmission.settings.script-torrent-done-filename at torrent completion.",
                "nixName": "settings.script-torrent-done-enabled",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.script-torrent-done-filename",
                "desc": "Executable to be run at torrent completion.",
                "nixName": "settings.script-torrent-done-filename",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "settings.trash-original-torrent-files",
                "desc": "Whether to delete torrents added from the  services.transmission.settings.watch-dir .",
                "nixName": "settings.trash-original-torrent-files",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.umask",
                "desc": "Sets transmission\u2019s file mode creation mask. See the umask(2) manpagefor more information. Users who want their saved torrents to beworld-writable may want to set this value to 0. Bear in mind that thejson markup language only accepts numbers in base 10, so the standardumask(2) octal notation \u201c022\u201d is written in settings.json as 18.",
                "nixName": "settings.umask",
                "type": "signed integer",
                "value": "2"
            },
            {
                "name": "settings.utp-enabled",
                "desc": "Whether to enable  MicroTransport Protocol (\u00b5TP) .",
                "nixName": "settings.utp-enabled",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings.watch-dir",
                "desc": "Watch a directory for torrent files and add them to transmission.",
                "nixName": "settings.watch-dir",
                "type": "path",
                "value": "\"${config.services.transmission.home}/watchdir\""
            },
            {
                "name": "settings.watch-dir-enabled",
                "desc": "Whether to enable the  services.transmission.settings.watch-dir .",
                "nixName": "settings.watch-dir-enabled",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "user",
                "desc": "User account under which Transmission runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"transmission\""
            },
            {
                "name": "webHome",
                "desc": "If not  null , sets the value of the TRANSMISSION_WEB_HOME  environment variable used by theservice. Useful for overriding the web interface files, withoutoverriding the transmission package and thus requiring rebuilding itlocally. Use this if you want to use an alternative web interface, suchas  pkgs.flood-for-transmission .",
                "nixName": "webHome",
                "type": "null or path",
                "value": "null"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Audiobookshelf",
        "desc": "Self-hosted audiobook and podcast server",
        "tags": [
            "Media Streaming - Audio Streaming\r"
        ],
        "website": "https://www.audiobookshelf.org/",
        "logo": "https://www.audiobookshelf.org/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "audiobookshelf",
        "options": [
            {
                "name": "dataDir",
                "desc": "Path to Audiobookshelf config and metadata inside of /var/lib.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"audiobookshelf\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Audiobookshelf, self-hosted audiobook and podcastserver.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which Audiobookshelf runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"audiobookshelf\""
            },
            {
                "name": "host",
                "desc": "The host Audiobookshelf binds to.",
                "nixName": "host",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "openFirewall",
                "desc": "Open ports in the firewall for the Audiobookshelf web interface.",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The audiobookshelf package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.audiobookshelf"
            },
            {
                "name": "port",
                "desc": "The TCP port Audiobookshelf will listen on.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8000"
            },
            {
                "name": "user",
                "desc": "User account under which Audiobookshelf runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"audiobookshelf\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "gonic",
        "desc": "Music streaming server / subsonic server API implementation",
        "tags": [
            "Media Streaming - Audio Streaming\r"
        ],
        "website": "https://github.com/sentriz/gonic",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "gonic",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable Gonic music server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings",
                "desc": "Configuration for Gonic, see  https://github.com/sentriz/gonic#configuration-options for supported values.",
                "nixName": "settings",
                "type": "attribute set of (atom (null, bool, int, float or string) or a list of them for duplicate keys)",
                "value": "{\n  cache-path = \"/var/cache/gonic\";\n  listen-addr = \"127.0.0.1:4747\";\n  tls-cert = null;\n  tls-key = null;\n}"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Mopidy",
        "desc": "An extensible music server that plays music from local disk, Spotify, SoundCloud, and more",
        "tags": [
            "Media Streaming - Audio Streaming\r"
        ],
        "website": "https://www.mopidy.com/",
        "logo": "https://www.mopidy.com/media/favicon/favicon-32x32.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "mopidy",
        "options": [
            {
                "name": "configuration",
                "desc": "The configuration that Mopidy should use.",
                "nixName": "configuration",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "dataDir",
                "desc": "The directory where Mopidy stores its state.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"/var/lib/mopidy\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Mopidy, a music player daemon.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extensionPackages",
                "desc": "Mopidy extensions that should be loaded by the service.",
                "nixName": "extensionPackages",
                "type": "list of package",
                "value": "[ ]"
            },
            {
                "name": "extraConfigFiles",
                "desc": "Extra config file read by Mopidy when the service starts. Later filesin the list overrides earlier configuration.",
                "nixName": "extraConfigFiles",
                "type": "list of string",
                "value": "[ ]"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Navidrome Music Server",
        "desc": "Navidrome Music Server and Streamer compatible with Subsonic/Airsonic",
        "tags": [
            "Media Streaming - Audio Streaming\r"
        ],
        "website": "https://www.navidrome.org/",
        "logo": "https://www.navidrome.org/favicons/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "navidrome",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable Navidrome music server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which Navidrome runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"navidrome\""
            },
            {
                "name": "openFirewall",
                "desc": "Whether to open the TCP port in the firewall",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The navidrome package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.navidrome"
            },
            {
                "name": "settings",
                "desc": "Configuration for Navidrome, see  https://www.navidrome.org/docs/usage/configuration-options/ for supported values.",
                "nixName": "settings",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "settings.Address",
                "desc": "Address to run Navidrome on.",
                "nixName": "settings.Address",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "settings.Port",
                "desc": "Port to run Navidrome on.",
                "nixName": "settings.Port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "4533"
            },
            {
                "name": "user",
                "desc": "User under which Navidrome runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"navidrome\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Jellyfin",
        "desc": "The Free Software Media System",
        "tags": [
            "Media Streaming - Multimedia Streaming"
        ],
        "website": "https://jellyfin.org/",
        "logo": "https://jellyfin.org/images/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "jellyfin",
        "options": [
            {
                "name": "cacheDir",
                "desc": "Directory containing the jellyfin server cache, passed with --cachedir  see  #cache-directory",
                "nixName": "cacheDir",
                "type": "path",
                "value": "\"/var/cache/jellyfin\""
            },
            {
                "name": "configDir",
                "desc": "Directory containing the server configuration files, passed with --configdir  see  configuration-directory",
                "nixName": "configDir",
                "type": "path",
                "value": "\"\\${cfg.dataDir}/config\""
            },
            {
                "name": "dataDir",
                "desc": "Base data directory, passed with  --datadir  see  #data-directory",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/jellyfin\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Jellyfin Media Server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which jellyfin runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"jellyfin\""
            },
            {
                "name": "logDir",
                "desc": "Directory where the Jellyfin logs will be stored, passed with --logdir  see  #log-directory",
                "nixName": "logDir",
                "type": "path",
                "value": "\"\\${cfg.dataDir}/log\""
            },
            {
                "name": "openFirewall",
                "desc": "Open the default ports in the firewall for the media server. TheHTTP/HTTPS ports can be changed in the Web UI, so this option shouldonly be used if they are unchanged, see  PortBindings .",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The jellyfin package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.jellyfin"
            },
            {
                "name": "user",
                "desc": "User account under which Jellyfin runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"jellyfin\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Invidious",
        "desc": "An open source alternative front-end to YouTube",
        "tags": [
            "Media Streaming - Video Streaming"
        ],
        "website": "https://invidious.io/",
        "logo": "https://invidious.io/favicon-32x32.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "invidious",
        "options": [
            {
                "name": "address",
                "desc": "The IP address Invidious should bind to.",
                "nixName": "address",
                "type": "string",
                "value": "if config.services.invidious.nginx.enable then \"127.0.0.1\" else \"0.0.0.0\""
            },
            {
                "name": "database.createLocally",
                "desc": "Whether to create a local database with PostgreSQL.",
                "nixName": "database.createLocally",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "database.host",
                "desc": "The database host Invidious should use.  If  null , the local unix socket is used. Otherwise TCP isused.",
                "nixName": "database.host",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "database.passwordFile",
                "desc": "Path to file containing the database password.",
                "nixName": "database.passwordFile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "database.port",
                "desc": "The port of the database Invidious should use.  Defaults to the the default postgresql port.",
                "nixName": "database.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "config.services.postgresql.settings.port"
            },
            {
                "name": "domain",
                "desc": "The FQDN Invidious is reachable on.  This is used to configure nginx and for building absolute URLs.",
                "nixName": "domain",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Invidious.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraSettingsFile",
                "desc": "A file including Invidious settings.  It gets merged with the settings specified in  services.invidious.settings  and can be used tostore secrets like  hmac_key  outside of the nix store.",
                "nixName": "extraSettingsFile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "hmacKeyFile",
                "desc": "A path to a file containing the  hmac_key . If null , a key will be generated automatically on firststart.  If non- null , this option overrides any hmac_key  specified in  services.invidious.settings  or via  services.invidious.extraSettingsFile .",
                "nixName": "hmacKeyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "http3-ytproxy.enable",
                "desc": "Whether to enable http3-ytproxy for faster loading of images andvideo playback.  If  services.invidious.nginx.enable  is used, nginx willbe configured automatically. If not, you need to configure a reverseproxy yourself according to  https://docs.invidious.io/improve-public-instance/#3-speed-up-video-playback-with-http3-ytproxy .",
                "nixName": "http3-ytproxy.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "http3-ytproxy.package",
                "desc": "The http3-ytproxy package to use.",
                "nixName": "http3-ytproxy.package",
                "type": "package",
                "value": "pkgs.http3-ytproxy"
            },
            {
                "name": "nginx.enable",
                "desc": "Whether to configure nginx as a reverse proxy for Invidious.  It serves it under the domain specified in  services.invidious.settings.domain  with enabled TLSand ACME. Further configuration can be done through  services.nginx.virtualHosts.${config.services.invidious.settings.domain}.* ,which can also be used to disable AMCE and TLS.",
                "nixName": "nginx.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The invidious package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.invidious"
            },
            {
                "name": "port",
                "desc": "The port Invidious should listen on.  To allow access from outside, you can use either  services.invidious.nginx or add  config.services.invidious.port  to  networking.firewall.allowedTCPPorts .",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "3000"
            },
            {
                "name": "serviceScale",
                "desc": "How many invidious instances to run.  See  https://docs.invidious.io/improve-public-instance/#2-multiple-invidious-processes for more details on how this is intended to work. All instances beyondthe first one have the options  channel_threads  and feed_threads  set to 0 to avoid conflicts with multipleinstances refreshing subscriptions. Instances will be configured to bindto consecutive ports starting with  services.invidious.port  for the first instance.",
                "nixName": "serviceScale",
                "type": "signed integer",
                "value": "1"
            },
            {
                "name": "settings",
                "desc": "The settings Invidious should use.  See  config.example.yml for a list of all possible options.",
                "nixName": "settings",
                "type": "JSON value",
                "value": "{ }"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Owncast",
        "desc": "self-hosted video live streaming solution",
        "tags": [
            "Media Streaming - Video Streaming"
        ],
        "website": "https://owncast.online",
        "logo": "https://owncast.online/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "owncast",
        "options": [
            {
                "name": "dataDir",
                "desc": "The directory where owncast stores its data files. If left as thedefault value this directory will automatically be created before theowncast server starts, otherwise the sysadmin is responsible forensuring the directory exists with appropriate ownership andpermissions.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"/var/lib/owncast\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable owncast, a video live streaming solution.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which owncast runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"owncast\""
            },
            {
                "name": "listen",
                "desc": "The IP address to bind the owncast web server to.",
                "nixName": "listen",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "openFirewall",
                "desc": "Open the appropriate ports in the firewall for owncast.",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "port",
                "desc": "TCP port where owncast web-gui listens.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            },
            {
                "name": "rtmp-port",
                "desc": "TCP port where owncast rtmp service listens.",
                "nixName": "rtmp-port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "1935"
            },
            {
                "name": "user",
                "desc": "User account under which owncast runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"owncast\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Alerta",
        "desc": "Alerta Monitoring System command-line interface",
        "tags": [
            "Monitoring"
        ],
        "website": "https://alerta.io",
        "logo": "https://alerta.io/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "alerta",
        "options": [
            {
                "name": "authenticationRequired",
                "desc": "Whether users must authenticate when using the web UI or command-linetool",
                "nixName": "authenticationRequired",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "bind",
                "desc": "Address to bind to. The default is to bind to all addresses",
                "nixName": "bind",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "corsOrigins",
                "desc": "List of URLs that can access the API for Cross-Origin ResourceSharing (CORS)",
                "nixName": "corsOrigins",
                "type": "list of string",
                "value": "[\n  \"http://localhost\"\n  \"http://localhost:5000\"\n]"
            },
            {
                "name": "databaseName",
                "desc": "Name of the database instance to connect to",
                "nixName": "databaseName",
                "type": "string",
                "value": "\"monitoring\""
            },
            {
                "name": "databaseUrl",
                "desc": "URL of the MongoDB or PostgreSQL database to connect to",
                "nixName": "databaseUrl",
                "type": "string",
                "value": "\"mongodb://localhost\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable alerta.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraConfig",
                "desc": "These lines go into alertad.conf verbatim.",
                "nixName": "extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "logDir",
                "desc": "Location where the logfiles are stored",
                "nixName": "logDir",
                "type": "path",
                "value": "\"/var/log/alerta\""
            },
            {
                "name": "port",
                "desc": "Port of Alerta",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "5000"
            },
            {
                "name": "signupEnabled",
                "desc": "Whether to prevent sign-up of new users via the web UI",
                "nixName": "signupEnabled",
                "type": "boolean",
                "value": "true"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "cadvisor",
        "desc": "Analyzes resource usage and performance characteristics of running docker containers",
        "tags": [
            "Monitoring"
        ],
        "website": "https://github.com/google/cadvisor",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "cadvisor",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable Cadvisor service.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraOptions",
                "desc": "Additional cadvisor options.  See  https://github.com/google/cadvisor/blob/master/docs/runtime_options.md for available options.",
                "nixName": "extraOptions",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "listenAddress",
                "desc": "Cadvisor listening host",
                "nixName": "listenAddress",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "port",
                "desc": "Cadvisor listening port",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            },
            {
                "name": "storageDriver",
                "desc": "Cadvisor storage driver.",
                "nixName": "storageDriver",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "storageDriverDb",
                "desc": "Cadvisord storage driver database name.",
                "nixName": "storageDriverDb",
                "type": "string",
                "value": "\"root\""
            },
            {
                "name": "storageDriverHost",
                "desc": "Cadvisor storage driver host.",
                "nixName": "storageDriverHost",
                "type": "string",
                "value": "\"localhost:8086\""
            },
            {
                "name": "storageDriverPassword",
                "desc": "Cadvisor storage driver password.  Warning: this password is stored in the world-readable Nix store.It\u2019s recommended to use the  storageDriverPasswordFile  option since that givesyou control over the security of the password.  storageDriverPasswordFile also takes precedence over  storageDriverPassword .",
                "nixName": "storageDriverPassword",
                "type": "string",
                "value": "\"root\""
            },
            {
                "name": "storageDriverPasswordFile",
                "desc": "File that contains the cadvisor storage driver password.   storageDriverPasswordFile  takes precedence over storageDriverPassword   Warning: when  storageDriverPassword  is non-empty this defaults toa file in the world-readable Nix store that contains the value of  storageDriverPassword .  It\u2019s recommended to override this with a path not in the Nix store.Tip: use  nixops keymanagement",
                "nixName": "storageDriverPasswordFile",
                "type": "string",
                "value": null
            },
            {
                "name": "storageDriverSecure",
                "desc": "Cadvisor storage driver, enable secure communication.",
                "nixName": "storageDriverSecure",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "storageDriverUser",
                "desc": "Cadvisor storage driver username.",
                "nixName": "storageDriverUser",
                "type": "string",
                "value": "\"root\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Netdata",
        "desc": "Real-time performance monitoring tool",
        "tags": [
            "Monitoring"
        ],
        "website": "https://www.netdata.cloud/",
        "logo": "https://www.netdata.cloud/favicon-32x32.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "netdata",
        "options": [
            {
                "name": "claimTokenFile",
                "desc": "If set, automatically registers the agent using the given claim tokenfile.",
                "nixName": "claimTokenFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "config",
                "desc": "netdata.conf configuration as nix attributes. cannot be combined withconfigText.",
                "nixName": "config",
                "type": "attribute set of (attribute set)",
                "value": "{ }"
            },
            {
                "name": "configDir",
                "desc": "Complete netdata config directory except netdata.conf. The defaultconfiguration is merged with changes defined in this option. Eachtop-level attribute denotes a path in the configuration directory as inenvironment.etc. Its value is the absolute path and must be readable bynetdata. Cannot be combined with configText.",
                "nixName": "configDir",
                "type": "attribute set of path",
                "value": "{ }"
            },
            {
                "name": "configText",
                "desc": "Verbatim netdata.conf, cannot be combined with config.",
                "nixName": "configText",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "deadlineBeforeStopSec",
                "desc": "In order to detect when netdata is misbehaving, we run a concurrenttask pinging netdata (wait-for-netdata-up) in the systemd unit.  If after a while, this task does not succeed, we stop the unit andmark it as failed.  You can control this deadline in seconds with this option, it\u2019suseful to bump it if you have (1) a lot of data (2) doing upgrades (3)have low IOPS/throughput.",
                "nixName": "deadlineBeforeStopSec",
                "type": "signed integer",
                "value": "120"
            },
            {
                "name": "enable",
                "desc": "Whether to enable netdata.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableAnalyticsReporting",
                "desc": "Enable reporting of anonymous usage statistics to Netdata Inc. viaeither Google Analytics (in versions prior to 1.29.4), or Netdata Inc.\u2019sself-hosted PostHog (in versions 1.29.4 and later). See:  https://learn.netdata.cloud/docs/agent/anonymous-statistics",
                "nixName": "enableAnalyticsReporting",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraPluginPaths",
                "desc": "Extra paths to add to the netdata global \u201cplugins directory\u201d option.Useful for when you want to include your own collection scripts.  Details about writing a custom netdata plugin are available at:  https://docs.netdata.cloud/collectors/plugins.d/   Cannot be combined with configText.",
                "nixName": "extraPluginPaths",
                "type": "list of path",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "Group under which netdata runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"netdata\""
            },
            {
                "name": "package",
                "desc": "The netdata package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.netdata"
            },
            {
                "name": "python.enable",
                "desc": "Whether to enable python-based plugins",
                "nixName": "python.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "python.extraPackages",
                "desc": "Extra python packages available at runtime to enable additionalpython plugins.",
                "nixName": "python.extraPackages",
                "type": "function that evaluates to a(n) list of package",
                "value": "ps: []"
            },
            {
                "name": "python.recommendedPythonPackages",
                "desc": "Whether to enable a set of recommended Python plugins by installingextra Python packages.",
                "nixName": "python.recommendedPythonPackages",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "user",
                "desc": "User account under which netdata runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"netdata\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Prometheus",
        "desc": "Service monitoring system and time series database",
        "tags": [
            "Monitoring"
        ],
        "website": "https://prometheus.io",
        "logo": "https://prometheus.io/assets/favicons/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "prometheus",
        "options": [
            {
                "name": "alertmanager.checkConfig",
                "desc": "Check configuration with  amtool check-config . The callto  amtool  is subject to sandboxing by Nix.  If you use credentials stored in external files( environmentFile , etc), they will not be visible to amtool  and it will report errors, despite a correctconfiguration.",
                "nixName": "alertmanager.checkConfig",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "alertmanager.clusterPeers",
                "desc": "Initial peers for HA cluster.",
                "nixName": "alertmanager.clusterPeers",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "alertmanager.configText",
                "desc": "Alertmanager configuration as YAML text. If non-null, this optiondefines the text that is written to alertmanager.yml. If null, thecontents of alertmanager.yml is generated from the structured configoptions.",
                "nixName": "alertmanager.configText",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "alertmanager.configuration",
                "desc": "Alertmanager configuration as nix attribute set.",
                "nixName": "alertmanager.configuration",
                "type": "null or (attribute set)",
                "value": "null"
            },
            {
                "name": "alertmanager.enable",
                "desc": "Whether to enable Prometheus Alertmanager.",
                "nixName": "alertmanager.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "alertmanager.environmentFile",
                "desc": "File to load as environment file. Environment variables from thisfile will be interpolated into the config file using envsubst with thissyntax:  $ENVIRONMENT ${VARIABLE}",
                "nixName": "alertmanager.environmentFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "alertmanager.extraFlags",
                "desc": "Extra commandline options when launching the Alertmanager.",
                "nixName": "alertmanager.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "alertmanager.listenAddress",
                "desc": "Address to listen on for the web interface and API. Empty string willlisten on all interfaces. \u201clocalhost\u201d will listen on 127.0.0.1 (but not::1).",
                "nixName": "alertmanager.listenAddress",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "alertmanager.logFormat",
                "desc": "If set use a syslog logger or JSON logging.",
                "nixName": "alertmanager.logFormat",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "alertmanager.logLevel",
                "desc": "Only log messages with the given severity or above.",
                "nixName": "alertmanager.logLevel",
                "type": "one of \"debug\", \"info\", \"warn\", \"error\", \"fatal\"",
                "value": "\"warn\""
            },
            {
                "name": "alertmanager.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "alertmanager.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "alertmanager.package",
                "desc": "The prometheus-alertmanager package to use.",
                "nixName": "alertmanager.package",
                "type": "package",
                "value": "pkgs.prometheus-alertmanager"
            },
            {
                "name": "alertmanager.port",
                "desc": "Port to listen on for the web interface and API.",
                "nixName": "alertmanager.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9093"
            },
            {
                "name": "alertmanager.webExternalUrl",
                "desc": "The URL under which Alertmanager is externally reachable (forexample, if Alertmanager is served via a reverse proxy). Used forgenerating relative and absolute links back to Alertmanager itself. Ifthe URL has a path portion, it will be used to prefix all HTTP endointsserved by Alertmanager. If omitted, relevant URL components will bederived automatically.",
                "nixName": "alertmanager.webExternalUrl",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "alertmanagerIrcRelay.enable",
                "desc": "Whether to enable Alertmanager IRC Relay.",
                "nixName": "alertmanagerIrcRelay.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "alertmanagerIrcRelay.extraFlags",
                "desc": "Extra command line options to pass to alertmanager-irc-relay.",
                "nixName": "alertmanagerIrcRelay.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "alertmanagerIrcRelay.package",
                "desc": "The alertmanager-irc-relay package to use.",
                "nixName": "alertmanagerIrcRelay.package",
                "type": "package",
                "value": "pkgs.alertmanager-irc-relay"
            },
            {
                "name": "alertmanagerIrcRelay.settings",
                "desc": "Configuration for Alertmanager IRC Relay as a Nix attribute set. Fora reference, check out the  exampleconfiguration  and the  sourcecode .  Note: The webhook\u2019s URL MUST point to the IRC channel where themessage should be posted. For  #mychannel  from the example,this would be  http://localhost:8080/mychannel .",
                "nixName": "alertmanagerIrcRelay.settings",
                "type": "YAML value",
                "value": null
            },
            {
                "name": "alertmanagerNotificationQueueCapacity",
                "desc": "The capacity of the queue for pending alert managernotifications.",
                "nixName": "alertmanagerNotificationQueueCapacity",
                "type": "signed integer",
                "value": "10000"
            },
            {
                "name": "alertmanagerWebhookLogger.enable",
                "desc": "Whether to enable Alertmanager Webhook Logger.",
                "nixName": "alertmanagerWebhookLogger.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "alertmanagerWebhookLogger.extraFlags",
                "desc": "Extra command line options to pass toalertmanager-webhook-logger.",
                "nixName": "alertmanagerWebhookLogger.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "alertmanagerWebhookLogger.package",
                "desc": "The alertmanager-webhook-logger package to use.",
                "nixName": "alertmanagerWebhookLogger.package",
                "type": "package",
                "value": "pkgs.alertmanager-webhook-logger"
            },
            {
                "name": "alertmanagers",
                "desc": "A list of alertmanagers to send alerts to. See  theofficial documentation  for more information.",
                "nixName": "alertmanagers",
                "type": "list of (attribute set)",
                "value": "[ ]"
            },
            {
                "name": "checkConfig",
                "desc": "Check configuration with  promtool check . The call to promtool  is subject to sandboxing by Nix.  If you use credentials stored in external files( password_file ,  bearer_token_file , etc), theywill not be visible to  promtool  and it will report errors,despite a correct configuration. To resolve this, you may set thisoption to  \"syntax-only\"  in order to only syntax check thePrometheus configuration.",
                "nixName": "checkConfig",
                "type": "boolean or value \"syntax-only\" (singular enum)",
                "value": "true"
            },
            {
                "name": "configText",
                "desc": "If non-null, this option defines the text that is written toprometheus.yml. If null, the contents of prometheus.yml is generatedfrom the structured config options.",
                "nixName": "configText",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Prometheus monitoring daemon.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableAgentMode",
                "desc": "Whether to enable agent mode.",
                "nixName": "enableAgentMode",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableReload",
                "desc": "Reload prometheus when configuration file changes (instead ofrestart).  The following property holds: switching to a configuration( switch-to-configuration ) that changes the prometheusconfiguration only finishes successfully when prometheus has finishedloading the new configuration.",
                "nixName": "enableReload",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters",
                "desc": "Prometheus exporter configuration",
                "nixName": "exporters",
                "type": "submodule",
                "value": "{ }"
            },
            {
                "name": "exporters.apcupsd.apcupsdAddress",
                "desc": "Address of the apcupsd Network Information Server (NIS).",
                "nixName": "exporters.apcupsd.apcupsdAddress",
                "type": "string",
                "value": "\":3551\""
            },
            {
                "name": "exporters.apcupsd.apcupsdNetwork",
                "desc": "Network of the apcupsd Network Information Server (NIS): one of\u201ctcp\u201d, \u201ctcp4\u201d, or \u201ctcp6\u201d.",
                "nixName": "exporters.apcupsd.apcupsdNetwork",
                "type": "one of \"tcp\", \"tcp4\", \"tcp6\"",
                "value": "\"tcp\""
            },
            {
                "name": "exporters.apcupsd.enable",
                "desc": "Whether to enable the prometheus apcupsd exporter.",
                "nixName": "exporters.apcupsd.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.apcupsd.extraFlags",
                "desc": "Extra commandline options to pass to the apcupsd exporter.",
                "nixName": "exporters.apcupsd.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.apcupsd.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.apcupsd.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.apcupsd.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.apcupsd.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.apcupsd.openFirewall is true.",
                "nixName": "exporters.apcupsd.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.apcupsd.group",
                "desc": "Group under which the apcupsd exporter shall be run.",
                "nixName": "exporters.apcupsd.group",
                "type": "string",
                "value": "\"apcupsd-exporter\""
            },
            {
                "name": "exporters.apcupsd.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.apcupsd.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.apcupsd.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.apcupsd.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.apcupsd.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.apcupsd.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9162"
            },
            {
                "name": "exporters.apcupsd.user",
                "desc": "User name under which the apcupsd exporter shall be run.",
                "nixName": "exporters.apcupsd.user",
                "type": "string",
                "value": "\"apcupsd-exporter\""
            },
            {
                "name": "exporters.artifactory.artiAccessToken",
                "desc": "Access token for authentication against JFrog Artifactory API. One ofthe password or access token needs to be set.",
                "nixName": "exporters.artifactory.artiAccessToken",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.artifactory.artiPassword",
                "desc": "Password for authentication against JFrog Artifactory API. One of thepassword or access token needs to be set.",
                "nixName": "exporters.artifactory.artiPassword",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.artifactory.artiUsername",
                "desc": "Username for authentication against JFrog Artifactory API.",
                "nixName": "exporters.artifactory.artiUsername",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.artifactory.enable",
                "desc": "Whether to enable the prometheus artifactory exporter.",
                "nixName": "exporters.artifactory.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.artifactory.extraFlags",
                "desc": "Extra commandline options to pass to the artifactory exporter.",
                "nixName": "exporters.artifactory.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.artifactory.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.artifactory.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.artifactory.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.artifactory.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.artifactory.openFirewall is true.",
                "nixName": "exporters.artifactory.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.artifactory.group",
                "desc": "Group under which the artifactory exporter shall be run.",
                "nixName": "exporters.artifactory.group",
                "type": "string",
                "value": "\"artifactory-exporter\""
            },
            {
                "name": "exporters.artifactory.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.artifactory.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.artifactory.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.artifactory.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.artifactory.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.artifactory.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9531"
            },
            {
                "name": "exporters.artifactory.scrapeUri",
                "desc": "URI on which to scrape JFrog Artifactory.",
                "nixName": "exporters.artifactory.scrapeUri",
                "type": "string",
                "value": "\"http://localhost:8081/artifactory\""
            },
            {
                "name": "exporters.artifactory.user",
                "desc": "User name under which the artifactory exporter shall be run.",
                "nixName": "exporters.artifactory.user",
                "type": "string",
                "value": "\"artifactory-exporter\""
            },
            {
                "name": "exporters.bind.bindGroups",
                "desc": "List of statistics to collect. Available: [server, view, tasks]",
                "nixName": "exporters.bind.bindGroups",
                "type": "list of (one of \"server\", \"view\", \"tasks\")",
                "value": "[\n  \"server\"\n  \"view\"\n]"
            },
            {
                "name": "exporters.bind.bindTimeout",
                "desc": "Timeout for trying to get stats from Bind.",
                "nixName": "exporters.bind.bindTimeout",
                "type": "string",
                "value": "\"10s\""
            },
            {
                "name": "exporters.bind.bindURI",
                "desc": "HTTP XML API address of an Bind server.",
                "nixName": "exporters.bind.bindURI",
                "type": "string",
                "value": "\"http://localhost:8053/\""
            },
            {
                "name": "exporters.bind.bindVersion",
                "desc": "BIND statistics version. Can be detected automatically.",
                "nixName": "exporters.bind.bindVersion",
                "type": "one of \"xml.v2\", \"xml.v3\", \"auto\"",
                "value": "\"auto\""
            },
            {
                "name": "exporters.bind.enable",
                "desc": "Whether to enable the prometheus bind exporter.",
                "nixName": "exporters.bind.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.bind.extraFlags",
                "desc": "Extra commandline options to pass to the bind exporter.",
                "nixName": "exporters.bind.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.bind.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.bind.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.bind.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.bind.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.bind.openFirewall  istrue.",
                "nixName": "exporters.bind.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.bind.group",
                "desc": "Group under which the bind exporter shall be run.",
                "nixName": "exporters.bind.group",
                "type": "string",
                "value": "\"bind-exporter\""
            },
            {
                "name": "exporters.bind.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.bind.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.bind.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.bind.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.bind.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.bind.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9119"
            },
            {
                "name": "exporters.bind.user",
                "desc": "User name under which the bind exporter shall be run.",
                "nixName": "exporters.bind.user",
                "type": "string",
                "value": "\"bind-exporter\""
            },
            {
                "name": "exporters.bird.birdSocket",
                "desc": "Path to BIRD2 (or BIRD1 v4) socket.",
                "nixName": "exporters.bird.birdSocket",
                "type": "path",
                "value": "\"/run/bird/bird.ctl\""
            },
            {
                "name": "exporters.bird.birdVersion",
                "desc": "Specifies whether BIRD1 or BIRD2 is in use.",
                "nixName": "exporters.bird.birdVersion",
                "type": "one of 1, 2",
                "value": "2"
            },
            {
                "name": "exporters.bird.enable",
                "desc": "Whether to enable the prometheus bird exporter.",
                "nixName": "exporters.bird.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.bird.extraFlags",
                "desc": "Extra commandline options to pass to the bird exporter.",
                "nixName": "exporters.bird.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.bird.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.bird.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.bird.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.bird.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.bird.openFirewall  istrue.",
                "nixName": "exporters.bird.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.bird.group",
                "desc": "Group under which the bird exporter shall be run.",
                "nixName": "exporters.bird.group",
                "type": "string",
                "value": "\"bird-exporter\""
            },
            {
                "name": "exporters.bird.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.bird.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.bird.newMetricFormat",
                "desc": "Enable the new more-generic metric format.",
                "nixName": "exporters.bird.newMetricFormat",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.bird.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.bird.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.bird.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.bird.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9324"
            },
            {
                "name": "exporters.bird.user",
                "desc": "User name under which the bird exporter shall be run.",
                "nixName": "exporters.bird.user",
                "type": "string",
                "value": "\"bird-exporter\""
            },
            {
                "name": "exporters.bitcoin.enable",
                "desc": "Whether to enable the prometheus bitcoin exporter.",
                "nixName": "exporters.bitcoin.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.bitcoin.extraEnv",
                "desc": "Extra environment variables for the exporter.",
                "nixName": "exporters.bitcoin.extraEnv",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "exporters.bitcoin.extraFlags",
                "desc": "Extra commandline options to pass to the bitcoin exporter.",
                "nixName": "exporters.bitcoin.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.bitcoin.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.bitcoin.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.bitcoin.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.bitcoin.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.bitcoin.openFirewall is true.",
                "nixName": "exporters.bitcoin.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.bitcoin.group",
                "desc": "Group under which the bitcoin exporter shall be run.",
                "nixName": "exporters.bitcoin.group",
                "type": "string",
                "value": "\"bitcoin-exporter\""
            },
            {
                "name": "exporters.bitcoin.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.bitcoin.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.bitcoin.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.bitcoin.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.bitcoin.package",
                "desc": "The prometheus-bitcoin-exporter package to use.",
                "nixName": "exporters.bitcoin.package",
                "type": "package",
                "value": "pkgs.prometheus-bitcoin-exporter"
            },
            {
                "name": "exporters.bitcoin.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.bitcoin.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9332"
            },
            {
                "name": "exporters.bitcoin.refreshSeconds",
                "desc": "How often to ask bitcoind for metrics.",
                "nixName": "exporters.bitcoin.refreshSeconds",
                "type": "unsigned integer, meaning >=0",
                "value": "300"
            },
            {
                "name": "exporters.bitcoin.rpcHost",
                "desc": "RPC host.",
                "nixName": "exporters.bitcoin.rpcHost",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "exporters.bitcoin.rpcPasswordFile",
                "desc": "File containing RPC password.",
                "nixName": "exporters.bitcoin.rpcPasswordFile",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.bitcoin.rpcPort",
                "desc": "RPC port number.",
                "nixName": "exporters.bitcoin.rpcPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8332"
            },
            {
                "name": "exporters.bitcoin.rpcScheme",
                "desc": "Whether to connect to bitcoind over http or https.",
                "nixName": "exporters.bitcoin.rpcScheme",
                "type": "one of \"http\", \"https\"",
                "value": "\"http\""
            },
            {
                "name": "exporters.bitcoin.rpcUser",
                "desc": "RPC user name.",
                "nixName": "exporters.bitcoin.rpcUser",
                "type": "string",
                "value": "\"bitcoinrpc\""
            },
            {
                "name": "exporters.bitcoin.user",
                "desc": "User name under which the bitcoin exporter shall be run.",
                "nixName": "exporters.bitcoin.user",
                "type": "string",
                "value": "\"bitcoin-exporter\""
            },
            {
                "name": "exporters.blackbox.configFile",
                "desc": "Path to configuration file.",
                "nixName": "exporters.blackbox.configFile",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.blackbox.enable",
                "desc": "Whether to enable the prometheus blackbox exporter.",
                "nixName": "exporters.blackbox.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.blackbox.enableConfigCheck",
                "desc": "Whether to run a correctness check for the configuration file. Thisdepends on the configuration file residing in the nix-store. Pathspassed as string will be copied to the store.",
                "nixName": "exporters.blackbox.enableConfigCheck",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.blackbox.extraFlags",
                "desc": "Extra commandline options to pass to the blackbox exporter.",
                "nixName": "exporters.blackbox.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.blackbox.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.blackbox.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.blackbox.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.blackbox.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.blackbox.openFirewall is true.",
                "nixName": "exporters.blackbox.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.blackbox.group",
                "desc": "Group under which the blackbox exporter shall be run.",
                "nixName": "exporters.blackbox.group",
                "type": "string",
                "value": "\"blackbox-exporter\""
            },
            {
                "name": "exporters.blackbox.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.blackbox.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.blackbox.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.blackbox.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.blackbox.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.blackbox.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9115"
            },
            {
                "name": "exporters.blackbox.user",
                "desc": "User name under which the blackbox exporter shall be run.",
                "nixName": "exporters.blackbox.user",
                "type": "string",
                "value": "\"blackbox-exporter\""
            },
            {
                "name": "exporters.buildkite-agent.enable",
                "desc": "Whether to enable the prometheus buildkite-agent exporter.",
                "nixName": "exporters.buildkite-agent.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.buildkite-agent.endpoint",
                "desc": "The Buildkite Agent API endpoint.",
                "nixName": "exporters.buildkite-agent.endpoint",
                "type": "string",
                "value": "\"https://agent.buildkite.com/v3\""
            },
            {
                "name": "exporters.buildkite-agent.extraFlags",
                "desc": "Extra commandline options to pass to the buildkite-agentexporter.",
                "nixName": "exporters.buildkite-agent.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.buildkite-agent.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.buildkite-agent.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.buildkite-agent.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.buildkite-agent.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.buildkite-agent.openFirewall is true.",
                "nixName": "exporters.buildkite-agent.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.buildkite-agent.group",
                "desc": "Group under which the buildkite-agent exporter shall be run.",
                "nixName": "exporters.buildkite-agent.group",
                "type": "string",
                "value": "\"buildkite-agent-exporter\""
            },
            {
                "name": "exporters.buildkite-agent.interval",
                "desc": "How often to update metrics.",
                "nixName": "exporters.buildkite-agent.interval",
                "type": "string",
                "value": "\"30s\""
            },
            {
                "name": "exporters.buildkite-agent.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.buildkite-agent.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.buildkite-agent.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.buildkite-agent.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.buildkite-agent.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.buildkite-agent.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9876"
            },
            {
                "name": "exporters.buildkite-agent.queues",
                "desc": "Which specific queues to process.",
                "nixName": "exporters.buildkite-agent.queues",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "exporters.buildkite-agent.tokenPath",
                "desc": "The token from your Buildkite \u201cAgents\u201d page.  A run-time path to the token file, which is supposed to beprovisioned outside of Nix store.",
                "nixName": "exporters.buildkite-agent.tokenPath",
                "type": "null or path",
                "value": null
            },
            {
                "name": "exporters.buildkite-agent.user",
                "desc": "User name under which the buildkite-agent exporter shall be run.",
                "nixName": "exporters.buildkite-agent.user",
                "type": "string",
                "value": "\"buildkite-agent-exporter\""
            },
            {
                "name": "exporters.collectd.collectdBinary.authFile",
                "desc": "File mapping user names to pre-shared keys (passwords).",
                "nixName": "exporters.collectd.collectdBinary.authFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.collectd.collectdBinary.enable",
                "desc": "Whether to enable collectd binary protocol receiver.",
                "nixName": "exporters.collectd.collectdBinary.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.collectd.collectdBinary.listenAddress",
                "desc": "Address to listen on for binary network packets.",
                "nixName": "exporters.collectd.collectdBinary.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.collectd.collectdBinary.port",
                "desc": "Network address on which to accept collectd binary networkpackets.",
                "nixName": "exporters.collectd.collectdBinary.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "25826"
            },
            {
                "name": "exporters.collectd.collectdBinary.securityLevel",
                "desc": "Minimum required security level for accepted packets.",
                "nixName": "exporters.collectd.collectdBinary.securityLevel",
                "type": "one of \"None\", \"Sign\", \"Encrypt\"",
                "value": "\"None\""
            },
            {
                "name": "exporters.collectd.enable",
                "desc": "Whether to enable the prometheus collectd exporter.",
                "nixName": "exporters.collectd.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.collectd.extraFlags",
                "desc": "Extra commandline options to pass to the collectd exporter.",
                "nixName": "exporters.collectd.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.collectd.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.collectd.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.collectd.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.collectd.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.collectd.openFirewall is true.",
                "nixName": "exporters.collectd.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.collectd.group",
                "desc": "Group under which the collectd exporter shall be run.",
                "nixName": "exporters.collectd.group",
                "type": "string",
                "value": "\"collectd-exporter\""
            },
            {
                "name": "exporters.collectd.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.collectd.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.collectd.logFormat",
                "desc": "Set the log format.",
                "nixName": "exporters.collectd.logFormat",
                "type": "one of \"logfmt\", \"json\"",
                "value": "\"logfmt\""
            },
            {
                "name": "exporters.collectd.logLevel",
                "desc": "Only log messages with the given severity or above.",
                "nixName": "exporters.collectd.logLevel",
                "type": "one of \"debug\", \"info\", \"warn\", \"error\", \"fatal\"",
                "value": "\"info\""
            },
            {
                "name": "exporters.collectd.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.collectd.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.collectd.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.collectd.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9103"
            },
            {
                "name": "exporters.collectd.user",
                "desc": "User name under which the collectd exporter shall be run.",
                "nixName": "exporters.collectd.user",
                "type": "string",
                "value": "\"collectd-exporter\""
            },
            {
                "name": "exporters.dmarc.debug",
                "desc": "Whether to declare enable  --debug .",
                "nixName": "exporters.dmarc.debug",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.dmarc.deduplicationMaxSeconds",
                "desc": "How long individual report IDs will be remembered to avoid countingdouble delivered reports twice.",
                "nixName": "exporters.dmarc.deduplicationMaxSeconds",
                "type": "unsigned integer, meaning >=0",
                "value": "\"7 days (in seconds)\""
            },
            {
                "name": "exporters.dmarc.enable",
                "desc": "Whether to enable the prometheus dmarc exporter.",
                "nixName": "exporters.dmarc.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.dmarc.extraFlags",
                "desc": "Extra commandline options to pass to the dmarc exporter.",
                "nixName": "exporters.dmarc.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.dmarc.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.dmarc.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.dmarc.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.dmarc.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.dmarc.openFirewall  istrue.",
                "nixName": "exporters.dmarc.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.dmarc.folders.done",
                "desc": "IMAP mailbox that successfully processed reports are moved to.",
                "nixName": "exporters.dmarc.folders.done",
                "type": "string",
                "value": "\"Archive\""
            },
            {
                "name": "exporters.dmarc.folders.error",
                "desc": "IMAP mailbox that emails are moved to that could not beprocessed.",
                "nixName": "exporters.dmarc.folders.error",
                "type": "string",
                "value": "\"Invalid\""
            },
            {
                "name": "exporters.dmarc.folders.inbox",
                "desc": "IMAP mailbox that is checked for incoming DMARC aggregate reports",
                "nixName": "exporters.dmarc.folders.inbox",
                "type": "string",
                "value": "\"INBOX\""
            },
            {
                "name": "exporters.dmarc.group",
                "desc": "Group under which the dmarc exporter shall be run.",
                "nixName": "exporters.dmarc.group",
                "type": "string",
                "value": "\"dmarc-exporter\""
            },
            {
                "name": "exporters.dmarc.imap.host",
                "desc": "Hostname of IMAP server to connect to.",
                "nixName": "exporters.dmarc.imap.host",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "exporters.dmarc.imap.passwordFile",
                "desc": "File containing the login password for the IMAP connection.",
                "nixName": "exporters.dmarc.imap.passwordFile",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.dmarc.imap.port",
                "desc": "Port of the IMAP server to connect to.",
                "nixName": "exporters.dmarc.imap.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "993"
            },
            {
                "name": "exporters.dmarc.imap.username",
                "desc": "Login username for the IMAP connection.",
                "nixName": "exporters.dmarc.imap.username",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.dmarc.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.dmarc.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.dmarc.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.dmarc.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.dmarc.pollIntervalSeconds",
                "desc": "How often to poll the IMAP server in seconds.",
                "nixName": "exporters.dmarc.pollIntervalSeconds",
                "type": "unsigned integer, meaning >=0",
                "value": "60"
            },
            {
                "name": "exporters.dmarc.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.dmarc.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9797"
            },
            {
                "name": "exporters.dmarc.user",
                "desc": "User name under which the dmarc exporter shall be run.",
                "nixName": "exporters.dmarc.user",
                "type": "string",
                "value": "\"dmarc-exporter\""
            },
            {
                "name": "exporters.dnsmasq.dnsmasqListenAddress",
                "desc": "Address on which dnsmasq listens.",
                "nixName": "exporters.dnsmasq.dnsmasqListenAddress",
                "type": "string",
                "value": "\"localhost:53\""
            },
            {
                "name": "exporters.dnsmasq.enable",
                "desc": "Whether to enable the prometheus dnsmasq exporter.",
                "nixName": "exporters.dnsmasq.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.dnsmasq.extraFlags",
                "desc": "Extra commandline options to pass to the dnsmasq exporter.",
                "nixName": "exporters.dnsmasq.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.dnsmasq.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.dnsmasq.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.dnsmasq.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.dnsmasq.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.dnsmasq.openFirewall is true.",
                "nixName": "exporters.dnsmasq.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.dnsmasq.group",
                "desc": "Group under which the dnsmasq exporter shall be run.",
                "nixName": "exporters.dnsmasq.group",
                "type": "string",
                "value": "\"dnsmasq-exporter\""
            },
            {
                "name": "exporters.dnsmasq.leasesPath",
                "desc": "Path to the  dnsmasq.leases  file.",
                "nixName": "exporters.dnsmasq.leasesPath",
                "type": "path",
                "value": "\"/var/lib/misc/dnsmasq.leases\""
            },
            {
                "name": "exporters.dnsmasq.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.dnsmasq.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.dnsmasq.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.dnsmasq.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.dnsmasq.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.dnsmasq.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9153"
            },
            {
                "name": "exporters.dnsmasq.user",
                "desc": "User name under which the dnsmasq exporter shall be run.",
                "nixName": "exporters.dnsmasq.user",
                "type": "string",
                "value": "\"dnsmasq-exporter\""
            },
            {
                "name": "exporters.dnssec.configuration",
                "desc": "dnssec exporter configuration as nix attribute set.  See  https://github.com/chrj/prometheus-dnssec-exporter/blob/master/README.md for the description of the configuration file format.",
                "nixName": "exporters.dnssec.configuration",
                "type": "null or (attribute set)",
                "value": "null"
            },
            {
                "name": "exporters.dnssec.enable",
                "desc": "Whether to enable the prometheus dnssec exporter.",
                "nixName": "exporters.dnssec.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.dnssec.extraFlags",
                "desc": "Extra commandline options when launching Prometheus.",
                "nixName": "exporters.dnssec.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.dnssec.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.dnssec.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.dnssec.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.dnssec.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.dnssec.openFirewall is true.",
                "nixName": "exporters.dnssec.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.dnssec.group",
                "desc": "Group under which the dnssec exporter shall be run.",
                "nixName": "exporters.dnssec.group",
                "type": "string",
                "value": "\"dnssec-exporter\""
            },
            {
                "name": "exporters.dnssec.listenAddress",
                "desc": "Listen address as host IP and port definition.",
                "nixName": "exporters.dnssec.listenAddress",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.dnssec.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.dnssec.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.dnssec.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.dnssec.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9204"
            },
            {
                "name": "exporters.dnssec.resolvers",
                "desc": "DNSSEC capable resolver to be used for the check.",
                "nixName": "exporters.dnssec.resolvers",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.dnssec.timeout",
                "desc": "DNS request timeout duration.",
                "nixName": "exporters.dnssec.timeout",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.dnssec.user",
                "desc": "User name under which the dnssec exporter shall be run.",
                "nixName": "exporters.dnssec.user",
                "type": "string",
                "value": "\"dnssec-exporter\""
            },
            {
                "name": "exporters.domain.enable",
                "desc": "Whether to enable the prometheus domain exporter.",
                "nixName": "exporters.domain.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.domain.extraFlags",
                "desc": "Extra commandline options to pass to the domain exporter.",
                "nixName": "exporters.domain.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.domain.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.domain.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.domain.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.domain.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.domain.openFirewall is true.",
                "nixName": "exporters.domain.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.domain.group",
                "desc": "Group under which the domain exporter shall be run.",
                "nixName": "exporters.domain.group",
                "type": "string",
                "value": "\"domain-exporter\""
            },
            {
                "name": "exporters.domain.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.domain.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.domain.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.domain.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.domain.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.domain.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9222"
            },
            {
                "name": "exporters.domain.user",
                "desc": "User name under which the domain exporter shall be run.",
                "nixName": "exporters.domain.user",
                "type": "string",
                "value": "\"domain-exporter\""
            },
            {
                "name": "exporters.dovecot.enable",
                "desc": "Whether to enable the prometheus dovecot exporter.",
                "nixName": "exporters.dovecot.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.dovecot.extraFlags",
                "desc": "Extra commandline options to pass to the dovecot exporter.",
                "nixName": "exporters.dovecot.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.dovecot.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.dovecot.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.dovecot.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.dovecot.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.dovecot.openFirewall is true.",
                "nixName": "exporters.dovecot.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.dovecot.group",
                "desc": "Group under which the dovecot exporter shall be run.",
                "nixName": "exporters.dovecot.group",
                "type": "string",
                "value": "\"dovecot-exporter\""
            },
            {
                "name": "exporters.dovecot.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.dovecot.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.dovecot.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.dovecot.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.dovecot.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.dovecot.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9166"
            },
            {
                "name": "exporters.dovecot.scopes",
                "desc": "Stats scopes to query.",
                "nixName": "exporters.dovecot.scopes",
                "type": "list of string",
                "value": "[\n  \"user\"\n]"
            },
            {
                "name": "exporters.dovecot.socketPath",
                "desc": "Path under which the stats socket is placed. The user/group underwhich the exporter runs, should be able to access the socket in order toscrape the metrics successfully.  Please keep in mind that the stats module has changed in  Dovecot 2.3+  which isnot  compatiblewith this exporter .  The following extra config has to be passed to Dovecot to ensure thatrecent versions work with this exporter:   {  services.prometheus.exporters.dovecot.enable = true;  services.prometheus.exporters.dovecot.socketPath = \"/var/run/dovecot2/old-stats\";  services.dovecot2.mailPlugins.globally.enable = [ \"old_stats\" ];  services.dovecot2.extraConfig = ''    service old-stats {      unix_listener old-stats {        user = dovecot-exporter        group = dovecot-exporter        mode = 0660      }      fifo_listener old-stats-mail {        mode = 0660        user = dovecot        group = dovecot      }      fifo_listener old-stats-user {        mode = 0660        user = dovecot        group = dovecot      }    }    plugin {      old_stats_refresh = 30 secs      old_stats_track_cmds = yes    }  '';}",
                "nixName": "exporters.dovecot.socketPath",
                "type": "path",
                "value": "\"/var/run/dovecot/stats\""
            },
            {
                "name": "exporters.dovecot.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.dovecot.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.dovecot.user",
                "desc": "User name under which the dovecot exporter shall be run.",
                "nixName": "exporters.dovecot.user",
                "type": "string",
                "value": "\"dovecot-exporter\""
            },
            {
                "name": "exporters.exportarr-bazarr.apiKeyFile",
                "desc": "File containing the api-key.",
                "nixName": "exporters.exportarr-bazarr.apiKeyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-bazarr.enable",
                "desc": "Whether to enable the prometheus exportarr-bazarr exporter.",
                "nixName": "exporters.exportarr-bazarr.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-bazarr.environment",
                "desc": "See  theconfiguration guide  for available options.",
                "nixName": "exporters.exportarr-bazarr.environment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "exporters.exportarr-bazarr.extraFlags",
                "desc": "Extra commandline options to pass to the exportarr-bazarrexporter.",
                "nixName": "exporters.exportarr-bazarr.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.exportarr-bazarr.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.exportarr-bazarr.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.exportarr-bazarr.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-bazarr.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.exportarr-bazarr.openFirewall is true.",
                "nixName": "exporters.exportarr-bazarr.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-bazarr.group",
                "desc": "Group under which the exportarr-bazarr exporter shall be run.",
                "nixName": "exporters.exportarr-bazarr.group",
                "type": "string",
                "value": "\"exportarr-bazarr-exporter\""
            },
            {
                "name": "exporters.exportarr-bazarr.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.exportarr-bazarr.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.exportarr-bazarr.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.exportarr-bazarr.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-bazarr.package",
                "desc": "The exportarr package to use.",
                "nixName": "exporters.exportarr-bazarr.package",
                "type": "package",
                "value": "pkgs.exportarr"
            },
            {
                "name": "exporters.exportarr-bazarr.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.exportarr-bazarr.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9708"
            },
            {
                "name": "exporters.exportarr-bazarr.url",
                "desc": "The full URL to Sonarr, Radarr, or Lidarr.",
                "nixName": "exporters.exportarr-bazarr.url",
                "type": "string",
                "value": "\"http://127.0.0.1\""
            },
            {
                "name": "exporters.exportarr-bazarr.user",
                "desc": "User name under which the exportarr-bazarr exporter shall be run.",
                "nixName": "exporters.exportarr-bazarr.user",
                "type": "string",
                "value": "\"exportarr-bazarr-exporter\""
            },
            {
                "name": "exporters.exportarr-lidarr.apiKeyFile",
                "desc": "File containing the api-key.",
                "nixName": "exporters.exportarr-lidarr.apiKeyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-lidarr.enable",
                "desc": "Whether to enable the prometheus exportarr-lidarr exporter.",
                "nixName": "exporters.exportarr-lidarr.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-lidarr.environment",
                "desc": "See  theconfiguration guide  for available options.",
                "nixName": "exporters.exportarr-lidarr.environment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "exporters.exportarr-lidarr.extraFlags",
                "desc": "Extra commandline options to pass to the exportarr-lidarrexporter.",
                "nixName": "exporters.exportarr-lidarr.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.exportarr-lidarr.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.exportarr-lidarr.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.exportarr-lidarr.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-lidarr.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.exportarr-lidarr.openFirewall is true.",
                "nixName": "exporters.exportarr-lidarr.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-lidarr.group",
                "desc": "Group under which the exportarr-lidarr exporter shall be run.",
                "nixName": "exporters.exportarr-lidarr.group",
                "type": "string",
                "value": "\"exportarr-lidarr-exporter\""
            },
            {
                "name": "exporters.exportarr-lidarr.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.exportarr-lidarr.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.exportarr-lidarr.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.exportarr-lidarr.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-lidarr.package",
                "desc": "The exportarr package to use.",
                "nixName": "exporters.exportarr-lidarr.package",
                "type": "package",
                "value": "pkgs.exportarr"
            },
            {
                "name": "exporters.exportarr-lidarr.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.exportarr-lidarr.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9708"
            },
            {
                "name": "exporters.exportarr-lidarr.url",
                "desc": "The full URL to Sonarr, Radarr, or Lidarr.",
                "nixName": "exporters.exportarr-lidarr.url",
                "type": "string",
                "value": "\"http://127.0.0.1\""
            },
            {
                "name": "exporters.exportarr-lidarr.user",
                "desc": "User name under which the exportarr-lidarr exporter shall be run.",
                "nixName": "exporters.exportarr-lidarr.user",
                "type": "string",
                "value": "\"exportarr-lidarr-exporter\""
            },
            {
                "name": "exporters.exportarr-prowlarr.apiKeyFile",
                "desc": "File containing the api-key.",
                "nixName": "exporters.exportarr-prowlarr.apiKeyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-prowlarr.enable",
                "desc": "Whether to enable the prometheus exportarr-prowlarr exporter.",
                "nixName": "exporters.exportarr-prowlarr.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-prowlarr.environment",
                "desc": "See  theconfiguration guide  for available options.",
                "nixName": "exporters.exportarr-prowlarr.environment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "exporters.exportarr-prowlarr.extraFlags",
                "desc": "Extra commandline options to pass to the exportarr-prowlarrexporter.",
                "nixName": "exporters.exportarr-prowlarr.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.exportarr-prowlarr.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.exportarr-prowlarr.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.exportarr-prowlarr.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-prowlarr.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.exportarr-prowlarr.openFirewall is true.",
                "nixName": "exporters.exportarr-prowlarr.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-prowlarr.group",
                "desc": "Group under which the exportarr-prowlarr exporter shall be run.",
                "nixName": "exporters.exportarr-prowlarr.group",
                "type": "string",
                "value": "\"exportarr-prowlarr-exporter\""
            },
            {
                "name": "exporters.exportarr-prowlarr.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.exportarr-prowlarr.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.exportarr-prowlarr.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.exportarr-prowlarr.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-prowlarr.package",
                "desc": "The exportarr package to use.",
                "nixName": "exporters.exportarr-prowlarr.package",
                "type": "package",
                "value": "pkgs.exportarr"
            },
            {
                "name": "exporters.exportarr-prowlarr.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.exportarr-prowlarr.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9708"
            },
            {
                "name": "exporters.exportarr-prowlarr.url",
                "desc": "The full URL to Sonarr, Radarr, or Lidarr.",
                "nixName": "exporters.exportarr-prowlarr.url",
                "type": "string",
                "value": "\"http://127.0.0.1\""
            },
            {
                "name": "exporters.exportarr-prowlarr.user",
                "desc": "User name under which the exportarr-prowlarr exporter shall berun.",
                "nixName": "exporters.exportarr-prowlarr.user",
                "type": "string",
                "value": "\"exportarr-prowlarr-exporter\""
            },
            {
                "name": "exporters.exportarr-radarr.apiKeyFile",
                "desc": "File containing the api-key.",
                "nixName": "exporters.exportarr-radarr.apiKeyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-radarr.enable",
                "desc": "Whether to enable the prometheus exportarr-radarr exporter.",
                "nixName": "exporters.exportarr-radarr.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-radarr.environment",
                "desc": "See  theconfiguration guide  for available options.",
                "nixName": "exporters.exportarr-radarr.environment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "exporters.exportarr-radarr.extraFlags",
                "desc": "Extra commandline options to pass to the exportarr-radarrexporter.",
                "nixName": "exporters.exportarr-radarr.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.exportarr-radarr.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.exportarr-radarr.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.exportarr-radarr.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-radarr.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.exportarr-radarr.openFirewall is true.",
                "nixName": "exporters.exportarr-radarr.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-radarr.group",
                "desc": "Group under which the exportarr-radarr exporter shall be run.",
                "nixName": "exporters.exportarr-radarr.group",
                "type": "string",
                "value": "\"exportarr-radarr-exporter\""
            },
            {
                "name": "exporters.exportarr-radarr.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.exportarr-radarr.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.exportarr-radarr.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.exportarr-radarr.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-radarr.package",
                "desc": "The exportarr package to use.",
                "nixName": "exporters.exportarr-radarr.package",
                "type": "package",
                "value": "pkgs.exportarr"
            },
            {
                "name": "exporters.exportarr-radarr.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.exportarr-radarr.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9708"
            },
            {
                "name": "exporters.exportarr-radarr.url",
                "desc": "The full URL to Sonarr, Radarr, or Lidarr.",
                "nixName": "exporters.exportarr-radarr.url",
                "type": "string",
                "value": "\"http://127.0.0.1\""
            },
            {
                "name": "exporters.exportarr-radarr.user",
                "desc": "User name under which the exportarr-radarr exporter shall be run.",
                "nixName": "exporters.exportarr-radarr.user",
                "type": "string",
                "value": "\"exportarr-radarr-exporter\""
            },
            {
                "name": "exporters.exportarr-readarr.apiKeyFile",
                "desc": "File containing the api-key.",
                "nixName": "exporters.exportarr-readarr.apiKeyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-readarr.enable",
                "desc": "Whether to enable the prometheus exportarr-readarr exporter.",
                "nixName": "exporters.exportarr-readarr.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-readarr.environment",
                "desc": "See  theconfiguration guide  for available options.",
                "nixName": "exporters.exportarr-readarr.environment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "exporters.exportarr-readarr.extraFlags",
                "desc": "Extra commandline options to pass to the exportarr-readarrexporter.",
                "nixName": "exporters.exportarr-readarr.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.exportarr-readarr.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.exportarr-readarr.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.exportarr-readarr.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-readarr.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.exportarr-readarr.openFirewall is true.",
                "nixName": "exporters.exportarr-readarr.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-readarr.group",
                "desc": "Group under which the exportarr-readarr exporter shall be run.",
                "nixName": "exporters.exportarr-readarr.group",
                "type": "string",
                "value": "\"exportarr-readarr-exporter\""
            },
            {
                "name": "exporters.exportarr-readarr.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.exportarr-readarr.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.exportarr-readarr.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.exportarr-readarr.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-readarr.package",
                "desc": "The exportarr package to use.",
                "nixName": "exporters.exportarr-readarr.package",
                "type": "package",
                "value": "pkgs.exportarr"
            },
            {
                "name": "exporters.exportarr-readarr.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.exportarr-readarr.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9708"
            },
            {
                "name": "exporters.exportarr-readarr.url",
                "desc": "The full URL to Sonarr, Radarr, or Lidarr.",
                "nixName": "exporters.exportarr-readarr.url",
                "type": "string",
                "value": "\"http://127.0.0.1\""
            },
            {
                "name": "exporters.exportarr-readarr.user",
                "desc": "User name under which the exportarr-readarr exporter shall berun.",
                "nixName": "exporters.exportarr-readarr.user",
                "type": "string",
                "value": "\"exportarr-readarr-exporter\""
            },
            {
                "name": "exporters.exportarr-sonarr.apiKeyFile",
                "desc": "File containing the api-key.",
                "nixName": "exporters.exportarr-sonarr.apiKeyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-sonarr.enable",
                "desc": "Whether to enable the prometheus exportarr-sonarr exporter.",
                "nixName": "exporters.exportarr-sonarr.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-sonarr.environment",
                "desc": "See  theconfiguration guide  for available options.",
                "nixName": "exporters.exportarr-sonarr.environment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "exporters.exportarr-sonarr.extraFlags",
                "desc": "Extra commandline options to pass to the exportarr-sonarrexporter.",
                "nixName": "exporters.exportarr-sonarr.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.exportarr-sonarr.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.exportarr-sonarr.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.exportarr-sonarr.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-sonarr.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.exportarr-sonarr.openFirewall is true.",
                "nixName": "exporters.exportarr-sonarr.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.exportarr-sonarr.group",
                "desc": "Group under which the exportarr-sonarr exporter shall be run.",
                "nixName": "exporters.exportarr-sonarr.group",
                "type": "string",
                "value": "\"exportarr-sonarr-exporter\""
            },
            {
                "name": "exporters.exportarr-sonarr.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.exportarr-sonarr.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.exportarr-sonarr.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.exportarr-sonarr.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.exportarr-sonarr.package",
                "desc": "The exportarr package to use.",
                "nixName": "exporters.exportarr-sonarr.package",
                "type": "package",
                "value": "pkgs.exportarr"
            },
            {
                "name": "exporters.exportarr-sonarr.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.exportarr-sonarr.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9708"
            },
            {
                "name": "exporters.exportarr-sonarr.url",
                "desc": "The full URL to Sonarr, Radarr, or Lidarr.",
                "nixName": "exporters.exportarr-sonarr.url",
                "type": "string",
                "value": "\"http://127.0.0.1\""
            },
            {
                "name": "exporters.exportarr-sonarr.user",
                "desc": "User name under which the exportarr-sonarr exporter shall be run.",
                "nixName": "exporters.exportarr-sonarr.user",
                "type": "string",
                "value": "\"exportarr-sonarr-exporter\""
            },
            {
                "name": "exporters.fastly.configFile",
                "desc": "Path to a fastly-exporter configuration file. Example one can begenerated with  fastly-exporter --config-file-example .",
                "nixName": "exporters.fastly.configFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.fastly.enable",
                "desc": "Whether to enable the prometheus fastly exporter.",
                "nixName": "exporters.fastly.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.fastly.extraFlags",
                "desc": "Extra commandline options to pass to the fastly exporter.",
                "nixName": "exporters.fastly.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.fastly.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.fastly.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.fastly.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.fastly.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.fastly.openFirewall is true.",
                "nixName": "exporters.fastly.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.fastly.group",
                "desc": "Group under which the fastly exporter shall be run.",
                "nixName": "exporters.fastly.group",
                "type": "string",
                "value": "\"fastly-exporter\""
            },
            {
                "name": "exporters.fastly.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.fastly.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.fastly.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.fastly.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.fastly.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.fastly.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9118"
            },
            {
                "name": "exporters.fastly.tokenPath",
                "desc": "A run-time path to the token file, which is supposed to beprovisioned outside of Nix store.",
                "nixName": "exporters.fastly.tokenPath",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.fastly.user",
                "desc": "User name under which the fastly exporter shall be run.",
                "nixName": "exporters.fastly.user",
                "type": "string",
                "value": "\"fastly-exporter\""
            },
            {
                "name": "exporters.flow.asn",
                "desc": "The ASN being monitored.",
                "nixName": "exporters.flow.asn",
                "type": "positive integer, meaning >0",
                "value": null
            },
            {
                "name": "exporters.flow.brokers",
                "desc": "List of Kafka brokers to connect to.",
                "nixName": "exporters.flow.brokers",
                "type": "list of string",
                "value": null
            },
            {
                "name": "exporters.flow.enable",
                "desc": "Whether to enable the prometheus flow exporter.",
                "nixName": "exporters.flow.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.flow.extraFlags",
                "desc": "Extra commandline options to pass to the flow exporter.",
                "nixName": "exporters.flow.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.flow.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.flow.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.flow.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.flow.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.flow.openFirewall  istrue.",
                "nixName": "exporters.flow.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.flow.group",
                "desc": "Group under which the flow exporter shall be run.",
                "nixName": "exporters.flow.group",
                "type": "string",
                "value": "\"flow-exporter\""
            },
            {
                "name": "exporters.flow.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.flow.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.flow.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.flow.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.flow.partitions",
                "desc": "The number of the partitions to consume, none means all.",
                "nixName": "exporters.flow.partitions",
                "type": "list of signed integer",
                "value": "[ ]"
            },
            {
                "name": "exporters.flow.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.flow.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9590"
            },
            {
                "name": "exporters.flow.topic",
                "desc": "The Kafka topic to consume from.",
                "nixName": "exporters.flow.topic",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.flow.user",
                "desc": "User name under which the flow exporter shall be run.",
                "nixName": "exporters.flow.user",
                "type": "string",
                "value": "\"flow-exporter\""
            },
            {
                "name": "exporters.fritz.enable",
                "desc": "Whether to enable the prometheus fritz exporter.",
                "nixName": "exporters.fritz.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.fritz.extraFlags",
                "desc": "Extra commandline options to pass to the fritz exporter.",
                "nixName": "exporters.fritz.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.fritz.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.fritz.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.fritz.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.fritz.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.fritz.openFirewall  istrue.",
                "nixName": "exporters.fritz.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.fritz.group",
                "desc": "Group under which the fritz exporter shall be run.",
                "nixName": "exporters.fritz.group",
                "type": "string",
                "value": "\"fritz-exporter\""
            },
            {
                "name": "exporters.fritz.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.fritz.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.fritz.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.fritz.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.fritz.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.fritz.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9787"
            },
            {
                "name": "exporters.fritz.settings",
                "desc": "Configuration settings for fritz-exporter.",
                "nixName": "exporters.fritz.settings",
                "type": "YAML value",
                "value": null
            },
            {
                "name": "exporters.fritz.settings.devices",
                "desc": "Fritz!-devices to monitor using the exporter.",
                "nixName": "exporters.fritz.settings.devices",
                "type": "list of (YAML value)",
                "value": "[ ]"
            },
            {
                "name": "exporters.fritz.settings.devices.*.host_info",
                "desc": "Enable extended host info for this device.  Warning : Thiswill heavily increase scrape time.",
                "nixName": "exporters.fritz.settings.devices.*.host_info",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.fritz.settings.devices.*.hostname",
                "desc": "Hostname under which the target device is reachable.",
                "nixName": "exporters.fritz.settings.devices.*.hostname",
                "type": "string",
                "value": "\"fritz.box\""
            },
            {
                "name": "exporters.fritz.settings.devices.*.name",
                "desc": "Name to use for the device.",
                "nixName": "exporters.fritz.settings.devices.*.name",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.fritz.settings.devices.*.password_file",
                "desc": "Path to a file which contains the password to authenticate with thetarget device. Needs to be readable by the user the exporter runsunder.",
                "nixName": "exporters.fritz.settings.devices.*.password_file",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.fritz.settings.devices.*.username",
                "desc": "Username to authenticate with the target device.",
                "nixName": "exporters.fritz.settings.devices.*.username",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.fritz.settings.log_level",
                "desc": "Log level to use for the exporter.",
                "nixName": "exporters.fritz.settings.log_level",
                "type": "one of \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"",
                "value": "\"INFO\""
            },
            {
                "name": "exporters.fritz.user",
                "desc": "User name under which the fritz exporter shall be run.",
                "nixName": "exporters.fritz.user",
                "type": "string",
                "value": "\"fritz-exporter\""
            },
            {
                "name": "exporters.fritzbox.enable",
                "desc": "Whether to enable the prometheus fritzbox exporter.",
                "nixName": "exporters.fritzbox.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.fritzbox.extraFlags",
                "desc": "Extra commandline options to pass to the fritzbox exporter.",
                "nixName": "exporters.fritzbox.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.fritzbox.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.fritzbox.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.fritzbox.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.fritzbox.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.fritzbox.openFirewall is true.",
                "nixName": "exporters.fritzbox.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.fritzbox.gatewayAddress",
                "desc": "The hostname or IP of the FRITZ!Box.",
                "nixName": "exporters.fritzbox.gatewayAddress",
                "type": "string",
                "value": "\"fritz.box\""
            },
            {
                "name": "exporters.fritzbox.gatewayPort",
                "desc": "The port of the FRITZ!Box UPnP service.",
                "nixName": "exporters.fritzbox.gatewayPort",
                "type": "signed integer",
                "value": "49000"
            },
            {
                "name": "exporters.fritzbox.group",
                "desc": "Group under which the fritzbox exporter shall be run.",
                "nixName": "exporters.fritzbox.group",
                "type": "string",
                "value": "\"fritzbox-exporter\""
            },
            {
                "name": "exporters.fritzbox.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.fritzbox.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.fritzbox.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.fritzbox.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.fritzbox.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.fritzbox.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9133"
            },
            {
                "name": "exporters.fritzbox.user",
                "desc": "User name under which the fritzbox exporter shall be run.",
                "nixName": "exporters.fritzbox.user",
                "type": "string",
                "value": "\"fritzbox-exporter\""
            },
            {
                "name": "exporters.graphite.enable",
                "desc": "Whether to enable the prometheus graphite exporter.",
                "nixName": "exporters.graphite.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.graphite.extraFlags",
                "desc": "Extra commandline options to pass to the graphite exporter.",
                "nixName": "exporters.graphite.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.graphite.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.graphite.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.graphite.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.graphite.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.graphite.openFirewall is true.",
                "nixName": "exporters.graphite.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.graphite.graphitePort",
                "desc": "Port to use for the graphite server.",
                "nixName": "exporters.graphite.graphitePort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9109"
            },
            {
                "name": "exporters.graphite.group",
                "desc": "Group under which the graphite exporter shall be run.",
                "nixName": "exporters.graphite.group",
                "type": "string",
                "value": "\"graphite-exporter\""
            },
            {
                "name": "exporters.graphite.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.graphite.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.graphite.mappingSettings",
                "desc": "Mapping configuration for the exporter, see  https://github.com/prometheus/graphite_exporter#yaml-config for available options.",
                "nixName": "exporters.graphite.mappingSettings",
                "type": "YAML value",
                "value": "{ }"
            },
            {
                "name": "exporters.graphite.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.graphite.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.graphite.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.graphite.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9108"
            },
            {
                "name": "exporters.graphite.user",
                "desc": "User name under which the graphite exporter shall be run.",
                "nixName": "exporters.graphite.user",
                "type": "string",
                "value": "\"graphite-exporter\""
            },
            {
                "name": "exporters.idrac.configuration",
                "desc": "Configuration for iDRAC exporter, as a nix attribute set.  Configuration reference:  https://github.com/mrlhansen/idrac_exporter/#configuration   Mutually exclusive with  configurationPath  option.",
                "nixName": "exporters.idrac.configuration",
                "type": "null or (attribute set)",
                "value": "null"
            },
            {
                "name": "exporters.idrac.configurationPath",
                "desc": "Path to the service\u2019s config file. This path can either be a computedpath in /nix/store or a path in the local filesystem.  The config file should NOT be stored in /nix/store as it will containpasswords and/or keys in plain text.  Mutually exclusive with  configuration  option.  Configuration reference:  https://github.com/mrlhansen/idrac_exporter/#configuration",
                "nixName": "exporters.idrac.configurationPath",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.idrac.enable",
                "desc": "Whether to enable the prometheus idrac exporter.",
                "nixName": "exporters.idrac.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.idrac.extraFlags",
                "desc": "Extra commandline options to pass to the idrac exporter.",
                "nixName": "exporters.idrac.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.idrac.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.idrac.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.idrac.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.idrac.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.idrac.openFirewall  istrue.",
                "nixName": "exporters.idrac.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.idrac.group",
                "desc": "Group under which the idrac exporter shall be run.",
                "nixName": "exporters.idrac.group",
                "type": "string",
                "value": "\"idrac-exporter\""
            },
            {
                "name": "exporters.idrac.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.idrac.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.idrac.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.idrac.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.idrac.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.idrac.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9348"
            },
            {
                "name": "exporters.idrac.user",
                "desc": "User name under which the idrac exporter shall be run.",
                "nixName": "exporters.idrac.user",
                "type": "string",
                "value": "\"idrac-exporter\""
            },
            {
                "name": "exporters.imap-mailstat.accounts",
                "desc": "Accounts to monitor",
                "nixName": "exporters.imap-mailstat.accounts",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "exporters.imap-mailstat.accounts.<name>.mailaddress",
                "desc": "Your email address (at the moment used as login name)",
                "nixName": "exporters.imap-mailstat.accounts.<name>.mailaddress",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.imap-mailstat.accounts.<name>.password",
                "desc": "",
                "nixName": "exporters.imap-mailstat.accounts.<name>.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.imap-mailstat.accounts.<name>.serveraddress",
                "desc": "mailserver name or address",
                "nixName": "exporters.imap-mailstat.accounts.<name>.serveraddress",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.imap-mailstat.accounts.<name>.serverport",
                "desc": "imap port number (at the moment only tls connection is supported)",
                "nixName": "exporters.imap-mailstat.accounts.<name>.serverport",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "exporters.imap-mailstat.accounts.<name>.starttls",
                "desc": "set to true for using STARTTLS to start a TLS connection",
                "nixName": "exporters.imap-mailstat.accounts.<name>.starttls",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "exporters.imap-mailstat.accounts.<name>.username",
                "desc": "If empty string mailaddress value is used",
                "nixName": "exporters.imap-mailstat.accounts.<name>.username",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.imap-mailstat.configurationFile",
                "desc": "File containing the configuration",
                "nixName": "exporters.imap-mailstat.configurationFile",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.imap-mailstat.enable",
                "desc": "Whether to enable the prometheus imap-mailstat exporter.",
                "nixName": "exporters.imap-mailstat.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.imap-mailstat.extraFlags",
                "desc": "Extra commandline options to pass to the imap-mailstat exporter.",
                "nixName": "exporters.imap-mailstat.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.imap-mailstat.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.imap-mailstat.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.imap-mailstat.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.imap-mailstat.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.imap-mailstat.openFirewall is true.",
                "nixName": "exporters.imap-mailstat.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.imap-mailstat.group",
                "desc": "Group under which the imap-mailstat exporter shall be run.",
                "nixName": "exporters.imap-mailstat.group",
                "type": "string",
                "value": "\"imap-mailstat-exporter\""
            },
            {
                "name": "exporters.imap-mailstat.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.imap-mailstat.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.imap-mailstat.oldestUnseenDate",
                "desc": "Enable metric with timestamp of oldest unseen mail",
                "nixName": "exporters.imap-mailstat.oldestUnseenDate",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.imap-mailstat.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.imap-mailstat.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.imap-mailstat.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.imap-mailstat.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8081"
            },
            {
                "name": "exporters.imap-mailstat.user",
                "desc": "User name under which the imap-mailstat exporter shall be run.",
                "nixName": "exporters.imap-mailstat.user",
                "type": "string",
                "value": "\"imap-mailstat-exporter\""
            },
            {
                "name": "exporters.influxdb.enable",
                "desc": "Whether to enable the prometheus influxdb exporter.",
                "nixName": "exporters.influxdb.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.influxdb.extraFlags",
                "desc": "Extra commandline options to pass to the influxdb exporter.",
                "nixName": "exporters.influxdb.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.influxdb.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.influxdb.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.influxdb.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.influxdb.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.influxdb.openFirewall is true.",
                "nixName": "exporters.influxdb.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.influxdb.group",
                "desc": "Group under which the influxdb exporter shall be run.",
                "nixName": "exporters.influxdb.group",
                "type": "string",
                "value": "\"influxdb-exporter\""
            },
            {
                "name": "exporters.influxdb.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.influxdb.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.influxdb.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.influxdb.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.influxdb.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.influxdb.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9122"
            },
            {
                "name": "exporters.influxdb.sampleExpiry",
                "desc": "How long a sample is valid for",
                "nixName": "exporters.influxdb.sampleExpiry",
                "type": "string",
                "value": "\"5m\""
            },
            {
                "name": "exporters.influxdb.udpBindAddress",
                "desc": "Address on which to listen for udp packets",
                "nixName": "exporters.influxdb.udpBindAddress",
                "type": "string",
                "value": "\":9122\""
            },
            {
                "name": "exporters.influxdb.user",
                "desc": "User name under which the influxdb exporter shall be run.",
                "nixName": "exporters.influxdb.user",
                "type": "string",
                "value": "\"influxdb-exporter\""
            },
            {
                "name": "exporters.ipmi.configFile",
                "desc": "Path to configuration file.",
                "nixName": "exporters.ipmi.configFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.ipmi.enable",
                "desc": "Whether to enable the prometheus ipmi exporter.",
                "nixName": "exporters.ipmi.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.ipmi.extraFlags",
                "desc": "Extra commandline options to pass to the ipmi exporter.",
                "nixName": "exporters.ipmi.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.ipmi.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.ipmi.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.ipmi.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.ipmi.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.ipmi.openFirewall  istrue.",
                "nixName": "exporters.ipmi.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.ipmi.group",
                "desc": "Group under which the ipmi exporter shall be run.",
                "nixName": "exporters.ipmi.group",
                "type": "string",
                "value": "\"ipmi-exporter\""
            },
            {
                "name": "exporters.ipmi.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.ipmi.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.ipmi.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.ipmi.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.ipmi.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.ipmi.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9290"
            },
            {
                "name": "exporters.ipmi.user",
                "desc": "User name under which the ipmi exporter shall be run.",
                "nixName": "exporters.ipmi.user",
                "type": "string",
                "value": "\"ipmi-exporter\""
            },
            {
                "name": "exporters.ipmi.webConfigFile",
                "desc": "Path to configuration file that can enable TLS or authentication.",
                "nixName": "exporters.ipmi.webConfigFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.jitsi.enable",
                "desc": "Whether to enable the prometheus jitsi exporter.",
                "nixName": "exporters.jitsi.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.jitsi.extraFlags",
                "desc": "Extra commandline options to pass to the jitsi exporter.",
                "nixName": "exporters.jitsi.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.jitsi.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.jitsi.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.jitsi.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.jitsi.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.jitsi.openFirewall  istrue.",
                "nixName": "exporters.jitsi.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.jitsi.group",
                "desc": "Group under which the jitsi exporter shall be run.",
                "nixName": "exporters.jitsi.group",
                "type": "string",
                "value": "\"jitsi-exporter\""
            },
            {
                "name": "exporters.jitsi.interval",
                "desc": "How often to scrape new data",
                "nixName": "exporters.jitsi.interval",
                "type": "string",
                "value": "\"30s\""
            },
            {
                "name": "exporters.jitsi.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.jitsi.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.jitsi.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.jitsi.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.jitsi.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.jitsi.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9700"
            },
            {
                "name": "exporters.jitsi.url",
                "desc": "Jitsi Videobridge metrics URL to monitor. This is usually/colibri/stats on port 8080 of the jitsi videobridge host.",
                "nixName": "exporters.jitsi.url",
                "type": "string",
                "value": "\"http://localhost:8080/colibri/stats\""
            },
            {
                "name": "exporters.jitsi.user",
                "desc": "User name under which the jitsi exporter shall be run.",
                "nixName": "exporters.jitsi.user",
                "type": "string",
                "value": "\"jitsi-exporter\""
            },
            {
                "name": "exporters.json.configFile",
                "desc": "Path to configuration file.",
                "nixName": "exporters.json.configFile",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.json.enable",
                "desc": "Whether to enable the prometheus json exporter.",
                "nixName": "exporters.json.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.json.extraFlags",
                "desc": "Extra commandline options to pass to the json exporter.",
                "nixName": "exporters.json.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.json.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.json.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.json.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.json.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.json.openFirewall  istrue.",
                "nixName": "exporters.json.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.json.group",
                "desc": "Group under which the json exporter shall be run.",
                "nixName": "exporters.json.group",
                "type": "string",
                "value": "\"json-exporter\""
            },
            {
                "name": "exporters.json.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.json.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.json.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.json.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.json.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.json.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "7979"
            },
            {
                "name": "exporters.json.user",
                "desc": "User name under which the json exporter shall be run.",
                "nixName": "exporters.json.user",
                "type": "string",
                "value": "\"json-exporter\""
            },
            {
                "name": "exporters.junos-czerwonk.configuration",
                "desc": "JunOS exporter configuration as nix attribute set. Mutually exclusivewith the  configurationFile  option.",
                "nixName": "exporters.junos-czerwonk.configuration",
                "type": "null or (attribute set)",
                "value": "null"
            },
            {
                "name": "exporters.junos-czerwonk.configurationFile",
                "desc": "Specify the JunOS exporter configuration file to use.",
                "nixName": "exporters.junos-czerwonk.configurationFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.junos-czerwonk.enable",
                "desc": "Whether to enable the prometheus junos-czerwonk exporter.",
                "nixName": "exporters.junos-czerwonk.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.junos-czerwonk.environmentFile",
                "desc": "File containing env-vars to be substituted into the exporter\u2019sconfig.",
                "nixName": "exporters.junos-czerwonk.environmentFile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.junos-czerwonk.extraFlags",
                "desc": "Extra commandline options to pass to the junos-czerwonk exporter.",
                "nixName": "exporters.junos-czerwonk.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.junos-czerwonk.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.junos-czerwonk.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.junos-czerwonk.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.junos-czerwonk.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.junos-czerwonk.openFirewall is true.",
                "nixName": "exporters.junos-czerwonk.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.junos-czerwonk.group",
                "desc": "Group under which the junos-czerwonk exporter shall be run.",
                "nixName": "exporters.junos-czerwonk.group",
                "type": "string",
                "value": "\"junos-czerwonk-exporter\""
            },
            {
                "name": "exporters.junos-czerwonk.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.junos-czerwonk.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.junos-czerwonk.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.junos-czerwonk.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.junos-czerwonk.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.junos-czerwonk.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9326"
            },
            {
                "name": "exporters.junos-czerwonk.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.junos-czerwonk.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.junos-czerwonk.user",
                "desc": "User name under which the junos-czerwonk exporter shall be run.",
                "nixName": "exporters.junos-czerwonk.user",
                "type": "string",
                "value": "\"junos-czerwonk-exporter\""
            },
            {
                "name": "exporters.kea.enable",
                "desc": "Whether to enable the prometheus kea exporter.",
                "nixName": "exporters.kea.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.kea.extraFlags",
                "desc": "Extra commandline options to pass to the kea exporter.",
                "nixName": "exporters.kea.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.kea.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.kea.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.kea.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.kea.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.kea.openFirewall  istrue.",
                "nixName": "exporters.kea.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.kea.group",
                "desc": "Group under which the kea exporter shall be run.",
                "nixName": "exporters.kea.group",
                "type": "string",
                "value": "\"kea-exporter\""
            },
            {
                "name": "exporters.kea.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.kea.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.kea.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.kea.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.kea.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.kea.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9547"
            },
            {
                "name": "exporters.kea.targets",
                "desc": "Paths or URLs to the Kea control socket.",
                "nixName": "exporters.kea.targets",
                "type": "list of string",
                "value": null
            },
            {
                "name": "exporters.kea.user",
                "desc": "User name under which the kea exporter shall be run.",
                "nixName": "exporters.kea.user",
                "type": "string",
                "value": "\"kea-exporter\""
            },
            {
                "name": "exporters.keylight.enable",
                "desc": "Whether to enable the prometheus keylight exporter.",
                "nixName": "exporters.keylight.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.keylight.extraFlags",
                "desc": "Extra commandline options to pass to the keylight exporter.",
                "nixName": "exporters.keylight.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.keylight.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.keylight.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.keylight.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.keylight.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.keylight.openFirewall is true.",
                "nixName": "exporters.keylight.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.keylight.group",
                "desc": "Group under which the keylight exporter shall be run.",
                "nixName": "exporters.keylight.group",
                "type": "string",
                "value": "\"keylight-exporter\""
            },
            {
                "name": "exporters.keylight.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.keylight.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.keylight.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.keylight.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.keylight.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.keylight.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9288"
            },
            {
                "name": "exporters.keylight.user",
                "desc": "User name under which the keylight exporter shall be run.",
                "nixName": "exporters.keylight.user",
                "type": "string",
                "value": "\"keylight-exporter\""
            },
            {
                "name": "exporters.knot.enable",
                "desc": "Whether to enable the prometheus knot exporter.",
                "nixName": "exporters.knot.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.knot.extraFlags",
                "desc": "Extra commandline options to pass to the knot exporter.",
                "nixName": "exporters.knot.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.knot.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.knot.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.knot.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.knot.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.knot.openFirewall  istrue.",
                "nixName": "exporters.knot.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.knot.group",
                "desc": "Group under which the knot exporter shall be run.",
                "nixName": "exporters.knot.group",
                "type": "string",
                "value": "\"knot-exporter\""
            },
            {
                "name": "exporters.knot.knotLibraryPath",
                "desc": "Path to the library of  knot-dns .",
                "nixName": "exporters.knot.knotLibraryPath",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.knot.knotSocketPath",
                "desc": "Socket path of  knotd(8) .",
                "nixName": "exporters.knot.knotSocketPath",
                "type": "string",
                "value": "\"/run/knot/knot.sock\""
            },
            {
                "name": "exporters.knot.knotSocketTimeout",
                "desc": "Timeout in seconds.",
                "nixName": "exporters.knot.knotSocketTimeout",
                "type": "positive integer, meaning >0",
                "value": "2000"
            },
            {
                "name": "exporters.knot.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.knot.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.knot.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.knot.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.knot.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.knot.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9433"
            },
            {
                "name": "exporters.knot.user",
                "desc": "User name under which the knot exporter shall be run.",
                "nixName": "exporters.knot.user",
                "type": "string",
                "value": "\"knot-exporter\""
            },
            {
                "name": "exporters.lnd.enable",
                "desc": "Whether to enable the prometheus lnd exporter.",
                "nixName": "exporters.lnd.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.lnd.extraFlags",
                "desc": "Extra commandline options to pass to the lnd exporter.",
                "nixName": "exporters.lnd.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.lnd.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.lnd.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.lnd.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.lnd.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.lnd.openFirewall  istrue.",
                "nixName": "exporters.lnd.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.lnd.group",
                "desc": "Group under which the lnd exporter shall be run.",
                "nixName": "exporters.lnd.group",
                "type": "string",
                "value": "\"lnd-exporter\""
            },
            {
                "name": "exporters.lnd.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.lnd.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.lnd.lndHost",
                "desc": "lnd instance gRPC address:port.",
                "nixName": "exporters.lnd.lndHost",
                "type": "string",
                "value": "\"localhost:10009\""
            },
            {
                "name": "exporters.lnd.lndMacaroonDir",
                "desc": "Path to lnd macaroons.",
                "nixName": "exporters.lnd.lndMacaroonDir",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.lnd.lndTlsPath",
                "desc": "Path to lnd TLS certificate.",
                "nixName": "exporters.lnd.lndTlsPath",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.lnd.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.lnd.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.lnd.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.lnd.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9092"
            },
            {
                "name": "exporters.lnd.user",
                "desc": "User name under which the lnd exporter shall be run.",
                "nixName": "exporters.lnd.user",
                "type": "string",
                "value": "\"lnd-exporter\""
            },
            {
                "name": "exporters.mail.configFile",
                "desc": "Specify the mailexporter configuration file to use.",
                "nixName": "exporters.mail.configFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.mail.configuration",
                "desc": "Specify the mailexporter configuration file to use.",
                "nixName": "exporters.mail.configuration",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "exporters.mail.configuration.disableFileDeletion",
                "desc": "Disables the exporter\u2019s function to delete probing mails.",
                "nixName": "exporters.mail.configuration.disableFileDeletion",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mail.configuration.mailCheckTimeout",
                "desc": "Timeout until mails are considered \u201cdidn\u2019t make it\u201d.",
                "nixName": "exporters.mail.configuration.mailCheckTimeout",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.mail.configuration.monitoringInterval",
                "desc": "Time interval between two probe attempts.",
                "nixName": "exporters.mail.configuration.monitoringInterval",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.mail.configuration.servers",
                "desc": "List of servers that should be probed.   Note:  if your mailserver has  rspamd(8)  configured, it can happen that emailsfrom this exporter are marked as spam.  It\u2019s possible to work around the issue with a config like this:   {  services.rspamd.locals.\"multimap.conf\".text = ''    ALLOWLIST_PROMETHEUS {      filter = \"email:domain:tld\";      type = \"from\";      map = \"${pkgs.writeText \"allowmap\" \"domain.tld\"}\";      score = -100.0;    }  '';}",
                "nixName": "exporters.mail.configuration.servers",
                "type": "list of (submodule)",
                "value": "[ ]"
            },
            {
                "name": "exporters.mail.configuration.servers.*.detectionDir",
                "desc": "Directory in which new mails for the exporter user are placed. Notethat this needs to exist when the exporter starts.",
                "nixName": "exporters.mail.configuration.servers.*.detectionDir",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.mail.configuration.servers.*.from",
                "desc": "Content of \u2018From\u2019 Header for probing mails.",
                "nixName": "exporters.mail.configuration.servers.*.from",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.mail.configuration.servers.*.login",
                "desc": "Username to use for SMTP authentication.",
                "nixName": "exporters.mail.configuration.servers.*.login",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.mail.configuration.servers.*.name",
                "desc": "Value for label \u2018configname\u2019 which will be added to all metrics.",
                "nixName": "exporters.mail.configuration.servers.*.name",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.mail.configuration.servers.*.passphrase",
                "desc": "Password to use for SMTP authentication.",
                "nixName": "exporters.mail.configuration.servers.*.passphrase",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.mail.configuration.servers.*.port",
                "desc": "Port to use for SMTP.",
                "nixName": "exporters.mail.configuration.servers.*.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": null
            },
            {
                "name": "exporters.mail.configuration.servers.*.server",
                "desc": "Hostname of the server that should be probed.",
                "nixName": "exporters.mail.configuration.servers.*.server",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.mail.configuration.servers.*.to",
                "desc": "Content of \u2018To\u2019 Header for probing mails.",
                "nixName": "exporters.mail.configuration.servers.*.to",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.mail.enable",
                "desc": "Whether to enable the prometheus mail exporter.",
                "nixName": "exporters.mail.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mail.environmentFile",
                "desc": "File containing env-vars to be substituted into the exporter\u2019sconfig.",
                "nixName": "exporters.mail.environmentFile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.mail.extraFlags",
                "desc": "Extra commandline options to pass to the mail exporter.",
                "nixName": "exporters.mail.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.mail.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.mail.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.mail.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.mail.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.mail.openFirewall  istrue.",
                "nixName": "exporters.mail.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.mail.group",
                "desc": "Group under which the mail exporter shall be run.",
                "nixName": "exporters.mail.group",
                "type": "string",
                "value": "\"mail-exporter\""
            },
            {
                "name": "exporters.mail.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.mail.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.mail.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.mail.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mail.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.mail.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9225"
            },
            {
                "name": "exporters.mail.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.mail.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.mail.user",
                "desc": "User name under which the mail exporter shall be run.",
                "nixName": "exporters.mail.user",
                "type": "string",
                "value": "\"mail-exporter\""
            },
            {
                "name": "exporters.mikrotik.configFile",
                "desc": "Path to a mikrotik exporter configuration file. Mutually exclusivewith  configuration option.",
                "nixName": "exporters.mikrotik.configFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.mikrotik.configuration",
                "desc": "Mikrotik exporter configuration as nix attribute set. Mutuallyexclusive with  configFile  option.  See  https://github.com/nshttpd/mikrotik-exporter/blob/master/README.md for the description of the configuration file format.",
                "nixName": "exporters.mikrotik.configuration",
                "type": "null or (attribute set)",
                "value": "null"
            },
            {
                "name": "exporters.mikrotik.enable",
                "desc": "Whether to enable the prometheus mikrotik exporter.",
                "nixName": "exporters.mikrotik.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mikrotik.extraFlags",
                "desc": "Extra commandline options to pass to the mikrotik exporter.",
                "nixName": "exporters.mikrotik.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.mikrotik.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.mikrotik.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.mikrotik.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.mikrotik.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.mikrotik.openFirewall is true.",
                "nixName": "exporters.mikrotik.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.mikrotik.group",
                "desc": "Group under which the mikrotik exporter shall be run.",
                "nixName": "exporters.mikrotik.group",
                "type": "string",
                "value": "\"mikrotik-exporter\""
            },
            {
                "name": "exporters.mikrotik.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.mikrotik.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.mikrotik.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.mikrotik.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mikrotik.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.mikrotik.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9436"
            },
            {
                "name": "exporters.mikrotik.user",
                "desc": "User name under which the mikrotik exporter shall be run.",
                "nixName": "exporters.mikrotik.user",
                "type": "string",
                "value": "\"mikrotik-exporter\""
            },
            {
                "name": "exporters.modemmanager.enable",
                "desc": "Whether to enable the prometheus modemmanager exporter.",
                "nixName": "exporters.modemmanager.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.modemmanager.extraFlags",
                "desc": "Extra commandline options to pass to the modemmanager exporter.",
                "nixName": "exporters.modemmanager.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.modemmanager.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.modemmanager.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.modemmanager.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.modemmanager.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.modemmanager.openFirewall is true.",
                "nixName": "exporters.modemmanager.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.modemmanager.group",
                "desc": "Group under which the modemmanager exporter shall be run.",
                "nixName": "exporters.modemmanager.group",
                "type": "string",
                "value": "\"modemmanager-exporter\""
            },
            {
                "name": "exporters.modemmanager.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.modemmanager.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.modemmanager.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.modemmanager.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.modemmanager.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.modemmanager.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9539"
            },
            {
                "name": "exporters.modemmanager.refreshRate",
                "desc": "How frequently ModemManager will refresh the extended signal qualityinformation for each modem. The duration should be specified in seconds(\u201c5s\u201d), minutes (\u201c1m\u201d), or hours (\u201c1h\u201d).",
                "nixName": "exporters.modemmanager.refreshRate",
                "type": "string",
                "value": "\"5s\""
            },
            {
                "name": "exporters.modemmanager.user",
                "desc": "User name under which the modemmanager exporter shall be run.",
                "nixName": "exporters.modemmanager.user",
                "type": "string",
                "value": "\"modemmanager-exporter\""
            },
            {
                "name": "exporters.mongodb.collStats",
                "desc": "List of comma separared databases.collections to get $collStats",
                "nixName": "exporters.mongodb.collStats",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.mongodb.collectAll",
                "desc": "Enable all collectors. Same as specifying all \u2013collector.",
                "nixName": "exporters.mongodb.collectAll",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mongodb.collector",
                "desc": "Enabled collectors",
                "nixName": "exporters.mongodb.collector",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.mongodb.enable",
                "desc": "Whether to enable the prometheus mongodb exporter.",
                "nixName": "exporters.mongodb.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mongodb.extraFlags",
                "desc": "Extra commandline options to pass to the mongodb exporter.",
                "nixName": "exporters.mongodb.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.mongodb.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.mongodb.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.mongodb.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.mongodb.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.mongodb.openFirewall is true.",
                "nixName": "exporters.mongodb.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.mongodb.group",
                "desc": "Group under which the mongodb exporter shall be run.",
                "nixName": "exporters.mongodb.group",
                "type": "string",
                "value": "\"mongodb-exporter\""
            },
            {
                "name": "exporters.mongodb.indexStats",
                "desc": "List of comma separared databases.collections to get $indexStats",
                "nixName": "exporters.mongodb.indexStats",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.mongodb.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.mongodb.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.mongodb.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.mongodb.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mongodb.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.mongodb.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9216"
            },
            {
                "name": "exporters.mongodb.telemetryPath",
                "desc": "Metrics expose path",
                "nixName": "exporters.mongodb.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.mongodb.uri",
                "desc": "MongoDB URI to connect to.",
                "nixName": "exporters.mongodb.uri",
                "type": "string",
                "value": "\"mongodb://localhost:27017/test\""
            },
            {
                "name": "exporters.mongodb.user",
                "desc": "User name under which the mongodb exporter shall be run.",
                "nixName": "exporters.mongodb.user",
                "type": "string",
                "value": "\"mongodb-exporter\""
            },
            {
                "name": "exporters.mysqld.configFile",
                "desc": "Path to the services config file.  See  https://github.com/prometheus/mysqld_exporter#running for more information about the available options.   Please do not store this file in the nix store if you choose toinclude any credentials here, as it would be world-readable.",
                "nixName": "exporters.mysqld.configFile",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.mysqld.enable",
                "desc": "Whether to enable the prometheus mysqld exporter.",
                "nixName": "exporters.mysqld.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mysqld.extraFlags",
                "desc": "Extra commandline options to pass to the mysqld exporter.",
                "nixName": "exporters.mysqld.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.mysqld.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.mysqld.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.mysqld.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.mysqld.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.mysqld.openFirewall is true.",
                "nixName": "exporters.mysqld.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.mysqld.group",
                "desc": "Group under which the mysqld exporter shall be run.",
                "nixName": "exporters.mysqld.group",
                "type": "string",
                "value": "\"mysqld-exporter\""
            },
            {
                "name": "exporters.mysqld.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.mysqld.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.mysqld.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.mysqld.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mysqld.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.mysqld.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9104"
            },
            {
                "name": "exporters.mysqld.runAsLocalSuperUser",
                "desc": "Whether to run the exporter as  services.mysql.user .",
                "nixName": "exporters.mysqld.runAsLocalSuperUser",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.mysqld.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.mysqld.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.mysqld.user",
                "desc": "User name under which the mysqld exporter shall be run.",
                "nixName": "exporters.mysqld.user",
                "type": "string",
                "value": "\"mysqld-exporter\""
            },
            {
                "name": "exporters.nats.enable",
                "desc": "Whether to enable the prometheus nats exporter.",
                "nixName": "exporters.nats.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nats.extraFlags",
                "desc": "Extra commandline options to pass to the nats exporter.",
                "nixName": "exporters.nats.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.nats.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.nats.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.nats.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.nats.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.nats.openFirewall  istrue.",
                "nixName": "exporters.nats.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.nats.group",
                "desc": "Group under which the nats exporter shall be run.",
                "nixName": "exporters.nats.group",
                "type": "string",
                "value": "\"nats-exporter\""
            },
            {
                "name": "exporters.nats.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.nats.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.nats.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.nats.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nats.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.nats.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "7777"
            },
            {
                "name": "exporters.nats.url",
                "desc": "NATS monitor endpoint to query.",
                "nixName": "exporters.nats.url",
                "type": "string",
                "value": "\"http://127.0.0.1:8222\""
            },
            {
                "name": "exporters.nats.user",
                "desc": "User name under which the nats exporter shall be run.",
                "nixName": "exporters.nats.user",
                "type": "string",
                "value": "\"nats-exporter\""
            },
            {
                "name": "exporters.nextcloud.enable",
                "desc": "Whether to enable the prometheus nextcloud exporter.",
                "nixName": "exporters.nextcloud.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nextcloud.extraFlags",
                "desc": "Extra commandline options to pass to the nextcloud exporter.",
                "nixName": "exporters.nextcloud.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.nextcloud.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.nextcloud.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.nextcloud.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.nextcloud.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.nextcloud.openFirewall is true.",
                "nixName": "exporters.nextcloud.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.nextcloud.group",
                "desc": "Group under which the nextcloud exporter shall be run.",
                "nixName": "exporters.nextcloud.group",
                "type": "string",
                "value": "\"nextcloud-exporter\""
            },
            {
                "name": "exporters.nextcloud.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.nextcloud.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.nextcloud.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.nextcloud.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nextcloud.passwordFile",
                "desc": "File containing the password for connecting to Nextcloud. Make surethat this file is readable by the exporter user.",
                "nixName": "exporters.nextcloud.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.nextcloud.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.nextcloud.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9205"
            },
            {
                "name": "exporters.nextcloud.timeout",
                "desc": "Timeout for getting server info document.",
                "nixName": "exporters.nextcloud.timeout",
                "type": "string",
                "value": "\"5s\""
            },
            {
                "name": "exporters.nextcloud.tokenFile",
                "desc": "File containing the token for connecting to Nextcloud. Make sure thatthis file is readable by the exporter user.",
                "nixName": "exporters.nextcloud.tokenFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.nextcloud.url",
                "desc": "URL to the Nextcloud serverinfo page. Adding the path to theserverinfo API is optional, it defaults to /ocs/v2.php/apps/serverinfo/api/v1/info .",
                "nixName": "exporters.nextcloud.url",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.nextcloud.user",
                "desc": "User name under which the nextcloud exporter shall be run.",
                "nixName": "exporters.nextcloud.user",
                "type": "string",
                "value": "\"nextcloud-exporter\""
            },
            {
                "name": "exporters.nextcloud.username",
                "desc": "Username for connecting to Nextcloud. Note that this account needs tohave admin privileges in Nextcloud. Unused when using tokenauthentication.",
                "nixName": "exporters.nextcloud.username",
                "type": "string",
                "value": "\"nextcloud-exporter\""
            },
            {
                "name": "exporters.nginx.constLabels",
                "desc": "A list of constant labels that will be used in every metric.",
                "nixName": "exporters.nginx.constLabels",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.nginx.enable",
                "desc": "Whether to enable the prometheus nginx exporter.",
                "nixName": "exporters.nginx.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nginx.extraFlags",
                "desc": "Extra commandline options to pass to the nginx exporter.",
                "nixName": "exporters.nginx.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.nginx.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.nginx.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.nginx.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.nginx.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.nginx.openFirewall  istrue.",
                "nixName": "exporters.nginx.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.nginx.group",
                "desc": "Group under which the nginx exporter shall be run.",
                "nixName": "exporters.nginx.group",
                "type": "string",
                "value": "\"nginx-exporter\""
            },
            {
                "name": "exporters.nginx.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.nginx.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.nginx.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.nginx.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nginx.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.nginx.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9113"
            },
            {
                "name": "exporters.nginx.scrapeUri",
                "desc": "Address to access the nginx status page. Can be enabled withservices.nginx.statusPage = true.",
                "nixName": "exporters.nginx.scrapeUri",
                "type": "string",
                "value": "\"http://localhost/nginx_status\""
            },
            {
                "name": "exporters.nginx.sslVerify",
                "desc": "Whether to perform certificate verification for https.",
                "nixName": "exporters.nginx.sslVerify",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.nginx.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.nginx.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.nginx.user",
                "desc": "User name under which the nginx exporter shall be run.",
                "nixName": "exporters.nginx.user",
                "type": "string",
                "value": "\"nginx-exporter\""
            },
            {
                "name": "exporters.nginxlog.enable",
                "desc": "Whether to enable the prometheus nginxlog exporter.",
                "nixName": "exporters.nginxlog.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nginxlog.extraFlags",
                "desc": "Extra commandline options to pass to the nginxlog exporter.",
                "nixName": "exporters.nginxlog.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.nginxlog.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.nginxlog.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.nginxlog.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.nginxlog.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.nginxlog.openFirewall is true.",
                "nixName": "exporters.nginxlog.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.nginxlog.group",
                "desc": "Group under which the nginxlog exporter shall be run.",
                "nixName": "exporters.nginxlog.group",
                "type": "string",
                "value": "\"nginxlog-exporter\""
            },
            {
                "name": "exporters.nginxlog.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.nginxlog.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.nginxlog.metricsEndpoint",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.nginxlog.metricsEndpoint",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.nginxlog.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.nginxlog.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nginxlog.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.nginxlog.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9117"
            },
            {
                "name": "exporters.nginxlog.settings",
                "desc": "All settings of nginxlog expressed as an Nix attrset.  Check the official documentation for the corresponding YAML settingsthat can all be used here:  https://github.com/martin-helmich/prometheus-nginxlog-exporter   The  listen  object is already generated by port ,  listenAddress  and metricsEndpoint  and will be merged with the value of settings  before writing it as JSON.",
                "nixName": "exporters.nginxlog.settings",
                "type": "attribute set",
                "value": "{ }"
            },
            {
                "name": "exporters.nginxlog.user",
                "desc": "User name under which the nginxlog exporter shall be run.",
                "nixName": "exporters.nginxlog.user",
                "type": "string",
                "value": "\"nginxlog-exporter\""
            },
            {
                "name": "exporters.node.disabledCollectors",
                "desc": "Collectors to disable which are enabled by default.",
                "nixName": "exporters.node.disabledCollectors",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.node.enable",
                "desc": "Whether to enable the prometheus node exporter.",
                "nixName": "exporters.node.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.node.enabledCollectors",
                "desc": "Collectors to enable. The collectors listed here are enabled inaddition to the default ones.",
                "nixName": "exporters.node.enabledCollectors",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.node.extraFlags",
                "desc": "Extra commandline options to pass to the node exporter.",
                "nixName": "exporters.node.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.node.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.node.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.node.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.node.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.node.openFirewall  istrue.",
                "nixName": "exporters.node.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.node.group",
                "desc": "Group under which the node exporter shall be run.",
                "nixName": "exporters.node.group",
                "type": "string",
                "value": "\"node-exporter\""
            },
            {
                "name": "exporters.node.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.node.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.node.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.node.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.node.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.node.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9100"
            },
            {
                "name": "exporters.node.user",
                "desc": "User name under which the node exporter shall be run.",
                "nixName": "exporters.node.user",
                "type": "string",
                "value": "\"node-exporter\""
            },
            {
                "name": "exporters.nut.enable",
                "desc": "Whether to enable the prometheus nut exporter.",
                "nixName": "exporters.nut.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nut.extraFlags",
                "desc": "Extra commandline options to pass to the nut exporter.",
                "nixName": "exporters.nut.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.nut.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.nut.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.nut.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.nut.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.nut.openFirewall  istrue.",
                "nixName": "exporters.nut.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.nut.group",
                "desc": "Group under which the nut exporter shall be run.",
                "nixName": "exporters.nut.group",
                "type": "string",
                "value": "\"nut-exporter\""
            },
            {
                "name": "exporters.nut.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.nut.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.nut.nutServer",
                "desc": "Hostname or address of the NUT server",
                "nixName": "exporters.nut.nutServer",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "exporters.nut.nutUser",
                "desc": "The user to log in into NUT server. If set, passwordPath should alsobe set.  Default NUT configs usually permit reading variables withoutauthentication.",
                "nixName": "exporters.nut.nutUser",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.nut.nutVariables",
                "desc": "List of NUT variable names to monitor.  If no variables are set, all numeric variables will be exportedautomatically. See the  upstreamdocs  for more information.",
                "nixName": "exporters.nut.nutVariables",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.nut.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.nut.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.nut.passwordPath",
                "desc": "A run-time path to the nutUser password file, which should beprovisioned outside of Nix store.",
                "nixName": "exporters.nut.passwordPath",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.nut.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.nut.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9199"
            },
            {
                "name": "exporters.nut.user",
                "desc": "User name under which the nut exporter shall be run.",
                "nixName": "exporters.nut.user",
                "type": "string",
                "value": "\"nut-exporter\""
            },
            {
                "name": "exporters.openldap.enable",
                "desc": "Whether to enable the prometheus openldap exporter.",
                "nixName": "exporters.openldap.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.openldap.extraFlags",
                "desc": "Extra commandline options to pass to the openldap exporter.",
                "nixName": "exporters.openldap.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.openldap.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.openldap.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.openldap.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.openldap.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.openldap.openFirewall is true.",
                "nixName": "exporters.openldap.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.openldap.group",
                "desc": "Group under which the openldap exporter shall be run.",
                "nixName": "exporters.openldap.group",
                "type": "string",
                "value": "\"openldap-exporter\""
            },
            {
                "name": "exporters.openldap.interval",
                "desc": "Scrape interval of the exporter.",
                "nixName": "exporters.openldap.interval",
                "type": "string",
                "value": "\"30s\""
            },
            {
                "name": "exporters.openldap.ldapAddr",
                "desc": "Address of the  openldap -instance.",
                "nixName": "exporters.openldap.ldapAddr",
                "type": "string",
                "value": "\"localhost:389\""
            },
            {
                "name": "exporters.openldap.ldapCredentialFile",
                "desc": "Environment file to contain the credentials to authenticate against openldap .  The file should look like this:   ---ldapUser: \"cn=monitoring,cn=Monitor\"ldapPass: \"secret\"",
                "nixName": "exporters.openldap.ldapCredentialFile",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.openldap.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.openldap.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.openldap.metricsPath",
                "desc": "URL path where metrics should be exposed.",
                "nixName": "exporters.openldap.metricsPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.openldap.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.openldap.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.openldap.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.openldap.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9330"
            },
            {
                "name": "exporters.openldap.protocol",
                "desc": "Which protocol to use to connect against  openldap .",
                "nixName": "exporters.openldap.protocol",
                "type": "string",
                "value": "\"tcp\""
            },
            {
                "name": "exporters.openldap.user",
                "desc": "User name under which the openldap exporter shall be run.",
                "nixName": "exporters.openldap.user",
                "type": "string",
                "value": "\"openldap-exporter\""
            },
            {
                "name": "exporters.pgbouncer.connectionString",
                "desc": "Connection string for accessing pgBouncer.  NOTE: You MUST keep pgbouncer as database name (special internaldb)!!!  NOTE: Admin user (with password or passwordless) MUST exist in theservices.pgbouncer.authFile if authType other than any is used.  WARNING: this secret is stored in the world-readable Nix store! Use connectionStringFile instead.",
                "nixName": "exporters.pgbouncer.connectionString",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.pgbouncer.connectionStringFile",
                "desc": "File that contains pgBouncer connection string in format:postgres://admin:@localhost:6432/pgbouncer?sslmode=require  NOTE: You MUST keep pgbouncer as database name (special internaldb)!!!  NOTE: Admin user (with password or passwordless) MUST exist in theservices.pgbouncer.authFile if authType other than any is used.   connectionStringFile  takes precedence over  connectionString",
                "nixName": "exporters.pgbouncer.connectionStringFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.pgbouncer.enable",
                "desc": "Whether to enable the prometheus pgbouncer exporter.",
                "nixName": "exporters.pgbouncer.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.pgbouncer.extraFlags",
                "desc": "Extra commandline options when launching Prometheus.",
                "nixName": "exporters.pgbouncer.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.pgbouncer.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.pgbouncer.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.pgbouncer.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.pgbouncer.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.pgbouncer.openFirewall is true.",
                "nixName": "exporters.pgbouncer.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.pgbouncer.group",
                "desc": "Group under which the pgbouncer exporter shall be run.",
                "nixName": "exporters.pgbouncer.group",
                "type": "string",
                "value": "\"pgbouncer-exporter\""
            },
            {
                "name": "exporters.pgbouncer.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.pgbouncer.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.pgbouncer.logFormat",
                "desc": "Output format of log messages. One of: [logfmt, json]",
                "nixName": "exporters.pgbouncer.logFormat",
                "type": "one of \"logfmt\", \"json\"",
                "value": "\"logfmt\""
            },
            {
                "name": "exporters.pgbouncer.logLevel",
                "desc": "Only log messages with the given severity or above.",
                "nixName": "exporters.pgbouncer.logLevel",
                "type": "one of \"debug\", \"info\", \"warn\", \"error\"",
                "value": "\"info\""
            },
            {
                "name": "exporters.pgbouncer.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.pgbouncer.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.pgbouncer.pidFile",
                "desc": "Path to PgBouncer pid file.  If provided, the standard process metrics get exported for thePgBouncer process, prefixed with \u2018pgbouncer_process_\u2026\u2019. Thepgbouncer_process exporter needs to have read access to files owned bythe PgBouncer process. Depends on the availability of /proc.   https://prometheus.io/docs/instrumenting/writing_clientlibs/#process-metrics .",
                "nixName": "exporters.pgbouncer.pidFile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.pgbouncer.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.pgbouncer.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9127"
            },
            {
                "name": "exporters.pgbouncer.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.pgbouncer.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.pgbouncer.user",
                "desc": "User name under which the pgbouncer exporter shall be run.",
                "nixName": "exporters.pgbouncer.user",
                "type": "string",
                "value": "\"pgbouncer-exporter\""
            },
            {
                "name": "exporters.pgbouncer.webConfigFile",
                "desc": "Path to configuration file that can enable TLS or authentication.",
                "nixName": "exporters.pgbouncer.webConfigFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.pgbouncer.webSystemdSocket",
                "desc": "Use systemd socket activation listeners instead of port listeners(Linux only).",
                "nixName": "exporters.pgbouncer.webSystemdSocket",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.php-fpm.enable",
                "desc": "Whether to enable the prometheus php-fpm exporter.",
                "nixName": "exporters.php-fpm.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.php-fpm.environmentFile",
                "desc": "Environment file as defined in   systemd.exec(5)  .  Secrets may be passed to the service without adding them to theworld-readable Nix store, by specifying placeholder variables as theoption value in Nix and setting these variables accordingly in theenvironment file.  Environment variables from this file will be interpolated into theconfig file using envsubst with this syntax: $ENVIRONMENT ${VARIABLE}   For variables to use see  optionsand defaults .  The main use is to set the PHP_FPM_SCRAPE_URI that indicate how toconnect to PHP-FPM process.     # Content of the environment file  PHP_FPM_SCRAPE_URI=\"unix:///tmp/php.sock;/status\"   Note that this file needs to be available on the host on which thisexporter is running.",
                "nixName": "exporters.php-fpm.environmentFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.php-fpm.extraFlags",
                "desc": "Extra commandline options to pass to the php-fpm exporter.",
                "nixName": "exporters.php-fpm.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.php-fpm.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.php-fpm.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.php-fpm.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.php-fpm.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.php-fpm.openFirewall is true.",
                "nixName": "exporters.php-fpm.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.php-fpm.group",
                "desc": "Group under which the php-fpm exporter shall be run.",
                "nixName": "exporters.php-fpm.group",
                "type": "string",
                "value": "\"php-fpm-exporter\""
            },
            {
                "name": "exporters.php-fpm.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.php-fpm.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.php-fpm.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.php-fpm.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.php-fpm.package",
                "desc": "The prometheus-php-fpm-exporter package to use.",
                "nixName": "exporters.php-fpm.package",
                "type": "package",
                "value": "pkgs.prometheus-php-fpm-exporter"
            },
            {
                "name": "exporters.php-fpm.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.php-fpm.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9253"
            },
            {
                "name": "exporters.php-fpm.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.php-fpm.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.php-fpm.user",
                "desc": "User name under which the php-fpm exporter shall be run.",
                "nixName": "exporters.php-fpm.user",
                "type": "string",
                "value": "\"php-fpm-exporter\""
            },
            {
                "name": "exporters.pihole.apiToken",
                "desc": "Pi-Hole API token which can be used instead of a password",
                "nixName": "exporters.pihole.apiToken",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.pihole.enable",
                "desc": "Whether to enable the prometheus pihole exporter.",
                "nixName": "exporters.pihole.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.pihole.extraFlags",
                "desc": "Extra commandline options to pass to the pihole exporter.",
                "nixName": "exporters.pihole.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.pihole.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.pihole.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.pihole.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.pihole.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.pihole.openFirewall is true.",
                "nixName": "exporters.pihole.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.pihole.group",
                "desc": "Group under which the pihole exporter shall be run.",
                "nixName": "exporters.pihole.group",
                "type": "string",
                "value": "\"pihole-exporter\""
            },
            {
                "name": "exporters.pihole.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.pihole.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.pihole.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.pihole.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.pihole.password",
                "desc": "The password to login into Pi-Hole. An api token can be usedinstead.",
                "nixName": "exporters.pihole.password",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.pihole.piholeHostname",
                "desc": "Hostname or address where to find the Pi-Hole webinterface",
                "nixName": "exporters.pihole.piholeHostname",
                "type": "string",
                "value": "\"pihole\""
            },
            {
                "name": "exporters.pihole.piholePort",
                "desc": "The port Pi-Hole webinterface is reachable on",
                "nixName": "exporters.pihole.piholePort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "80"
            },
            {
                "name": "exporters.pihole.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.pihole.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9617"
            },
            {
                "name": "exporters.pihole.protocol",
                "desc": "The protocol which is used to connect to Pi-Hole",
                "nixName": "exporters.pihole.protocol",
                "type": "one of \"http\", \"https\"",
                "value": "\"http\""
            },
            {
                "name": "exporters.pihole.timeout",
                "desc": "Controls the timeout to connect to a Pi-Hole instance",
                "nixName": "exporters.pihole.timeout",
                "type": "string",
                "value": "\"5s\""
            },
            {
                "name": "exporters.pihole.user",
                "desc": "User name under which the pihole exporter shall be run.",
                "nixName": "exporters.pihole.user",
                "type": "string",
                "value": "\"pihole-exporter\""
            },
            {
                "name": "exporters.ping.enable",
                "desc": "Whether to enable the prometheus ping exporter.",
                "nixName": "exporters.ping.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.ping.extraFlags",
                "desc": "Extra commandline options to pass to the ping exporter.",
                "nixName": "exporters.ping.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.ping.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.ping.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.ping.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.ping.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.ping.openFirewall  istrue.",
                "nixName": "exporters.ping.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.ping.group",
                "desc": "Group under which the ping exporter shall be run.",
                "nixName": "exporters.ping.group",
                "type": "string",
                "value": "\"ping-exporter\""
            },
            {
                "name": "exporters.ping.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.ping.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.ping.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.ping.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.ping.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.ping.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9427"
            },
            {
                "name": "exporters.ping.settings",
                "desc": "Configuration for ping_exporter, see  https://github.com/czerwonk/ping_exporter for supported values.",
                "nixName": "exporters.ping.settings",
                "type": "YAML value",
                "value": "{ }"
            },
            {
                "name": "exporters.ping.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.ping.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.ping.user",
                "desc": "User name under which the ping exporter shall be run.",
                "nixName": "exporters.ping.user",
                "type": "string",
                "value": "\"ping-exporter\""
            },
            {
                "name": "exporters.postfix.enable",
                "desc": "Whether to enable the prometheus postfix exporter.",
                "nixName": "exporters.postfix.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.postfix.extraFlags",
                "desc": "Extra commandline options to pass to the postfix exporter.",
                "nixName": "exporters.postfix.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.postfix.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.postfix.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.postfix.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.postfix.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.postfix.openFirewall is true.",
                "nixName": "exporters.postfix.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.postfix.group",
                "desc": "Group under which the postfix exporter shall be run. It should matchthe group that is allowed to access the  showq  socket in the queue/public/  directory. Defaults to services.postfix.setgidGroup  when postfix is enabled.",
                "nixName": "exporters.postfix.group",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.postfix.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.postfix.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.postfix.logfilePath",
                "desc": "Path where Postfix writes log entries. This file will be truncated bythis exporter!",
                "nixName": "exporters.postfix.logfilePath",
                "type": "path",
                "value": "\"/var/log/postfix_exporter_input.log\""
            },
            {
                "name": "exporters.postfix.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.postfix.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.postfix.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.postfix.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9154"
            },
            {
                "name": "exporters.postfix.showqPath",
                "desc": "Path where Postfix places its showq socket.",
                "nixName": "exporters.postfix.showqPath",
                "type": "path",
                "value": "\"/var/lib/postfix/queue/public/showq\""
            },
            {
                "name": "exporters.postfix.systemd.enable",
                "desc": "Whether to enable reading metrics from the systemd journal instead offrom a logfile",
                "nixName": "exporters.postfix.systemd.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.postfix.systemd.journalPath",
                "desc": "Path to the systemd journal.",
                "nixName": "exporters.postfix.systemd.journalPath",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.postfix.systemd.slice",
                "desc": "Name of the postfix systemd slice. This overrides the  systemd.unit .",
                "nixName": "exporters.postfix.systemd.slice",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.postfix.systemd.unit",
                "desc": "Name of the postfix systemd unit.",
                "nixName": "exporters.postfix.systemd.unit",
                "type": "string",
                "value": "\"postfix.service\""
            },
            {
                "name": "exporters.postfix.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.postfix.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.postfix.user",
                "desc": "User name under which the postfix exporter shall be run.",
                "nixName": "exporters.postfix.user",
                "type": "string",
                "value": "\"postfix-exporter\""
            },
            {
                "name": "exporters.postgres.dataSourceName",
                "desc": "Accepts PostgreSQL URI form and key=value form arguments.",
                "nixName": "exporters.postgres.dataSourceName",
                "type": "string",
                "value": "\"user=postgres database=postgres host=/run/postgresql sslmode=disable\""
            },
            {
                "name": "exporters.postgres.enable",
                "desc": "Whether to enable the prometheus postgres exporter.",
                "nixName": "exporters.postgres.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.postgres.environmentFile",
                "desc": "Environment file as defined in   systemd.exec(5)  .  Secrets may be passed to the service without adding them to theworld-readable Nix store, by specifying placeholder variables as theoption value in Nix and setting these variables accordingly in theenvironment file.  Environment variables from this file will be interpolated into theconfig file using envsubst with this syntax: $ENVIRONMENT ${VARIABLE}   The main use is to set the DATA_SOURCE_NAME that contains thepostgres password  note that contents from this file will override dataSourceName if youhave set it from nix.     # Content of the environment file  DATA_SOURCE_NAME=postgresql://username:password@localhost:5432/postgres?sslmode=disable   Note that this file needs to be available on the host on which thisexporter is running.",
                "nixName": "exporters.postgres.environmentFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.postgres.extraFlags",
                "desc": "Extra commandline options to pass to the postgres exporter.",
                "nixName": "exporters.postgres.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.postgres.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.postgres.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.postgres.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.postgres.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.postgres.openFirewall is true.",
                "nixName": "exporters.postgres.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.postgres.group",
                "desc": "Group under which the postgres exporter shall be run.",
                "nixName": "exporters.postgres.group",
                "type": "string",
                "value": "\"postgres-exporter\""
            },
            {
                "name": "exporters.postgres.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.postgres.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.postgres.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.postgres.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.postgres.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.postgres.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9187"
            },
            {
                "name": "exporters.postgres.runAsLocalSuperUser",
                "desc": "Whether to run the exporter as the local \u2018postgres\u2019 super user.",
                "nixName": "exporters.postgres.runAsLocalSuperUser",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.postgres.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.postgres.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.postgres.user",
                "desc": "User name under which the postgres exporter shall be run.",
                "nixName": "exporters.postgres.user",
                "type": "string",
                "value": "\"postgres-exporter\""
            },
            {
                "name": "exporters.process.enable",
                "desc": "Whether to enable the prometheus process exporter.",
                "nixName": "exporters.process.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.process.extraFlags",
                "desc": "Extra commandline options to pass to the process exporter.",
                "nixName": "exporters.process.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.process.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.process.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.process.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.process.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.process.openFirewall is true.",
                "nixName": "exporters.process.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.process.group",
                "desc": "Group under which the process exporter shall be run.",
                "nixName": "exporters.process.group",
                "type": "string",
                "value": "\"process-exporter\""
            },
            {
                "name": "exporters.process.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.process.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.process.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.process.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.process.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.process.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9256"
            },
            {
                "name": "exporters.process.settings.process_names",
                "desc": "All settings expressed as an Nix attrset.  Check the official documentation for the corresponding YAML settingsthat can all be used here:  https://github.com/ncabatoff/process-exporter",
                "nixName": "exporters.process.settings.process_names",
                "type": "list of anything",
                "value": "[ ]"
            },
            {
                "name": "exporters.process.user",
                "desc": "User name under which the process exporter shall be run.",
                "nixName": "exporters.process.user",
                "type": "string",
                "value": "\"process-exporter\""
            },
            {
                "name": "exporters.pve.collectors.cluster",
                "desc": "Collect PVE cluster info",
                "nixName": "exporters.pve.collectors.cluster",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.pve.collectors.config",
                "desc": "Collect PVE onboot status",
                "nixName": "exporters.pve.collectors.config",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.pve.collectors.node",
                "desc": "Collect PVE node info",
                "nixName": "exporters.pve.collectors.node",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.pve.collectors.resources",
                "desc": "Collect PVE resources info",
                "nixName": "exporters.pve.collectors.resources",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.pve.collectors.status",
                "desc": "Collect Node/VM/CT status",
                "nixName": "exporters.pve.collectors.status",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.pve.collectors.version",
                "desc": "Collect PVE version info",
                "nixName": "exporters.pve.collectors.version",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.pve.configFile",
                "desc": "Path to the service\u2019s config file. This path can either be a computedpath in /nix/store or a path in the local filesystem.  The config file should NOT be stored in /nix/store as it will containpasswords and/or keys in plain text.  If both configFile and environmentFile are provided, the configFileoption will be ignored.  Configuration reference:  https://github.com/prometheus-pve/prometheus-pve-exporter/#authentication",
                "nixName": "exporters.pve.configFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.pve.enable",
                "desc": "Whether to enable the prometheus pve exporter.",
                "nixName": "exporters.pve.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.pve.environmentFile",
                "desc": "Path to the service\u2019s environment file. This path can either be acomputed path in /nix/store or a path in the local filesystem.  The environment file should NOT be stored in /nix/store as itcontains passwords and/or keys in plain text.  Environment reference:  https://github.com/prometheus-pve/prometheus-pve-exporter#authentication",
                "nixName": "exporters.pve.environmentFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.pve.extraFlags",
                "desc": "Extra commandline options to pass to the pve exporter.",
                "nixName": "exporters.pve.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.pve.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.pve.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.pve.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.pve.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.pve.openFirewall  istrue.",
                "nixName": "exporters.pve.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.pve.group",
                "desc": "Group under which the pve exporter shall be run.",
                "nixName": "exporters.pve.group",
                "type": "string",
                "value": "\"pve-exporter\""
            },
            {
                "name": "exporters.pve.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.pve.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.pve.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.pve.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.pve.package",
                "desc": "The prometheus-pve-exporter package to use.",
                "nixName": "exporters.pve.package",
                "type": "package",
                "value": "pkgs.prometheus-pve-exporter"
            },
            {
                "name": "exporters.pve.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.pve.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9221"
            },
            {
                "name": "exporters.pve.server.certFile",
                "desc": "Path to a SSL certificate file for the server",
                "nixName": "exporters.pve.server.certFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.pve.server.keyFile",
                "desc": "Path to a SSL private key file for the server",
                "nixName": "exporters.pve.server.keyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.pve.user",
                "desc": "User name under which the pve exporter shall be run.",
                "nixName": "exporters.pve.user",
                "type": "string",
                "value": "\"pve-exporter\""
            },
            {
                "name": "exporters.py-air-control.deviceHostname",
                "desc": "The hostname of the air purification device from which to scrape themetrics.",
                "nixName": "exporters.py-air-control.deviceHostname",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.py-air-control.enable",
                "desc": "Whether to enable the prometheus py-air-control exporter.",
                "nixName": "exporters.py-air-control.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.py-air-control.extraFlags",
                "desc": "Extra commandline options to pass to the py-air-control exporter.",
                "nixName": "exporters.py-air-control.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.py-air-control.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.py-air-control.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.py-air-control.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.py-air-control.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.py-air-control.openFirewall is true.",
                "nixName": "exporters.py-air-control.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.py-air-control.group",
                "desc": "Group under which the py-air-control exporter shall be run.",
                "nixName": "exporters.py-air-control.group",
                "type": "string",
                "value": "\"py-air-control-exporter\""
            },
            {
                "name": "exporters.py-air-control.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.py-air-control.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.py-air-control.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.py-air-control.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.py-air-control.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.py-air-control.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9896"
            },
            {
                "name": "exporters.py-air-control.protocol",
                "desc": "The protocol to use when communicating with the air purificationdevice. Available: [http, coap, plain_coap]",
                "nixName": "exporters.py-air-control.protocol",
                "type": "string",
                "value": "\"http\""
            },
            {
                "name": "exporters.py-air-control.stateDir",
                "desc": "Directory below  /var/lib  to store runtime data. Thisdirectory will be created automatically using systemd\u2019s StateDirectorymechanism.",
                "nixName": "exporters.py-air-control.stateDir",
                "type": "string",
                "value": "\"prometheus-py-air-control-exporter\""
            },
            {
                "name": "exporters.py-air-control.user",
                "desc": "User name under which the py-air-control exporter shall be run.",
                "nixName": "exporters.py-air-control.user",
                "type": "string",
                "value": "\"py-air-control-exporter\""
            },
            {
                "name": "exporters.redis.enable",
                "desc": "Whether to enable the prometheus redis exporter.",
                "nixName": "exporters.redis.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.redis.extraFlags",
                "desc": "Extra commandline options to pass to the redis exporter.",
                "nixName": "exporters.redis.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.redis.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.redis.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.redis.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.redis.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.redis.openFirewall  istrue.",
                "nixName": "exporters.redis.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.redis.group",
                "desc": "Group under which the redis exporter shall be run.",
                "nixName": "exporters.redis.group",
                "type": "string",
                "value": "\"redis-exporter\""
            },
            {
                "name": "exporters.redis.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.redis.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.redis.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.redis.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.redis.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.redis.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9121"
            },
            {
                "name": "exporters.redis.user",
                "desc": "User name under which the redis exporter shall be run.",
                "nixName": "exporters.redis.user",
                "type": "string",
                "value": "\"redis-exporter\""
            },
            {
                "name": "exporters.restic.enable",
                "desc": "Whether to enable the prometheus restic exporter.",
                "nixName": "exporters.restic.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.restic.environmentFile",
                "desc": "File containing the credentials to access the repository, in theformat of an EnvironmentFile as described by systemd.exec(5)",
                "nixName": "exporters.restic.environmentFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.restic.extraFlags",
                "desc": "Extra commandline options to pass to the restic exporter.",
                "nixName": "exporters.restic.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.restic.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.restic.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.restic.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.restic.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.restic.openFirewall is true.",
                "nixName": "exporters.restic.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.restic.group",
                "desc": "Group under which the restic exporter shall be run.",
                "nixName": "exporters.restic.group",
                "type": "string",
                "value": "\"restic-exporter\""
            },
            {
                "name": "exporters.restic.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.restic.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.restic.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.restic.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.restic.passwordFile",
                "desc": "File containing the password to the repository.",
                "nixName": "exporters.restic.passwordFile",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.restic.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.restic.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9753"
            },
            {
                "name": "exporters.restic.rcloneConfig",
                "desc": "Configuration for the rclone remote being used for backup. See theremote\u2019s specific options under rclone\u2019s docs at  https://rclone.org/docs/ . Whenspecifying option names, use the \u201cconfig\u201d name specified in the docs.For example, to set  --b2-hard-delete  for a B2 remote, use hard_delete = true  in the attribute set.   Secrets set in here will be world-readable in the Nix store! Considerusing the  rcloneConfigFile  option instead to specify secretvalues separately. Note that options set here will override those set inthe config file.",
                "nixName": "exporters.restic.rcloneConfig",
                "type": "attribute set of (string or boolean)",
                "value": "{ }"
            },
            {
                "name": "exporters.restic.rcloneConfigFile",
                "desc": "Path to the file containing rclone configuration. This file mustcontain configuration for the remote specified in this backup set andalso must be readable by root.   Options set in  rcloneConfig  will override those set inthis file.",
                "nixName": "exporters.restic.rcloneConfigFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.restic.rcloneOptions",
                "desc": "Options to pass to rclone to control its behavior. See  https://rclone.org/docs/#options for available options. When specifying option names, strip the leading -- . To set a flag such as  --drive-use-trash ,which does not take a value, set the value to the Boolean true .",
                "nixName": "exporters.restic.rcloneOptions",
                "type": "attribute set of (string or boolean)",
                "value": "{ }"
            },
            {
                "name": "exporters.restic.refreshInterval",
                "desc": "Refresh interval for the metrics in seconds. Computing the metrics isan expensive task, keep this value as high as possible.",
                "nixName": "exporters.restic.refreshInterval",
                "type": "unsigned integer, meaning >=0",
                "value": "60"
            },
            {
                "name": "exporters.restic.repository",
                "desc": "URI pointing to the repository to monitor.",
                "nixName": "exporters.restic.repository",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.restic.user",
                "desc": "User name under which the restic exporter shall be run.",
                "nixName": "exporters.restic.user",
                "type": "string",
                "value": "\"restic-exporter\""
            },
            {
                "name": "exporters.rspamd.enable",
                "desc": "Whether to enable the prometheus rspamd exporter.",
                "nixName": "exporters.rspamd.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.rspamd.extraFlags",
                "desc": "Extra commandline options to pass to the rspamd exporter.",
                "nixName": "exporters.rspamd.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.rspamd.extraLabels",
                "desc": "Set of labels added to each metric.",
                "nixName": "exporters.rspamd.extraLabels",
                "type": "attribute set of string",
                "value": "{ host = config.networking.hostName; }"
            },
            {
                "name": "exporters.rspamd.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.rspamd.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.rspamd.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.rspamd.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.rspamd.openFirewall is true.",
                "nixName": "exporters.rspamd.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.rspamd.group",
                "desc": "Group under which the rspamd exporter shall be run.",
                "nixName": "exporters.rspamd.group",
                "type": "string",
                "value": "\"rspamd-exporter\""
            },
            {
                "name": "exporters.rspamd.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.rspamd.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.rspamd.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.rspamd.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.rspamd.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.rspamd.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "7980"
            },
            {
                "name": "exporters.rspamd.user",
                "desc": "User name under which the rspamd exporter shall be run.",
                "nixName": "exporters.rspamd.user",
                "type": "string",
                "value": "\"rspamd-exporter\""
            },
            {
                "name": "exporters.rtl_433.channels",
                "desc": "List of channel matchers to export.",
                "nixName": "exporters.rtl_433.channels",
                "type": "list of (submodule)",
                "value": "[ ]"
            },
            {
                "name": "exporters.rtl_433.channels.*.channel",
                "desc": "Channel to match.",
                "nixName": "exporters.rtl_433.channels.*.channel",
                "type": "signed integer",
                "value": null
            },
            {
                "name": "exporters.rtl_433.channels.*.location",
                "desc": "Location to match.",
                "nixName": "exporters.rtl_433.channels.*.location",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.rtl_433.channels.*.name",
                "desc": "Name to match.",
                "nixName": "exporters.rtl_433.channels.*.name",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.rtl_433.enable",
                "desc": "Whether to enable the prometheus rtl_433 exporter.",
                "nixName": "exporters.rtl_433.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.rtl_433.extraFlags",
                "desc": "Extra commandline options to pass to the rtl_433 exporter.",
                "nixName": "exporters.rtl_433.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.rtl_433.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.rtl_433.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.rtl_433.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.rtl_433.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.rtl_433.openFirewall is true.",
                "nixName": "exporters.rtl_433.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.rtl_433.group",
                "desc": "Group under which the rtl_433 exporter shall be run.",
                "nixName": "exporters.rtl_433.group",
                "type": "string",
                "value": "\"rtl_433-exporter\""
            },
            {
                "name": "exporters.rtl_433.ids",
                "desc": "List of ID matchers to export.",
                "nixName": "exporters.rtl_433.ids",
                "type": "list of (submodule)",
                "value": "[ ]"
            },
            {
                "name": "exporters.rtl_433.ids.*.id",
                "desc": "ID to match.",
                "nixName": "exporters.rtl_433.ids.*.id",
                "type": "signed integer",
                "value": null
            },
            {
                "name": "exporters.rtl_433.ids.*.location",
                "desc": "Location to match.",
                "nixName": "exporters.rtl_433.ids.*.location",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.rtl_433.ids.*.name",
                "desc": "Name to match.",
                "nixName": "exporters.rtl_433.ids.*.name",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.rtl_433.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.rtl_433.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.rtl_433.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.rtl_433.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.rtl_433.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.rtl_433.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9550"
            },
            {
                "name": "exporters.rtl_433.rtl433Flags",
                "desc": "Flags passed verbatim to rtl_433 binary. Having  -C si (the default) is recommended since only Celsius temperatures areparsed.",
                "nixName": "exporters.rtl_433.rtl433Flags",
                "type": "string",
                "value": "\"-C si\""
            },
            {
                "name": "exporters.rtl_433.user",
                "desc": "User name under which the rtl_433 exporter shall be run.",
                "nixName": "exporters.rtl_433.user",
                "type": "string",
                "value": "\"rtl_433-exporter\""
            },
            {
                "name": "exporters.sabnzbd.enable",
                "desc": "Whether to enable the prometheus sabnzbd exporter.",
                "nixName": "exporters.sabnzbd.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.sabnzbd.extraFlags",
                "desc": "Extra commandline options to pass to the sabnzbd exporter.",
                "nixName": "exporters.sabnzbd.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.sabnzbd.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.sabnzbd.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.sabnzbd.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.sabnzbd.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.sabnzbd.openFirewall is true.",
                "nixName": "exporters.sabnzbd.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.sabnzbd.group",
                "desc": "Group under which the sabnzbd exporter shall be run.",
                "nixName": "exporters.sabnzbd.group",
                "type": "string",
                "value": "\"sabnzbd-exporter\""
            },
            {
                "name": "exporters.sabnzbd.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.sabnzbd.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.sabnzbd.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.sabnzbd.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.sabnzbd.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.sabnzbd.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9387"
            },
            {
                "name": "exporters.sabnzbd.servers",
                "desc": "List of sabnzbd servers to connect to.",
                "nixName": "exporters.sabnzbd.servers",
                "type": "list of (submodule)",
                "value": null
            },
            {
                "name": "exporters.sabnzbd.servers.*.apiKeyFile",
                "desc": "The path to a file containing the API key. The file is securelypassed to the service by leveraging systemd credentials. No specialpermissions need to be set on this file.",
                "nixName": "exporters.sabnzbd.servers.*.apiKeyFile",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.sabnzbd.servers.*.baseUrl",
                "desc": "Base URL of the sabnzbd server.",
                "nixName": "exporters.sabnzbd.servers.*.baseUrl",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.sabnzbd.user",
                "desc": "User name under which the sabnzbd exporter shall be run.",
                "nixName": "exporters.sabnzbd.user",
                "type": "string",
                "value": "\"sabnzbd-exporter\""
            },
            {
                "name": "exporters.scaphandre.enable",
                "desc": "Whether to enable the prometheus scaphandre exporter.",
                "nixName": "exporters.scaphandre.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.scaphandre.extraFlags",
                "desc": "Extra commandline options to pass to the scaphandre exporter.",
                "nixName": "exporters.scaphandre.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.scaphandre.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.scaphandre.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.scaphandre.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.scaphandre.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.scaphandre.openFirewall is true.",
                "nixName": "exporters.scaphandre.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.scaphandre.group",
                "desc": "Group under which the scaphandre exporter shall be run.",
                "nixName": "exporters.scaphandre.group",
                "type": "string",
                "value": "\"scaphandre-exporter\""
            },
            {
                "name": "exporters.scaphandre.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.scaphandre.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.scaphandre.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.scaphandre.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.scaphandre.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.scaphandre.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            },
            {
                "name": "exporters.scaphandre.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.scaphandre.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.scaphandre.user",
                "desc": "User name under which the scaphandre exporter shall be run.",
                "nixName": "exporters.scaphandre.user",
                "type": "string",
                "value": "\"scaphandre-exporter\""
            },
            {
                "name": "exporters.script.enable",
                "desc": "Whether to enable the prometheus script exporter.",
                "nixName": "exporters.script.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.script.extraFlags",
                "desc": "Extra commandline options to pass to the script exporter.",
                "nixName": "exporters.script.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.script.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.script.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.script.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.script.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.script.openFirewall is true.",
                "nixName": "exporters.script.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.script.group",
                "desc": "Group under which the script exporter shall be run.",
                "nixName": "exporters.script.group",
                "type": "string",
                "value": "\"script-exporter\""
            },
            {
                "name": "exporters.script.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.script.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.script.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.script.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.script.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.script.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9172"
            },
            {
                "name": "exporters.script.settings.scripts",
                "desc": "All settings expressed as an Nix attrset.  Check the official documentation for the corresponding YAML settingsthat can all be used here:  https://github.com/adhocteam/script_exporter#sample-configuration",
                "nixName": "exporters.script.settings.scripts",
                "type": "list of (submodule)",
                "value": null
            },
            {
                "name": "exporters.script.settings.scripts.*.name",
                "desc": "Name of the script.",
                "nixName": "exporters.script.settings.scripts.*.name",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.script.settings.scripts.*.script",
                "desc": "Shell script to execute when metrics are requested.",
                "nixName": "exporters.script.settings.scripts.*.script",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.script.settings.scripts.*.timeout",
                "desc": "Optional timeout for the script in seconds.",
                "nixName": "exporters.script.settings.scripts.*.timeout",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "exporters.script.user",
                "desc": "User name under which the script exporter shall be run.",
                "nixName": "exporters.script.user",
                "type": "string",
                "value": "\"script-exporter\""
            },
            {
                "name": "exporters.shelly.enable",
                "desc": "Whether to enable the prometheus shelly exporter.",
                "nixName": "exporters.shelly.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.shelly.extraFlags",
                "desc": "Extra commandline options to pass to the shelly exporter.",
                "nixName": "exporters.shelly.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.shelly.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.shelly.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.shelly.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.shelly.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.shelly.openFirewall is true.",
                "nixName": "exporters.shelly.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.shelly.group",
                "desc": "Group under which the shelly exporter shall be run.",
                "nixName": "exporters.shelly.group",
                "type": "string",
                "value": "\"shelly-exporter\""
            },
            {
                "name": "exporters.shelly.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.shelly.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.shelly.metrics-file",
                "desc": "Path to the JSON file with the metric definitions",
                "nixName": "exporters.shelly.metrics-file",
                "type": "path",
                "value": null
            },
            {
                "name": "exporters.shelly.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.shelly.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.shelly.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.shelly.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9784"
            },
            {
                "name": "exporters.shelly.user",
                "desc": "User name under which the shelly exporter shall be run.",
                "nixName": "exporters.shelly.user",
                "type": "string",
                "value": "\"shelly-exporter\""
            },
            {
                "name": "exporters.smartctl.devices",
                "desc": "Paths to the disks that will be monitored. Will autodiscover alldisks if none given.",
                "nixName": "exporters.smartctl.devices",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.smartctl.enable",
                "desc": "Whether to enable the prometheus smartctl exporter.",
                "nixName": "exporters.smartctl.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.smartctl.extraFlags",
                "desc": "Extra commandline options to pass to the smartctl exporter.",
                "nixName": "exporters.smartctl.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.smartctl.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.smartctl.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.smartctl.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.smartctl.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.smartctl.openFirewall is true.",
                "nixName": "exporters.smartctl.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.smartctl.group",
                "desc": "Group under which the smartctl exporter shall be run.",
                "nixName": "exporters.smartctl.group",
                "type": "string",
                "value": "\"smartctl-exporter\""
            },
            {
                "name": "exporters.smartctl.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.smartctl.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.smartctl.maxInterval",
                "desc": "Interval that limits how often a disk can be queried.",
                "nixName": "exporters.smartctl.maxInterval",
                "type": "string",
                "value": "\"60s\""
            },
            {
                "name": "exporters.smartctl.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.smartctl.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.smartctl.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.smartctl.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9633"
            },
            {
                "name": "exporters.smartctl.user",
                "desc": "User name under which the smartctl exporter shall be run.",
                "nixName": "exporters.smartctl.user",
                "type": "string",
                "value": "\"smartctl-exporter\""
            },
            {
                "name": "exporters.smokeping.buckets",
                "desc": "List of buckets to use for the response duration histogram.",
                "nixName": "exporters.smokeping.buckets",
                "type": "strings concatenated with \",\"",
                "value": "\"5e-05,0.0001,0.0002,0.0004,0.0008,0.0016,0.0032,0.0064,0.0128,0.0256,0.0512,0.1024,0.2048,0.4096,0.8192,1.6384,3.2768,6.5536,13.1072,26.2144\""
            },
            {
                "name": "exporters.smokeping.enable",
                "desc": "Whether to enable the prometheus smokeping exporter.",
                "nixName": "exporters.smokeping.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.smokeping.extraFlags",
                "desc": "Extra commandline options to pass to the smokeping exporter.",
                "nixName": "exporters.smokeping.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.smokeping.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.smokeping.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.smokeping.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.smokeping.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.smokeping.openFirewall is true.",
                "nixName": "exporters.smokeping.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.smokeping.group",
                "desc": "Group under which the smokeping exporter shall be run.",
                "nixName": "exporters.smokeping.group",
                "type": "string",
                "value": "\"smokeping-exporter\""
            },
            {
                "name": "exporters.smokeping.hosts",
                "desc": "List of endpoints to probe.",
                "nixName": "exporters.smokeping.hosts",
                "type": "list of string",
                "value": null
            },
            {
                "name": "exporters.smokeping.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.smokeping.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.smokeping.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.smokeping.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.smokeping.pingInterval",
                "desc": "Interval between pings.",
                "nixName": "exporters.smokeping.pingInterval",
                "type": "Go duration (https://golang.org/pkg/time/#ParseDuration)",
                "value": "\"1s\""
            },
            {
                "name": "exporters.smokeping.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.smokeping.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9374"
            },
            {
                "name": "exporters.smokeping.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.smokeping.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.smokeping.user",
                "desc": "User name under which the smokeping exporter shall be run.",
                "nixName": "exporters.smokeping.user",
                "type": "string",
                "value": "\"smokeping-exporter\""
            },
            {
                "name": "exporters.snmp.configuration",
                "desc": "Snmp exporter configuration as nix attribute set. Mutually exclusivewith \u2018configurationPath\u2019 option.",
                "nixName": "exporters.snmp.configuration",
                "type": "null or (attribute set)",
                "value": "null"
            },
            {
                "name": "exporters.snmp.configurationPath",
                "desc": "Path to a snmp exporter configuration file. Mutually exclusive with\u2018configuration\u2019 option.",
                "nixName": "exporters.snmp.configurationPath",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.snmp.enable",
                "desc": "Whether to enable the prometheus snmp exporter.",
                "nixName": "exporters.snmp.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.snmp.enableConfigCheck",
                "desc": "Whether to run a correctness check for the configuration file. Thisdepends on the configuration file residing in the nix-store. Pathspassed as string will be copied to the store.",
                "nixName": "exporters.snmp.enableConfigCheck",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.snmp.extraFlags",
                "desc": "Extra commandline options to pass to the snmp exporter.",
                "nixName": "exporters.snmp.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.snmp.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.snmp.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.snmp.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.snmp.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.snmp.openFirewall  istrue.",
                "nixName": "exporters.snmp.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.snmp.group",
                "desc": "Group under which the snmp exporter shall be run.",
                "nixName": "exporters.snmp.group",
                "type": "string",
                "value": "\"snmp-exporter\""
            },
            {
                "name": "exporters.snmp.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.snmp.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.snmp.logFormat",
                "desc": "Output format of log messages.",
                "nixName": "exporters.snmp.logFormat",
                "type": "one of \"logfmt\", \"json\"",
                "value": "\"logfmt\""
            },
            {
                "name": "exporters.snmp.logLevel",
                "desc": "Only log messages with the given severity or above.",
                "nixName": "exporters.snmp.logLevel",
                "type": "one of \"debug\", \"info\", \"warn\", \"error\"",
                "value": "\"info\""
            },
            {
                "name": "exporters.snmp.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.snmp.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.snmp.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.snmp.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9116"
            },
            {
                "name": "exporters.snmp.user",
                "desc": "User name under which the snmp exporter shall be run.",
                "nixName": "exporters.snmp.user",
                "type": "string",
                "value": "\"snmp-exporter\""
            },
            {
                "name": "exporters.sql.configFile",
                "desc": "Path to configuration file.",
                "nixName": "exporters.sql.configFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "exporters.sql.configuration",
                "desc": "Exporter configuration as nix attribute set. Mutually exclusive with\u2018configFile\u2019 option.",
                "nixName": "exporters.sql.configuration",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "exporters.sql.configuration.jobs",
                "desc": "An attrset of metrics scraping jobs to run.",
                "nixName": "exporters.sql.configuration.jobs",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "exporters.sql.configuration.jobs.<name>.connections",
                "desc": "A list of connection strings of the SQL servers to scrape metricsfrom",
                "nixName": "exporters.sql.configuration.jobs.<name>.connections",
                "type": "list of string",
                "value": null
            },
            {
                "name": "exporters.sql.configuration.jobs.<name>.interval",
                "desc": "How often to run this job, specified in  Go duration format.",
                "nixName": "exporters.sql.configuration.jobs.<name>.interval",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.sql.configuration.jobs.<name>.queries",
                "desc": "SQL queries to run.",
                "nixName": "exporters.sql.configuration.jobs.<name>.queries",
                "type": "attribute set of (submodule)",
                "value": null
            },
            {
                "name": "exporters.sql.configuration.jobs.<name>.queries.<name>.help",
                "desc": "A human-readable description of this metric.",
                "nixName": "exporters.sql.configuration.jobs.<name>.queries.<name>.help",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.sql.configuration.jobs.<name>.queries.<name>.labels",
                "desc": "A set of columns that will be used as Prometheus labels.",
                "nixName": "exporters.sql.configuration.jobs.<name>.queries.<name>.labels",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.sql.configuration.jobs.<name>.queries.<name>.query",
                "desc": "The SQL query to run.",
                "nixName": "exporters.sql.configuration.jobs.<name>.queries.<name>.query",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.sql.configuration.jobs.<name>.queries.<name>.values",
                "desc": "A set of columns that will be used as values of this metric.",
                "nixName": "exporters.sql.configuration.jobs.<name>.queries.<name>.values",
                "type": "list of string",
                "value": null
            },
            {
                "name": "exporters.sql.configuration.jobs.<name>.startupSql",
                "desc": "A list of SQL statements to execute once after making aconnection.",
                "nixName": "exporters.sql.configuration.jobs.<name>.startupSql",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.sql.enable",
                "desc": "Whether to enable the prometheus sql exporter.",
                "nixName": "exporters.sql.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.sql.extraFlags",
                "desc": "Extra commandline options to pass to the sql exporter.",
                "nixName": "exporters.sql.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.sql.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.sql.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.sql.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.sql.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.sql.openFirewall  istrue.",
                "nixName": "exporters.sql.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.sql.group",
                "desc": "Group under which the sql exporter shall be run.",
                "nixName": "exporters.sql.group",
                "type": "string",
                "value": "\"sql-exporter\""
            },
            {
                "name": "exporters.sql.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.sql.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.sql.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.sql.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.sql.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.sql.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9237"
            },
            {
                "name": "exporters.sql.user",
                "desc": "User name under which the sql exporter shall be run.",
                "nixName": "exporters.sql.user",
                "type": "string",
                "value": "\"sql-exporter\""
            },
            {
                "name": "exporters.statsd.enable",
                "desc": "Whether to enable the prometheus statsd exporter.",
                "nixName": "exporters.statsd.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.statsd.extraFlags",
                "desc": "Extra commandline options to pass to the statsd exporter.",
                "nixName": "exporters.statsd.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.statsd.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.statsd.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.statsd.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.statsd.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.statsd.openFirewall is true.",
                "nixName": "exporters.statsd.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.statsd.group",
                "desc": "Group under which the statsd exporter shall be run.",
                "nixName": "exporters.statsd.group",
                "type": "string",
                "value": "\"statsd-exporter\""
            },
            {
                "name": "exporters.statsd.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.statsd.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.statsd.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.statsd.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.statsd.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.statsd.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9102"
            },
            {
                "name": "exporters.statsd.user",
                "desc": "User name under which the statsd exporter shall be run.",
                "nixName": "exporters.statsd.user",
                "type": "string",
                "value": "\"statsd-exporter\""
            },
            {
                "name": "exporters.surfboard.enable",
                "desc": "Whether to enable the prometheus surfboard exporter.",
                "nixName": "exporters.surfboard.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.surfboard.extraFlags",
                "desc": "Extra commandline options to pass to the surfboard exporter.",
                "nixName": "exporters.surfboard.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.surfboard.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.surfboard.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.surfboard.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.surfboard.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.surfboard.openFirewall is true.",
                "nixName": "exporters.surfboard.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.surfboard.group",
                "desc": "Group under which the surfboard exporter shall be run.",
                "nixName": "exporters.surfboard.group",
                "type": "string",
                "value": "\"surfboard-exporter\""
            },
            {
                "name": "exporters.surfboard.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.surfboard.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.surfboard.modemAddress",
                "desc": "The hostname or IP of the cable modem.",
                "nixName": "exporters.surfboard.modemAddress",
                "type": "string",
                "value": "\"192.168.100.1\""
            },
            {
                "name": "exporters.surfboard.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.surfboard.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.surfboard.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.surfboard.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9239"
            },
            {
                "name": "exporters.surfboard.user",
                "desc": "User name under which the surfboard exporter shall be run.",
                "nixName": "exporters.surfboard.user",
                "type": "string",
                "value": "\"surfboard-exporter\""
            },
            {
                "name": "exporters.systemd.enable",
                "desc": "Whether to enable the prometheus systemd exporter.",
                "nixName": "exporters.systemd.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.systemd.extraFlags",
                "desc": "Extra commandline options to pass to the systemd exporter.",
                "nixName": "exporters.systemd.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.systemd.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.systemd.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.systemd.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.systemd.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.systemd.openFirewall is true.",
                "nixName": "exporters.systemd.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.systemd.group",
                "desc": "Group under which the systemd exporter shall be run.",
                "nixName": "exporters.systemd.group",
                "type": "string",
                "value": "\"systemd-exporter\""
            },
            {
                "name": "exporters.systemd.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.systemd.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.systemd.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.systemd.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.systemd.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.systemd.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9558"
            },
            {
                "name": "exporters.systemd.user",
                "desc": "User name under which the systemd exporter shall be run.",
                "nixName": "exporters.systemd.user",
                "type": "string",
                "value": "\"systemd-exporter\""
            },
            {
                "name": "exporters.tor.enable",
                "desc": "Whether to enable the prometheus tor exporter.",
                "nixName": "exporters.tor.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.tor.extraFlags",
                "desc": "Extra commandline options to pass to the tor exporter.",
                "nixName": "exporters.tor.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.tor.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.tor.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.tor.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.tor.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.tor.openFirewall  istrue.",
                "nixName": "exporters.tor.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.tor.group",
                "desc": "Group under which the tor exporter shall be run.",
                "nixName": "exporters.tor.group",
                "type": "string",
                "value": "\"tor-exporter\""
            },
            {
                "name": "exporters.tor.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.tor.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.tor.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.tor.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.tor.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.tor.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9130"
            },
            {
                "name": "exporters.tor.torControlAddress",
                "desc": "Tor control IP address or hostname.",
                "nixName": "exporters.tor.torControlAddress",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "exporters.tor.torControlPort",
                "desc": "Tor control port.",
                "nixName": "exporters.tor.torControlPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9051"
            },
            {
                "name": "exporters.tor.user",
                "desc": "User name under which the tor exporter shall be run.",
                "nixName": "exporters.tor.user",
                "type": "string",
                "value": "\"tor-exporter\""
            },
            {
                "name": "exporters.unbound.enable",
                "desc": "Whether to enable the prometheus unbound exporter.",
                "nixName": "exporters.unbound.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unbound.extraFlags",
                "desc": "Extra commandline options to pass to the unbound exporter.",
                "nixName": "exporters.unbound.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.unbound.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.unbound.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.unbound.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.unbound.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.unbound.openFirewall is true.",
                "nixName": "exporters.unbound.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.unbound.group",
                "desc": "Group under which the unbound exporter shall be run.",
                "nixName": "exporters.unbound.group",
                "type": "string",
                "value": "\"unbound-exporter\""
            },
            {
                "name": "exporters.unbound.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.unbound.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.unbound.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.unbound.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unbound.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.unbound.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9167"
            },
            {
                "name": "exporters.unbound.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.unbound.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.unbound.unbound.ca",
                "desc": "Path to the Unbound server certificate authority",
                "nixName": "exporters.unbound.unbound.ca",
                "type": "null or path",
                "value": "\"/var/lib/unbound/unbound_server.pem\""
            },
            {
                "name": "exporters.unbound.unbound.certificate",
                "desc": "Path to the Unbound control socket certificate",
                "nixName": "exporters.unbound.unbound.certificate",
                "type": "null or path",
                "value": "\"/var/lib/unbound/unbound_control.pem\""
            },
            {
                "name": "exporters.unbound.unbound.host",
                "desc": "Path to the unbound control socket. Supports unix domain sockets, aswell as the TCP interface.",
                "nixName": "exporters.unbound.unbound.host",
                "type": "string",
                "value": "\"tcp://127.0.0.1:8953\""
            },
            {
                "name": "exporters.unbound.unbound.key",
                "desc": "Path to the Unbound control socket key.",
                "nixName": "exporters.unbound.unbound.key",
                "type": "null or path",
                "value": "\"/var/lib/unbound/unbound_control.key\""
            },
            {
                "name": "exporters.unbound.user",
                "desc": "User name under which the unbound exporter shall be run.",
                "nixName": "exporters.unbound.user",
                "type": "string",
                "value": "\"unbound-exporter\""
            },
            {
                "name": "exporters.unifi.enable",
                "desc": "Whether to enable the prometheus unifi exporter.",
                "nixName": "exporters.unifi.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unifi.extraFlags",
                "desc": "Extra commandline options to pass to the unifi exporter.",
                "nixName": "exporters.unifi.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.unifi.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.unifi.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.unifi.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.unifi.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.unifi.openFirewall  istrue.",
                "nixName": "exporters.unifi.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.unifi.group",
                "desc": "Group under which the unifi exporter shall be run.",
                "nixName": "exporters.unifi.group",
                "type": "string",
                "value": "\"unifi-exporter\""
            },
            {
                "name": "exporters.unifi.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.unifi.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.unifi.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.unifi.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unifi.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.unifi.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9130"
            },
            {
                "name": "exporters.unifi.unifiAddress",
                "desc": "URL of the UniFi Controller API.",
                "nixName": "exporters.unifi.unifiAddress",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.unifi.unifiInsecure",
                "desc": "If enabled skip the verification of the TLS certificate of the UniFiController API. Use with caution.",
                "nixName": "exporters.unifi.unifiInsecure",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unifi.unifiPassword",
                "desc": "Password for authentication against UniFi Controller API.",
                "nixName": "exporters.unifi.unifiPassword",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.unifi.unifiTimeout",
                "desc": "Timeout including unit for UniFi Controller API requests.",
                "nixName": "exporters.unifi.unifiTimeout",
                "type": "string",
                "value": "\"5s\""
            },
            {
                "name": "exporters.unifi.unifiUsername",
                "desc": "username for authentication against UniFi Controller API.",
                "nixName": "exporters.unifi.unifiUsername",
                "type": "string",
                "value": null
            },
            {
                "name": "exporters.unifi.user",
                "desc": "User name under which the unifi exporter shall be run.",
                "nixName": "exporters.unifi.user",
                "type": "string",
                "value": "\"unifi-exporter\""
            },
            {
                "name": "exporters.unpoller.controllers",
                "desc": "List of Unifi controllers to poll. Use defaults if empty.",
                "nixName": "exporters.unpoller.controllers",
                "type": "list of (submodule)",
                "value": "[ ]"
            },
            {
                "name": "exporters.unpoller.controllers.*.hash_pii",
                "desc": "Hash, with md5, client names and MAC addresses. This attempts toprotect personally identifiable information.",
                "nixName": "exporters.unpoller.controllers.*.hash_pii",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.controllers.*.pass",
                "desc": "Path of a file containing the password for the unifi service user.This file needs to be readable by the unifi-poller user.",
                "nixName": "exporters.unpoller.controllers.*.pass",
                "type": "path",
                "value": "unpoller-unifi-default.password"
            },
            {
                "name": "exporters.unpoller.controllers.*.save_alarms",
                "desc": "Collect and save data from UniFi alarms to influxdb and Loki.",
                "nixName": "exporters.unpoller.controllers.*.save_alarms",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.controllers.*.save_anomalies",
                "desc": "Collect and save data from UniFi anomalies to influxdb and Loki.",
                "nixName": "exporters.unpoller.controllers.*.save_anomalies",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.controllers.*.save_dpi",
                "desc": "Collect and save data from deep packet inspection. Adds around 150data points and impacts performance.",
                "nixName": "exporters.unpoller.controllers.*.save_dpi",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.controllers.*.save_events",
                "desc": "Collect and save data from UniFi events to influxdb and Loki.",
                "nixName": "exporters.unpoller.controllers.*.save_events",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.controllers.*.save_ids",
                "desc": "Collect and save data from the intrusion detection system to influxdband Loki.",
                "nixName": "exporters.unpoller.controllers.*.save_ids",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.controllers.*.save_sites",
                "desc": "Collect and save site data.",
                "nixName": "exporters.unpoller.controllers.*.save_sites",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.unpoller.controllers.*.sites",
                "desc": "List of site names for which statistics should be exported. Or thestring \u201cdefault\u201d for the default site or the string \u201call\u201d for allsites.",
                "nixName": "exporters.unpoller.controllers.*.sites",
                "type": "one of \"default\", \"all\" or list of string",
                "value": "\"all\""
            },
            {
                "name": "exporters.unpoller.controllers.*.url",
                "desc": "URL of the Unifi controller.",
                "nixName": "exporters.unpoller.controllers.*.url",
                "type": "string",
                "value": "\"https://unifi:8443\""
            },
            {
                "name": "exporters.unpoller.controllers.*.user",
                "desc": "Unifi service user name.",
                "nixName": "exporters.unpoller.controllers.*.user",
                "type": "string",
                "value": "\"unifi\""
            },
            {
                "name": "exporters.unpoller.controllers.*.verify_ssl",
                "desc": "Verify the Unifi controller\u2019s certificate.",
                "nixName": "exporters.unpoller.controllers.*.verify_ssl",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "exporters.unpoller.enable",
                "desc": "Whether to enable the prometheus unpoller exporter.",
                "nixName": "exporters.unpoller.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.extraFlags",
                "desc": "Extra commandline options to pass to the unpoller exporter.",
                "nixName": "exporters.unpoller.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.unpoller.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.unpoller.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.unpoller.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.unpoller.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.unpoller.openFirewall is true.",
                "nixName": "exporters.unpoller.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.unpoller.group",
                "desc": "Group under which the unpoller exporter shall be run.",
                "nixName": "exporters.unpoller.group",
                "type": "string",
                "value": "\"unpoller-exporter\""
            },
            {
                "name": "exporters.unpoller.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.unpoller.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.unpoller.log.debug",
                "desc": "Whether to enable debug logging including line numbers, highresolution timestamps, per-device logs.",
                "nixName": "exporters.unpoller.log.debug",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.log.prometheusErrors",
                "desc": "Whether to enable emitting errors to prometheus.",
                "nixName": "exporters.unpoller.log.prometheusErrors",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.log.quiet",
                "desc": "Whether to enable startup and error logs only.",
                "nixName": "exporters.unpoller.log.quiet",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.loki.interval",
                "desc": "How often the events are polled and pushed to Loki.",
                "nixName": "exporters.unpoller.loki.interval",
                "type": "string",
                "value": "\"2m\""
            },
            {
                "name": "exporters.unpoller.loki.pass",
                "desc": "Path of a file containing the password for Loki. This file needs tobe readable by the unifi-poller user.",
                "nixName": "exporters.unpoller.loki.pass",
                "type": "path",
                "value": "\"unpoller-influxdb-default.password\""
            },
            {
                "name": "exporters.unpoller.loki.tenant_id",
                "desc": "Tenant ID to use in Loki.",
                "nixName": "exporters.unpoller.loki.tenant_id",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.unpoller.loki.timeout",
                "desc": "Should be increased in case of timeout errors.",
                "nixName": "exporters.unpoller.loki.timeout",
                "type": "string",
                "value": "\"10s\""
            },
            {
                "name": "exporters.unpoller.loki.url",
                "desc": "URL of the Loki host.",
                "nixName": "exporters.unpoller.loki.url",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.unpoller.loki.user",
                "desc": "Username for Loki.",
                "nixName": "exporters.unpoller.loki.user",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "exporters.unpoller.loki.verify_ssl",
                "desc": "Verify Loki\u2019s certificate.",
                "nixName": "exporters.unpoller.loki.verify_ssl",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.unpoller.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.unpoller.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.unpoller.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9130"
            },
            {
                "name": "exporters.unpoller.user",
                "desc": "User name under which the unpoller exporter shall be run.",
                "nixName": "exporters.unpoller.user",
                "type": "string",
                "value": "\"unpoller-exporter\""
            },
            {
                "name": "exporters.v2ray.enable",
                "desc": "Whether to enable the prometheus v2ray exporter.",
                "nixName": "exporters.v2ray.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.v2ray.extraFlags",
                "desc": "Extra commandline options to pass to the v2ray exporter.",
                "nixName": "exporters.v2ray.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.v2ray.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.v2ray.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.v2ray.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.v2ray.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.v2ray.openFirewall  istrue.",
                "nixName": "exporters.v2ray.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.v2ray.group",
                "desc": "Group under which the v2ray exporter shall be run.",
                "nixName": "exporters.v2ray.group",
                "type": "string",
                "value": "\"v2ray-exporter\""
            },
            {
                "name": "exporters.v2ray.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.v2ray.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.v2ray.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.v2ray.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.v2ray.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.v2ray.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9299"
            },
            {
                "name": "exporters.v2ray.user",
                "desc": "User name under which the v2ray exporter shall be run.",
                "nixName": "exporters.v2ray.user",
                "type": "string",
                "value": "\"v2ray-exporter\""
            },
            {
                "name": "exporters.v2ray.v2rayEndpoint",
                "desc": "v2ray grpc api endpoint",
                "nixName": "exporters.v2ray.v2rayEndpoint",
                "type": "string",
                "value": "\"127.0.0.1:54321\""
            },
            {
                "name": "exporters.varnish.enable",
                "desc": "Whether to enable the prometheus varnish exporter.",
                "nixName": "exporters.varnish.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.varnish.extraFlags",
                "desc": "Extra commandline options to pass to the varnish exporter.",
                "nixName": "exporters.varnish.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.varnish.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.varnish.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.varnish.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.varnish.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.varnish.openFirewall is true.",
                "nixName": "exporters.varnish.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.varnish.group",
                "desc": "Group under which the varnish exporter shall be run.",
                "nixName": "exporters.varnish.group",
                "type": "string",
                "value": "\"varnish-exporter\""
            },
            {
                "name": "exporters.varnish.healthPath",
                "desc": "Path under which to expose healthcheck. Disabled unlessconfigured.",
                "nixName": "exporters.varnish.healthPath",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.varnish.instance",
                "desc": "varnishstat -n value.",
                "nixName": "exporters.varnish.instance",
                "type": "null or string",
                "value": "config.services.varnish.stateDir"
            },
            {
                "name": "exporters.varnish.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.varnish.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.varnish.noExit",
                "desc": "Do not exit server on Varnish scrape errors.",
                "nixName": "exporters.varnish.noExit",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.varnish.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.varnish.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.varnish.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.varnish.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9131"
            },
            {
                "name": "exporters.varnish.raw",
                "desc": "Enable raw stdout logging without timestamps.",
                "nixName": "exporters.varnish.raw",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.varnish.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.varnish.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.varnish.user",
                "desc": "User name under which the varnish exporter shall be run.",
                "nixName": "exporters.varnish.user",
                "type": "string",
                "value": "\"varnish-exporter\""
            },
            {
                "name": "exporters.varnish.varnishStatPath",
                "desc": "Path to varnishstat.",
                "nixName": "exporters.varnish.varnishStatPath",
                "type": "string",
                "value": "\"varnishstat\""
            },
            {
                "name": "exporters.varnish.verbose",
                "desc": "Enable verbose logging.",
                "nixName": "exporters.varnish.verbose",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.varnish.withGoMetrics",
                "desc": "Export go runtime and http handler metrics.",
                "nixName": "exporters.varnish.withGoMetrics",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.wireguard.enable",
                "desc": "Whether to enable the prometheus wireguard exporter.",
                "nixName": "exporters.wireguard.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.wireguard.extraFlags",
                "desc": "Extra commandline options to pass to the wireguard exporter.",
                "nixName": "exporters.wireguard.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.wireguard.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.wireguard.openFirewall is true. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.wireguard.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.wireguard.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.wireguard.openFirewall is true.",
                "nixName": "exporters.wireguard.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.wireguard.group",
                "desc": "Group under which the wireguard exporter shall be run.",
                "nixName": "exporters.wireguard.group",
                "type": "string",
                "value": "\"wireguard-exporter\""
            },
            {
                "name": "exporters.wireguard.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.wireguard.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.wireguard.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.wireguard.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.wireguard.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.wireguard.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9586"
            },
            {
                "name": "exporters.wireguard.singleSubnetPerField",
                "desc": "By default, all allowed IPs and subnets are comma-separated in the allowed_ips  field. With this option enabled, a single IPand subnet will be listed in fields like  allowed_ip_0 , allowed_ip_1  and so on.",
                "nixName": "exporters.wireguard.singleSubnetPerField",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.wireguard.user",
                "desc": "User name under which the wireguard exporter shall be run.",
                "nixName": "exporters.wireguard.user",
                "type": "string",
                "value": "\"wireguard-exporter\""
            },
            {
                "name": "exporters.wireguard.verbose",
                "desc": "Whether to enable verbose logging mode forprometheus-wireguard-exporter.",
                "nixName": "exporters.wireguard.verbose",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.wireguard.wireguardConfig",
                "desc": "Path to the Wireguard Config to  addthe peer\u2019s name to the stats of a peer .  Please note that  networking.wg-quick  is required forthis feature as  networking.wireguard  uses  wg(8)  to set the peersup.",
                "nixName": "exporters.wireguard.wireguardConfig",
                "type": "null or path or string",
                "value": "null"
            },
            {
                "name": "exporters.wireguard.withRemoteIp",
                "desc": "Whether or not the remote IP of a WireGuard peer should be exposedvia prometheus.",
                "nixName": "exporters.wireguard.withRemoteIp",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.zfs.enable",
                "desc": "Whether to enable the prometheus zfs exporter.",
                "nixName": "exporters.zfs.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.zfs.extraFlags",
                "desc": "Extra commandline options to pass to the zfs exporter.",
                "nixName": "exporters.zfs.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "exporters.zfs.firewallFilter",
                "desc": "Specify a filter for iptables to use when  services.prometheus.exporters.zfs.openFirewall  istrue. It is used as ip46tables -I nixos-fw firewallFilter -j nixos-fw-accept .",
                "nixName": "exporters.zfs.firewallFilter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "exporters.zfs.firewallRules",
                "desc": "Specify rules for nftables to add to the input chain when  services.prometheus.exporters.zfs.openFirewall  istrue.",
                "nixName": "exporters.zfs.firewallRules",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "exporters.zfs.group",
                "desc": "Group under which the zfs exporter shall be run.",
                "nixName": "exporters.zfs.group",
                "type": "string",
                "value": "\"zfs-exporter\""
            },
            {
                "name": "exporters.zfs.listenAddress",
                "desc": "Address to listen on.",
                "nixName": "exporters.zfs.listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "exporters.zfs.openFirewall",
                "desc": "Open port in firewall for incoming connections.",
                "nixName": "exporters.zfs.openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "exporters.zfs.pools",
                "desc": "Name of the pool(s) to collect, repeat for multiple pools (default:all pools).",
                "nixName": "exporters.zfs.pools",
                "type": "null or (list of string)",
                "value": "[ ]"
            },
            {
                "name": "exporters.zfs.port",
                "desc": "Port to listen on.",
                "nixName": "exporters.zfs.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9134"
            },
            {
                "name": "exporters.zfs.telemetryPath",
                "desc": "Path under which to expose metrics.",
                "nixName": "exporters.zfs.telemetryPath",
                "type": "string",
                "value": "\"/metrics\""
            },
            {
                "name": "exporters.zfs.user",
                "desc": "User name under which the zfs exporter shall be run.",
                "nixName": "exporters.zfs.user",
                "type": "string",
                "value": "\"zfs-exporter\""
            },
            {
                "name": "extraFlags",
                "desc": "Extra commandline options when launching Prometheus.",
                "nixName": "extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "globalConfig",
                "desc": "Parameters that are valid in all configuration contexts. They alsoserve as defaults for other configuration sections",
                "nixName": "globalConfig",
                "type": "submodule",
                "value": "{ }"
            },
            {
                "name": "globalConfig.evaluation_interval",
                "desc": "How frequently to evaluate rules by default.  Defaults to  1m  in prometheus when set to null .",
                "nixName": "globalConfig.evaluation_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "globalConfig.external_labels",
                "desc": "The labels to add to any time series or alerts when communicatingwith external systems (federation, remote storage, Alertmanager).",
                "nixName": "globalConfig.external_labels",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "globalConfig.query_log_file",
                "desc": "Path to the file prometheus should write its query log to.",
                "nixName": "globalConfig.query_log_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "globalConfig.scrape_interval",
                "desc": "How frequently to scrape targets by default.  Defaults to  1m  in prometheus when set to null .",
                "nixName": "globalConfig.scrape_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "globalConfig.scrape_timeout",
                "desc": "How long until a scrape request times out.  Defaults to  10s  in prometheus when set to null .",
                "nixName": "globalConfig.scrape_timeout",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "listenAddress",
                "desc": "Address to listen on for the web interface, API, and telemetry.",
                "nixName": "listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "package",
                "desc": "The prometheus package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.prometheus"
            },
            {
                "name": "port",
                "desc": "Port to listen on.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9090"
            },
            {
                "name": "pushgateway.enable",
                "desc": "Whether to enable Prometheus Pushgateway.",
                "nixName": "pushgateway.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "pushgateway.extraFlags",
                "desc": "Extra commandline options when launching the Pushgateway.",
                "nixName": "pushgateway.extraFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "pushgateway.log.format",
                "desc": "Set the log target and format.   null  will default to  logger:stderr .",
                "nixName": "pushgateway.log.format",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "pushgateway.log.level",
                "desc": "Only log messages with the given severity or above.   null  will default to  info .",
                "nixName": "pushgateway.log.level",
                "type": "null or one of \"debug\", \"info\", \"warn\", \"error\", \"fatal\"",
                "value": "null"
            },
            {
                "name": "pushgateway.package",
                "desc": "The prometheus-pushgateway package to use.",
                "nixName": "pushgateway.package",
                "type": "package",
                "value": "pkgs.prometheus-pushgateway"
            },
            {
                "name": "pushgateway.persistMetrics",
                "desc": "Whether to persist metrics to a file.  When enabled metrics will be saved to a file called metrics  in the directory  /var/lib/pushgateway .The directory below  /var/lib  can be set using  services.prometheus.pushgateway.stateDir .",
                "nixName": "pushgateway.persistMetrics",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "pushgateway.persistence.interval",
                "desc": "The minimum interval at which to write out the persistence file.   null  will default to  5m .",
                "nixName": "pushgateway.persistence.interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "pushgateway.stateDir",
                "desc": "Directory below  /var/lib  to store metrics.  This directory will be created automatically using systemd\u2019sStateDirectory mechanism when  services.prometheus.pushgateway.persistMetrics  isenabled.",
                "nixName": "pushgateway.stateDir",
                "type": "string",
                "value": "\"pushgateway\""
            },
            {
                "name": "pushgateway.web.external-url",
                "desc": "The URL under which Pushgateway is externally reachable.",
                "nixName": "pushgateway.web.external-url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "pushgateway.web.listen-address",
                "desc": "Address to listen on for the web interface, API and telemetry.   null  will default to  :9091 .",
                "nixName": "pushgateway.web.listen-address",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "pushgateway.web.route-prefix",
                "desc": "Prefix for the internal routes of web endpoints.  Defaults to the path of  services.prometheus.pushgateway.web.external-url .",
                "nixName": "pushgateway.web.route-prefix",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "pushgateway.web.telemetry-path",
                "desc": "Path under which to expose metrics.   null  will default to  /metrics .",
                "nixName": "pushgateway.web.telemetry-path",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead",
                "desc": "Parameters of the endpoints to query from. See  theofficial documentation  for more information.",
                "nixName": "remoteRead",
                "type": "list of (submodule)",
                "value": "[ ]"
            },
            {
                "name": "remoteRead.*.basic_auth",
                "desc": "Sets the  Authorization  header on every remote readrequest with the configured username and password. password andpassword_file are mutually exclusive.",
                "nixName": "remoteRead.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "remoteRead.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "remoteRead.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "remoteRead.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "remoteRead.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "remoteRead.*.bearer_token",
                "desc": "Sets the  Authorization  header on every remote readrequest with the configured bearer token. It is mutually exclusive with bearer_token_file .",
                "nixName": "remoteRead.*.bearer_token",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.bearer_token_file",
                "desc": "Sets the  Authorization  header on every remote readrequest with the bearer token read from the configured file. It ismutually exclusive with  bearer_token .",
                "nixName": "remoteRead.*.bearer_token_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.headers",
                "desc": "Custom HTTP headers to be sent along with each remote read request.Be aware that headers that are set by Prometheus itself can\u2019t beoverwritten.",
                "nixName": "remoteRead.*.headers",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "remoteRead.*.name",
                "desc": "Name of the remote read config, which if specified must be uniqueamong remote read configs. The name will be used in metrics and loggingin place of a generated value to help users distinguish between remoteread configs.",
                "nixName": "remoteRead.*.name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.proxy_url",
                "desc": "Optional Proxy URL.",
                "nixName": "remoteRead.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.read_recent",
                "desc": "Whether reads should be made for queries for time ranges that thelocal storage should have complete data for.",
                "nixName": "remoteRead.*.read_recent",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "remoteRead.*.remote_timeout",
                "desc": "Timeout for requests to the remote read endpoint.",
                "nixName": "remoteRead.*.remote_timeout",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.required_matchers",
                "desc": "An optional list of equality matchers which have to be present in aselector to query the remote read endpoint.",
                "nixName": "remoteRead.*.required_matchers",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "remoteRead.*.tls_config",
                "desc": "Configures the remote read request\u2019s TLS settings.",
                "nixName": "remoteRead.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "remoteRead.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "remoteRead.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "remoteRead.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "remoteRead.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "remoteRead.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "remoteRead.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "remoteRead.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteRead.*.url",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "remoteRead.*.url",
                "type": "string",
                "value": null
            },
            {
                "name": "remoteWrite",
                "desc": "Parameters of the endpoints to send samples to. See  theofficial documentation  for more information.",
                "nixName": "remoteWrite",
                "type": "list of (submodule)",
                "value": "[ ]"
            },
            {
                "name": "remoteWrite.*.basic_auth",
                "desc": "Sets the  Authorization  header on every remote writerequest with the configured username and password. password andpassword_file are mutually exclusive.",
                "nixName": "remoteWrite.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "remoteWrite.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "remoteWrite.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "remoteWrite.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "remoteWrite.*.bearer_token",
                "desc": "Sets the  Authorization  header on every remote writerequest with the configured bearer token. It is mutually exclusive with bearer_token_file .",
                "nixName": "remoteWrite.*.bearer_token",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.bearer_token_file",
                "desc": "Sets the  Authorization  header on every remote writerequest with the bearer token read from the configured file. It ismutually exclusive with  bearer_token .",
                "nixName": "remoteWrite.*.bearer_token_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.headers",
                "desc": "Custom HTTP headers to be sent along with each remote write request.Be aware that headers that are set by Prometheus itself can\u2019t beoverwritten.",
                "nixName": "remoteWrite.*.headers",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.metadata_config",
                "desc": "Configures the sending of series metadata to remote storage. Metadataconfiguration is subject to change at any point or be removed in futurereleases.",
                "nixName": "remoteWrite.*.metadata_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.metadata_config.send",
                "desc": "Whether metric metadata is sent to remote storage or not.",
                "nixName": "remoteWrite.*.metadata_config.send",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.metadata_config.send_interval",
                "desc": "How frequently metric metadata is sent to remote storage.",
                "nixName": "remoteWrite.*.metadata_config.send_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.name",
                "desc": "Name of the remote write config, which if specified must be uniqueamong remote write configs. The name will be used in metrics and loggingin place of a generated value to help users distinguish between remotewrite configs.",
                "nixName": "remoteWrite.*.name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.proxy_url",
                "desc": "Optional Proxy URL.",
                "nixName": "remoteWrite.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.queue_config",
                "desc": "Configures the queue used to write to remote storage.",
                "nixName": "remoteWrite.*.queue_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.queue_config.batch_send_deadline",
                "desc": "Maximum time a sample will wait in buffer.",
                "nixName": "remoteWrite.*.queue_config.batch_send_deadline",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.queue_config.capacity",
                "desc": "Number of samples to buffer per shard before we block reading of moresamples from the WAL. It is recommended to have enough capacity in eachshard to buffer several requests to keep throughput up while processingoccasional slow remote requests.",
                "nixName": "remoteWrite.*.queue_config.capacity",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.queue_config.max_backoff",
                "desc": "Maximum retry delay.",
                "nixName": "remoteWrite.*.queue_config.max_backoff",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.queue_config.max_samples_per_send",
                "desc": "Maximum number of samples per send.",
                "nixName": "remoteWrite.*.queue_config.max_samples_per_send",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.queue_config.max_shards",
                "desc": "Maximum number of shards, i.e. amount of concurrency.",
                "nixName": "remoteWrite.*.queue_config.max_shards",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.queue_config.min_backoff",
                "desc": "Initial retry delay. Gets doubled for every retry.",
                "nixName": "remoteWrite.*.queue_config.min_backoff",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.queue_config.min_shards",
                "desc": "Minimum number of shards, i.e. amount of concurrency.",
                "nixName": "remoteWrite.*.queue_config.min_shards",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.remote_timeout",
                "desc": "Timeout for requests to the remote write endpoint.",
                "nixName": "remoteWrite.*.remote_timeout",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.tls_config",
                "desc": "Configures the remote write request\u2019s TLS settings.",
                "nixName": "remoteWrite.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "remoteWrite.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "remoteWrite.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "remoteWrite.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "remoteWrite.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "remoteWrite.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.url",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "remoteWrite.*.url",
                "type": "string",
                "value": null
            },
            {
                "name": "remoteWrite.*.write_relabel_configs",
                "desc": "List of remote write relabel configurations.",
                "nixName": "remoteWrite.*.write_relabel_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.write_relabel_configs.*.action",
                "desc": "Action to perform based on regex matching.  Defaults to  replace  in prometheus when set to null .",
                "nixName": "remoteWrite.*.write_relabel_configs.*.action",
                "type": "null or one of \"replace\", \"lowercase\", \"uppercase\", \"keep\", \"drop\", \"hashmod\", \"labelmap\", \"labeldrop\", \"labelkeep\"",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.write_relabel_configs.*.modulus",
                "desc": "Modulus to take of the hash of the source label values.",
                "nixName": "remoteWrite.*.write_relabel_configs.*.modulus",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.write_relabel_configs.*.regex",
                "desc": "Regular expression against which the extracted value is matched.  Defaults to  (.*)  in prometheus when set to null .",
                "nixName": "remoteWrite.*.write_relabel_configs.*.regex",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.write_relabel_configs.*.replacement",
                "desc": "Replacement value against which a regex replace is performed if theregular expression matches.  Defaults to  $1  in prometheus when set to null .",
                "nixName": "remoteWrite.*.write_relabel_configs.*.replacement",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.write_relabel_configs.*.separator",
                "desc": "Separator placed between concatenated source label values.  Defaults to  ;  in prometheus when set to null .",
                "nixName": "remoteWrite.*.write_relabel_configs.*.separator",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.write_relabel_configs.*.source_labels",
                "desc": "The source labels select values from existing labels. Their contentis concatenated using the configured separator and matched against theconfigured regular expression.",
                "nixName": "remoteWrite.*.write_relabel_configs.*.source_labels",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "remoteWrite.*.write_relabel_configs.*.target_label",
                "desc": "Label to which the resulting value is written in a replace action. Itis mandatory for replace actions.",
                "nixName": "remoteWrite.*.write_relabel_configs.*.target_label",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "retentionTime",
                "desc": "How long to retain samples in storage.",
                "nixName": "retentionTime",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "ruleFiles",
                "desc": "Any additional rules files to include in this configuration.",
                "nixName": "ruleFiles",
                "type": "list of path",
                "value": "[ ]"
            },
            {
                "name": "rules",
                "desc": "Alerting and/or Recording rules to evaluate at runtime.",
                "nixName": "rules",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "sachet.address",
                "desc": "The address Sachet will listen to.",
                "nixName": "sachet.address",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "sachet.configuration",
                "desc": "Sachet\u2019s configuration as a nix attribute set.",
                "nixName": "sachet.configuration",
                "type": "null or (attribute set)",
                "value": "null"
            },
            {
                "name": "sachet.enable",
                "desc": "Whether to enable Sachet, an SMS alerting tool for the PrometheusAlertmanager.",
                "nixName": "sachet.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "sachet.port",
                "desc": "The port Sachet will listen to.",
                "nixName": "sachet.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9876"
            },
            {
                "name": "scrapeConfigs",
                "desc": "A list of scrape configurations.",
                "nixName": "scrapeConfigs",
                "type": "list of (submodule)",
                "value": "[ ]"
            },
            {
                "name": "scrapeConfigs.*.authorization",
                "desc": "Sets the  Authorization  header on every scrape requestwith the configured credentials.",
                "nixName": "scrapeConfigs.*.authorization",
                "type": "null or (attribute set)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs",
                "desc": "List of Azure service discovery configurations.",
                "nixName": "scrapeConfigs.*.azure_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.authentication_method",
                "desc": "The authentication method, either OAuth or ManagedIdentity. See  https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview   Defaults to  OAuth  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.authentication_method",
                "type": "null or one of \"OAuth\", \"ManagedIdentity\"",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.client_id",
                "desc": "Optional client ID. Only required with authentication_methodOAuth.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.client_secret",
                "desc": "Optional client secret. Only required with authentication_methodOAuth.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.environment",
                "desc": "The Azure environment.  Defaults to  AzurePublicCloud  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.environment",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.port",
                "desc": "The port to scrape metrics from. If using the public IP address, thismust instead be specified in the relabeling rule.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-read the instance list.  Defaults to  300s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.subscription_id",
                "desc": "The subscription ID.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.subscription_id",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.tenant_id",
                "desc": "Optional tenant ID. Only required with authentication_methodOAuth.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.tenant_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.azure_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.azure_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.basic_auth",
                "desc": "Sets the  Authorization  header on every scrape requestwith the configured username and password. password and password_fileare mutually exclusive.",
                "nixName": "scrapeConfigs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.bearer_token",
                "desc": "Sets the  Authorization  header on every scrape requestwith the configured bearer token. It is mutually exclusive with  bearer_token_file .",
                "nixName": "scrapeConfigs.*.bearer_token",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.bearer_token_file",
                "desc": "Sets the  Authorization  header on every scrape requestwith the bearer token read from the configured file. It is mutuallyexclusive with  bearer_token .",
                "nixName": "scrapeConfigs.*.bearer_token_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.body_size_limit",
                "desc": "An uncompressed response body larger than this many bytes will causethe scrape to fail. 0 means no limit. Example: 100MB. This is anexperimental feature, this behaviour could change or be removed in thefuture.  Defaults to  0  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.body_size_limit",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs",
                "desc": "List of Consul service discovery configurations.",
                "nixName": "scrapeConfigs.*.consul_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.allow_stale",
                "desc": "Allow stale Consul results (see  https://www.consul.io/api/index.html#consistency-modes ).  Will reduce load on Consul.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.allow_stale",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.datacenter",
                "desc": "Consul datacenter",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.datacenter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.node_meta",
                "desc": "Node metadata used to filter nodes for a given service.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.node_meta",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.password",
                "desc": "Consul password",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.refresh_interval",
                "desc": "The time after which the provided names are refreshed.  On large setup it might be a good idea to increase this value becausethe catalog will change all the time.  Defaults to  30s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.scheme",
                "desc": "Consul scheme Defaults to  http  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.scheme",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.server",
                "desc": "Consul server to query.  Defaults to  localhost:8500  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.server",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.services",
                "desc": "A list of services for which targets are retrieved.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.services",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.tag_separator",
                "desc": "The string by which Consul tags are joined into the tag label.  Defaults to  ,  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.tag_separator",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.tags",
                "desc": "An optional list of tags used to filter nodes for a given service.Services must contain all tags in the list.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.tags",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.tls_config",
                "desc": "Configures the Consul request\u2019s TLS settings.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.token",
                "desc": "Consul token",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.token",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.consul_sd_configs.*.username",
                "desc": "Consul username",
                "nixName": "scrapeConfigs.*.consul_sd_configs.*.username",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs",
                "desc": "List of DigitalOcean service discovery configurations.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.port",
                "desc": "The port to scrape metrics from.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.refresh_interval",
                "desc": "The time after which the droplets are refreshed.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.digitalocean_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dns_sd_configs",
                "desc": "List of DNS service discovery configurations.",
                "nixName": "scrapeConfigs.*.dns_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dns_sd_configs.*.names",
                "desc": "A list of DNS SRV record names to be queried.",
                "nixName": "scrapeConfigs.*.dns_sd_configs.*.names",
                "type": "list of string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.dns_sd_configs.*.port",
                "desc": "The port number used if the query type is not SRV.",
                "nixName": "scrapeConfigs.*.dns_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dns_sd_configs.*.refresh_interval",
                "desc": "The time after which the provided names are refreshed.  Defaults to  30s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.dns_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dns_sd_configs.*.type",
                "desc": "The type of DNS query to perform. One of SRV, A, or AAAA.  Defaults to  SRV  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.dns_sd_configs.*.type",
                "type": "null or one of \"SRV\", \"A\", \"AAAA\"",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs",
                "desc": "List of Docker service discovery configurations.",
                "nixName": "scrapeConfigs.*.docker_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.filters",
                "desc": "Optional filters to limit the discovery process to a subset ofavailable resources.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.filters",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.filters.*.name",
                "desc": "Name of the filter. The available filters are listed in the upstreamdocumentation: Services:  https://docs.docker.com/engine/api/v1.40/#operation/ServiceList Tasks:  https://docs.docker.com/engine/api/v1.40/#operation/TaskList Nodes:  https://docs.docker.com/engine/api/v1.40/#operation/NodeList",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.filters.*.name",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.filters.*.values",
                "desc": "Value for the filter.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.filters.*.values",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.host",
                "desc": "Address of the Docker daemon.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.host",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.host_networking_host",
                "desc": "The host to use if the container is in host networking mode.  Defaults to  localhost  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.host_networking_host",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.port",
                "desc": "The port to scrape metrics from, when  role  is nodes, andfor discovered tasks and services that don\u2019t have published ports.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.refresh_interval",
                "desc": "The time after which the containers are refreshed.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.docker_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.docker_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs",
                "desc": "List of Docker Swarm service discovery configurations.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.filters",
                "desc": "Optional filters to limit the discovery process to a subset ofavailable resources.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.filters",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.filters.*.name",
                "desc": "Name of the filter. The available filters are listed in the upstreamdocumentation: Services:  https://docs.docker.com/engine/api/v1.40/#operation/ServiceList Tasks:  https://docs.docker.com/engine/api/v1.40/#operation/TaskList Nodes:  https://docs.docker.com/engine/api/v1.40/#operation/NodeList",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.filters.*.name",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.filters.*.values",
                "desc": "Value for the filter.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.filters.*.values",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.host",
                "desc": "Address of the Docker daemon.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.host",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.port",
                "desc": "The port to scrape metrics from, when  role  is nodes, andfor discovered tasks and services that don\u2019t have published ports.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.refresh_interval",
                "desc": "The time after which the containers are refreshed.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.role",
                "desc": "Role of the targets to retrieve. Must be  services , tasks , or  nodes .",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.role",
                "type": "one of \"services\", \"tasks\", \"nodes\"",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.dockerswarm_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs",
                "desc": "List of EC2 service discovery configurations.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.access_key",
                "desc": "The AWS API key id. If blank, the environment variable AWS_ACCESS_KEY_ID  is used.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.access_key",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.endpoint",
                "desc": "Custom endpoint to be used.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.endpoint",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.filters",
                "desc": "Filters can be used optionally to filter the instance list by othercriteria.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.filters",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.filters.*.name",
                "desc": "See  thislist  for the available filters.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.filters.*.name",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.filters.*.values",
                "desc": "Value of the filter.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.filters.*.values",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.port",
                "desc": "The port to scrape metrics from. If using the public IP address, thismust instead be specified in the relabeling rule.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.profile",
                "desc": "Named AWS profile used to connect to the API.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.profile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-read the instance list.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.region",
                "desc": "The AWS Region. If blank, the region from the instance metadata isused.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.region",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.role_arn",
                "desc": "AWS Role ARN, an alternative to using AWS API keys.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.role_arn",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.ec2_sd_configs.*.secret_key",
                "desc": "The AWS API key secret. If blank, the environment variable AWS_SECRET_ACCESS_KEY  is used.",
                "nixName": "scrapeConfigs.*.ec2_sd_configs.*.secret_key",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs",
                "desc": "List of Eureka service discovery configurations.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.server",
                "desc": "The URL to connect to the Eureka server.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.server",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.eureka_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.file_sd_configs",
                "desc": "List of file service discovery configurations.",
                "nixName": "scrapeConfigs.*.file_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.file_sd_configs.*.files",
                "desc": "Patterns for files from which target groups are extracted. Refer tothe Prometheus documentation for permitted filename patterns andformats.",
                "nixName": "scrapeConfigs.*.file_sd_configs.*.files",
                "type": "list of string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.file_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-read the files.  Defaults to  5m  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.file_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.gce_sd_configs",
                "desc": "List of Google Compute Engine service discovery configurations.  See  therelevant Prometheus configuration docs  for more detail.",
                "nixName": "scrapeConfigs.*.gce_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.gce_sd_configs.*.filter",
                "desc": "Filter can be used optionally to filter the instance list by othercriteria Syntax of this filter string is described here in the filterquery parameter section:  https://cloud.google.com/compute/docs/reference/latest/instances/list .",
                "nixName": "scrapeConfigs.*.gce_sd_configs.*.filter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.gce_sd_configs.*.port",
                "desc": "The port to scrape metrics from. If using the public IP address, thismust instead be specified in the relabeling rule.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.gce_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.gce_sd_configs.*.project",
                "desc": "The GCP Project.",
                "nixName": "scrapeConfigs.*.gce_sd_configs.*.project",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.gce_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-read the cloud instance list.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.gce_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.gce_sd_configs.*.tag_separator",
                "desc": "The tag separator used to separate concatenated GCE instance networktags.  See the GCP documentation on network tags for more information:  https://cloud.google.com/vpc/docs/add-remove-network-tags   Defaults to  ,  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.gce_sd_configs.*.tag_separator",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.gce_sd_configs.*.zone",
                "desc": "The zone of the scrape targets. If you need multiple zones usemultiple gce_sd_configs.",
                "nixName": "scrapeConfigs.*.gce_sd_configs.*.zone",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs",
                "desc": "List of Hetzner service discovery configurations.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.port",
                "desc": "The port to scrape metrics from.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.refresh_interval",
                "desc": "The time after which the servers are refreshed.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.role",
                "desc": "The Hetzner role of entities that should be discovered. One of robot  or  hcloud .",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.role",
                "type": "one of \"robot\", \"hcloud\"",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.hetzner_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.honor_labels",
                "desc": "Controls how Prometheus handles conflicts between labels that arealready present in scraped data and labels that Prometheus would attachserver-side (\u201cjob\u201d and \u201cinstance\u201d labels, manually configured targetlabels, and labels generated by service discovery implementations).  If honor_labels is set to \u201ctrue\u201d, label conflicts are resolved bykeeping label values from the scraped data and ignoring the conflictingserver-side labels.  If honor_labels is set to \u201cfalse\u201d, label conflicts are resolved byrenaming conflicting labels in the scraped data to\u201cexported_<original-label>\u201d (for example \u201cexported_instance\u201d,\u201cexported_job\u201d) and then attaching server-side labels. This is usefulfor use cases such as federation, where all labels specified in thetarget should be preserved.  Defaults to  false  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.honor_labels",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.honor_timestamps",
                "desc": "honor_timestamps controls whether Prometheus respects the timestampspresent in scraped data.  If honor_timestamps is set to  true , the timestamps ofthe metrics exposed by the target will be used.  If honor_timestamps is set to  false , the timestamps ofthe metrics exposed by the target will be ignored.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.honor_timestamps",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs",
                "desc": "List of HTTP service discovery configurations.",
                "nixName": "scrapeConfigs.*.http_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.basic_auth",
                "desc": "Authentication information used to authenticate to the API server.password and password_file are mutually exclusive.",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-query the endpoint.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.tls_config",
                "desc": "Configures the scrape request\u2019s TLS settings.",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.http_sd_configs.*.url",
                "desc": "URL from which the targets are fetched.",
                "nixName": "scrapeConfigs.*.http_sd_configs.*.url",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.job_name",
                "desc": "The job name assigned to scraped metrics by default.",
                "nixName": "scrapeConfigs.*.job_name",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs",
                "desc": "List of Kubernetes service discovery configurations.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.api_server",
                "desc": "The API server addresses. If left empty, Prometheus is assumed to runinside of the cluster and will discover API servers automatically anduse the pod\u2019s CA certificate and bearer token file at/var/run/secrets/kubernetes.io/serviceaccount/.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.api_server",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.kubeconfig_file",
                "desc": "Optional path to a kubeconfig file. Note that api_server andkube_config are mutually exclusive.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.kubeconfig_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.namespaces",
                "desc": "Optional namespace discovery. If omitted, all namespaces areused.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.namespaces",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.namespaces.names",
                "desc": "Namespace name.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.namespaces.names",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.role",
                "desc": "The Kubernetes role of entities that should be discovered. One ofendpoints, service, pod, node, or ingress.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.role",
                "type": "one of \"endpoints\", \"service\", \"pod\", \"node\", \"ingress\"",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.selectors",
                "desc": "Optional label and field selectors to limit the discovery process toa subset of available resources. See  https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/ and  https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ to learn more about the possible filters that can be used. Endpointsrole supports pod, service and endpoints selectors, other roles onlysupport selectors matching the role itself (e.g. node role can onlycontain node selectors).  Note: When making decision about using field/label selector make surethat this is the best approach - it will prevent Prometheus from reusingsingle list/watch for all scrape configs. This might result in a biggerload on the Kubernetes API, because per each selector combination therewill be additional LIST/WATCH. On the other hand, if you just want tomonitor small subset of pods in large cluster it\u2019s recommended to useselectors. Decision, if selectors should be used or not depends on theparticular situation.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.selectors",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.selectors.*.field",
                "desc": "Selector field",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.selectors.*.field",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.selectors.*.label",
                "desc": "Selector label",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.selectors.*.label",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.selectors.*.role",
                "desc": "Selector role",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.selectors.*.role",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.kubernetes_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs",
                "desc": "List of Kuma service discovery configurations.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.fetch_timeout",
                "desc": "The time after which the monitoring assignments are refreshed.  Defaults to  2m  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.fetch_timeout",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.refresh_interval",
                "desc": "The time to wait between polling update requests.  Defaults to  30s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.server",
                "desc": "Address of the Kuma Control Plane\u2019s MADS xDS server.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.server",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.kuma_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.label_limit",
                "desc": "Per-scrape limit on number of labels that will be accepted for asample. If more than this number of labels are present postmetric-relabeling, the entire scrape will be treated as failed. 0 meansno limit.  Defaults to  0  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.label_limit",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.label_name_length_limit",
                "desc": "Per-scrape limit on length of labels name that will be accepted for asample. If a label name is longer than this number postmetric-relabeling, the entire scrape will be treated as failed. 0 meansno limit.  Defaults to  0  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.label_name_length_limit",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.label_value_length_limit",
                "desc": "Per-scrape limit on length of labels value that will be accepted fora sample. If a label value is longer than this number postmetric-relabeling, the entire scrape will be treated as failed. 0 meansno limit.  Defaults to  0  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.label_value_length_limit",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.lightsail_sd_configs",
                "desc": "List of Lightsail service discovery configurations.",
                "nixName": "scrapeConfigs.*.lightsail_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.lightsail_sd_configs.*.access_key",
                "desc": "The AWS API keys. If blank, the environment variable AWS_ACCESS_KEY_ID  is used.",
                "nixName": "scrapeConfigs.*.lightsail_sd_configs.*.access_key",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.lightsail_sd_configs.*.endpoint",
                "desc": "Custom endpoint to be used.",
                "nixName": "scrapeConfigs.*.lightsail_sd_configs.*.endpoint",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.lightsail_sd_configs.*.port",
                "desc": "The port to scrape metrics from. If using the public IP address, thismust instead be specified in the relabeling rule.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.lightsail_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.lightsail_sd_configs.*.profile",
                "desc": "Named AWS profile used to connect to the API.",
                "nixName": "scrapeConfigs.*.lightsail_sd_configs.*.profile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.lightsail_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-read the instance list.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.lightsail_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.lightsail_sd_configs.*.region",
                "desc": "The AWS region. If blank, the region from the instance metadata isused.",
                "nixName": "scrapeConfigs.*.lightsail_sd_configs.*.region",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.lightsail_sd_configs.*.role_arn",
                "desc": "AWS Role ARN, an alternative to using AWS API keys.",
                "nixName": "scrapeConfigs.*.lightsail_sd_configs.*.role_arn",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.lightsail_sd_configs.*.secret_key",
                "desc": "The AWS API keys. If blank, the environment variable AWS_SECRET_ACCESS_KEY  is used.",
                "nixName": "scrapeConfigs.*.lightsail_sd_configs.*.secret_key",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs",
                "desc": "List of Linode service discovery configurations.",
                "nixName": "scrapeConfigs.*.linode_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.port",
                "desc": "The port to scrape metrics from.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.refresh_interval",
                "desc": "The time after which the linode instances are refreshed.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.tag_separator",
                "desc": "The string by which Linode Instance tags are joined into the taglabel.  Defaults to  ,  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.tag_separator",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.linode_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.linode_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs",
                "desc": "List of Marathon service discovery configurations.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.auth_token",
                "desc": "Optional authentication information for token-based authentication: https://docs.mesosphere.com/1.11/security/ent/iam-api/#passing-an-authentication-token It is mutually exclusive with  auth_token_file  and otherauthentication mechanisms.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.auth_token",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.auth_token_file",
                "desc": "Optional authentication information for token-based authentication: https://docs.mesosphere.com/1.11/security/ent/iam-api/#passing-an-authentication-token It is mutually exclusive with  auth_token  and otherauthentication mechanisms.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.auth_token_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.refresh_interval",
                "desc": "Polling interval.  Defaults to  30s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.servers",
                "desc": "List of URLs to be used to contact Marathon servers. You need toprovide at least one server URL.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.servers",
                "type": "list of string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.marathon_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.metric_relabel_configs",
                "desc": "List of metric relabel configurations.",
                "nixName": "scrapeConfigs.*.metric_relabel_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.metric_relabel_configs.*.action",
                "desc": "Action to perform based on regex matching.  Defaults to  replace  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.metric_relabel_configs.*.action",
                "type": "null or one of \"replace\", \"lowercase\", \"uppercase\", \"keep\", \"drop\", \"hashmod\", \"labelmap\", \"labeldrop\", \"labelkeep\"",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.metric_relabel_configs.*.modulus",
                "desc": "Modulus to take of the hash of the source label values.",
                "nixName": "scrapeConfigs.*.metric_relabel_configs.*.modulus",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.metric_relabel_configs.*.regex",
                "desc": "Regular expression against which the extracted value is matched.  Defaults to  (.*)  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.metric_relabel_configs.*.regex",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.metric_relabel_configs.*.replacement",
                "desc": "Replacement value against which a regex replace is performed if theregular expression matches.  Defaults to  $1  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.metric_relabel_configs.*.replacement",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.metric_relabel_configs.*.separator",
                "desc": "Separator placed between concatenated source label values.  Defaults to  ;  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.metric_relabel_configs.*.separator",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.metric_relabel_configs.*.source_labels",
                "desc": "The source labels select values from existing labels. Their contentis concatenated using the configured separator and matched against theconfigured regular expression.",
                "nixName": "scrapeConfigs.*.metric_relabel_configs.*.source_labels",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.metric_relabel_configs.*.target_label",
                "desc": "Label to which the resulting value is written in a replace action. Itis mandatory for replace actions.",
                "nixName": "scrapeConfigs.*.metric_relabel_configs.*.target_label",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.metrics_path",
                "desc": "The HTTP resource path on which to fetch metrics from targets.  Defaults to  /metrics  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.metrics_path",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.nerve_sd_configs",
                "desc": "List of AirBnB\u2019s Nerve service discovery configurations.",
                "nixName": "scrapeConfigs.*.nerve_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.nerve_sd_configs.*.paths",
                "desc": "Paths can point to a single service, or the root of a tree ofservices.",
                "nixName": "scrapeConfigs.*.nerve_sd_configs.*.paths",
                "type": "list of string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.nerve_sd_configs.*.servers",
                "desc": "The Zookeeper servers.",
                "nixName": "scrapeConfigs.*.nerve_sd_configs.*.servers",
                "type": "list of string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.nerve_sd_configs.*.timeout",
                "desc": "Timeout value.  Defaults to  10s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.nerve_sd_configs.*.timeout",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs",
                "desc": "List of OpenStack service discovery configurations.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.all_tenants",
                "desc": "Whether the service discovery should list all instances for allprojects. It is only relevant for the \u2018instance\u2019 role and usuallyrequires admin permissions.  Defaults to  false  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.all_tenants",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.application_credential_id",
                "desc": "The application_credential_id or application_credential_name fieldsare required if using an application credential to authenticate. Someproviders allow you to create an application credential to authenticaterather than a password.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.application_credential_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.application_credential_name",
                "desc": "The application_credential_id or application_credential_name fieldsare required if using an application credential to authenticate. Someproviders allow you to create an application credential to authenticaterather than a password.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.application_credential_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.application_credential_secret",
                "desc": "The application_credential_secret field is required if using anapplication credential to authenticate.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.application_credential_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.availability",
                "desc": "The availability of the endpoint to connect to. Must be one ofpublic, admin or internal.  Defaults to  public  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.availability",
                "type": "null or one of \"public\", \"admin\", \"internal\"",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.domain_id",
                "desc": "At most one of domain_id and domain_name must be provided if usingusername with Identity V3. Otherwise, either are optional.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.domain_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.domain_name",
                "desc": "At most one of domain_id and domain_name must be provided if usingusername with Identity V3. Otherwise, either are optional.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.domain_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.identity_endpoint",
                "desc": "identity_endpoint specifies the HTTP endpoint that is required towork with the Identity API of the appropriate version. While it\u2019sultimately needed by all of the identity services, it will often bepopulated by a provider-level function.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.identity_endpoint",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.password",
                "desc": "password for the Identity V2 and V3 APIs. Consult with yourprovider\u2019s control panel to discover your account\u2019s preferred method ofauthentication.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.port",
                "desc": "The port to scrape metrics from. If using the public IP address, thismust instead be specified in the relabeling rule.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.project_id",
                "desc": "The project_id and project_name fields are optional for the IdentityV2 API. Some providers allow you to specify a project_name instead ofthe project_id. Some require both. Your provider\u2019s authenticationpolicies will determine how these fields influence authentication.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.project_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.project_name",
                "desc": "The project_id and project_name fields are optional for the IdentityV2 API. Some providers allow you to specify a project_name instead ofthe project_id. Some require both. Your provider\u2019s authenticationpolicies will determine how these fields influence authentication.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.project_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-read the instance list.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.region",
                "desc": "The OpenStack Region.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.region",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.role",
                "desc": "The OpenStack role of entities that should be discovered.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.role",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.userid",
                "desc": "username is required if using Identity V2 API. Consult with yourprovider\u2019s control panel to discover your account\u2019s username. InIdentity V3, either userid or a combination of username and domain_id ordomain_name are needed.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.userid",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.openstack_sd_configs.*.username",
                "desc": "username is required if using Identity V2 API. Consult with yourprovider\u2019s control panel to discover your account\u2019s username. InIdentity V3, either userid or a combination of username and domain_id ordomain_name are needed.",
                "nixName": "scrapeConfigs.*.openstack_sd_configs.*.username",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.params",
                "desc": "Optional HTTP URL parameters.",
                "nixName": "scrapeConfigs.*.params",
                "type": "null or (attribute set of list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs",
                "desc": "List of PuppetDB service discovery configurations.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.include_parameters",
                "desc": "Whether to include the parameters as meta labels. Due to thedifferences between parameter types and Prometheus labels, someparameters might not be rendered. The format of the parameters mightalso change in future releases.  Note: Enabling this exposes parameters in the Prometheus UI and API.Make sure that you don\u2019t have secrets exposed as parameters if youenable this.  Defaults to  false  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.include_parameters",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.port",
                "desc": "The port to scrape metrics from.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.query",
                "desc": "Puppet Query Language (PQL) query. Only resources are supported.  https://puppet.com/docs/puppetdb/latest/api/query/v4/pql.html",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.query",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-read the resources list.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.puppetdb_sd_configs.*.url",
                "desc": "The URL of the PuppetDB root query endpoint.",
                "nixName": "scrapeConfigs.*.puppetdb_sd_configs.*.url",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.relabel_configs",
                "desc": "List of relabel configurations.",
                "nixName": "scrapeConfigs.*.relabel_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.relabel_configs.*.action",
                "desc": "Action to perform based on regex matching.  Defaults to  replace  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.relabel_configs.*.action",
                "type": "null or one of \"replace\", \"lowercase\", \"uppercase\", \"keep\", \"drop\", \"hashmod\", \"labelmap\", \"labeldrop\", \"labelkeep\"",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.relabel_configs.*.modulus",
                "desc": "Modulus to take of the hash of the source label values.",
                "nixName": "scrapeConfigs.*.relabel_configs.*.modulus",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.relabel_configs.*.regex",
                "desc": "Regular expression against which the extracted value is matched.  Defaults to  (.*)  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.relabel_configs.*.regex",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.relabel_configs.*.replacement",
                "desc": "Replacement value against which a regex replace is performed if theregular expression matches.  Defaults to  $1  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.relabel_configs.*.replacement",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.relabel_configs.*.separator",
                "desc": "Separator placed between concatenated source label values.  Defaults to  ;  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.relabel_configs.*.separator",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.relabel_configs.*.source_labels",
                "desc": "The source labels select values from existing labels. Their contentis concatenated using the configured separator and matched against theconfigured regular expression.",
                "nixName": "scrapeConfigs.*.relabel_configs.*.source_labels",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.relabel_configs.*.target_label",
                "desc": "Label to which the resulting value is written in a replace action. Itis mandatory for replace actions.",
                "nixName": "scrapeConfigs.*.relabel_configs.*.target_label",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.sample_limit",
                "desc": "Per-scrape limit on number of scraped samples that will be accepted.If more than this number of samples are present after metric relabellingthe entire scrape will be treated as failed. 0 means no limit.  Defaults to  0  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.sample_limit",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs",
                "desc": "List of Scaleway service discovery configurations.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.access_key",
                "desc": "Access key to use.  https://console.scaleway.com/project/credentials",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.access_key",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.api_url",
                "desc": "API URL to use when doing the server listing requests.  Defaults to  https://api.scaleway.com  in prometheus whenset to  null .",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.api_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.name_filter",
                "desc": "Specify a name filter (works as a LIKE) to apply on the serverlisting request.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.name_filter",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.port",
                "desc": "The port to scrape metrics from.  Defaults to  80  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.project_id",
                "desc": "Project ID of the targets.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.project_id",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-read the managed targets list.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.role",
                "desc": "Role of the targets to retrieve. Must be  instance  or baremetal .",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.role",
                "type": "one of \"instance\", \"baremetal\"",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.secret_key",
                "desc": "Secret key to use when listing targets.  https://console.scaleway.com/project/credentials It is mutually exclusive with  secret_key_file .",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.secret_key",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.secret_key_file",
                "desc": "Sets the secret key with the credentials read from the configuredfile. It is mutually exclusive with  secret_key .",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.secret_key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.tags_filter",
                "desc": "Specify a tag filter (a server needs to have all defined tags to belisted) to apply on the server listing request.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.tags_filter",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scaleway_sd_configs.*.zone",
                "desc": "Zone is the availability zone of your targets (e.g. fr-par-1).  Defaults to  fr-par-1  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.scaleway_sd_configs.*.zone",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scheme",
                "desc": "The URL scheme with which to fetch metrics from targets.  Defaults to  http  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.scheme",
                "type": "null or one of \"http\", \"https\"",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scrape_interval",
                "desc": "How frequently to scrape targets from this job. Defaults to theglobally configured default.",
                "nixName": "scrapeConfigs.*.scrape_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.scrape_timeout",
                "desc": "Per-target timeout when scraping this job. Defaults to the globallyconfigured default.",
                "nixName": "scrapeConfigs.*.scrape_timeout",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.serverset_sd_configs",
                "desc": "List of Zookeeper Serverset service discovery configurations.",
                "nixName": "scrapeConfigs.*.serverset_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.serverset_sd_configs.*.paths",
                "desc": "Paths can point to a single service, or the root of a tree ofservices.",
                "nixName": "scrapeConfigs.*.serverset_sd_configs.*.paths",
                "type": "list of string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.serverset_sd_configs.*.servers",
                "desc": "The Zookeeper servers.",
                "nixName": "scrapeConfigs.*.serverset_sd_configs.*.servers",
                "type": "list of string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.serverset_sd_configs.*.timeout",
                "desc": "Timeout value.  Defaults to  10s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.serverset_sd_configs.*.timeout",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.static_configs",
                "desc": "List of labeled target groups for this job.",
                "nixName": "scrapeConfigs.*.static_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.static_configs.*.labels",
                "desc": "Labels assigned to all metrics scraped from the targets.",
                "nixName": "scrapeConfigs.*.static_configs.*.labels",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "scrapeConfigs.*.static_configs.*.targets",
                "desc": "The targets specified by the target group.",
                "nixName": "scrapeConfigs.*.static_configs.*.targets",
                "type": "list of string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.target_limit",
                "desc": "Per-scrape config limit on number of unique targets that will beaccepted. If more than this number of targets are present after targetrelabeling, Prometheus will mark the targets as failed without scrapingthem. 0 means no limit. This is an experimental feature, this behaviourcould change in the future.  Defaults to  0  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.target_limit",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.tls_config",
                "desc": "Configures the scrape request\u2019s TLS settings.",
                "nixName": "scrapeConfigs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs",
                "desc": "List of Triton Serverset service discovery configurations.",
                "nixName": "scrapeConfigs.*.triton_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.account",
                "desc": "The account to use for discovering new targets.",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.account",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.dns_suffix",
                "desc": "The DNS suffix which should be applied to target.",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.dns_suffix",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.endpoint",
                "desc": "The Triton discovery endpoint (e.g. cmon.us-east-3b.triton.zone ). This is often the same valueas dns_suffix.",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.endpoint",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.groups",
                "desc": "A list of groups for which targets are retrieved, only supported whentargeting the  container  role. If omitted all containersowned by the requesting account are scraped.",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.groups",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.port",
                "desc": "The port to use for discovery and metric scraping.  Defaults to  9163  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.refresh_interval",
                "desc": "The interval which should be used for refreshing targets.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.role",
                "desc": "The type of targets to discover, can be set to:   \u201ccontainer\u201d to discover virtual machines (SmartOS zones,lx/KVM/bhyve branded zones) running on Triton  \u201ccn\u201d to discover compute nodes (servers/global zones) making up theTriton infrastructure   Defaults to  container  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.role",
                "type": "null or one of \"container\", \"cn\"",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.triton_sd_configs.*.version",
                "desc": "The Triton discovery API version.  Defaults to  1  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.triton_sd_configs.*.version",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs",
                "desc": "List of Uyuni Serverset service discovery configurations.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs",
                "type": "null or (list of (submodule))",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.authorization",
                "desc": "Optional  Authorization  header configuration.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.authorization",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.authorization.credentials",
                "desc": "Sets the credentials. It is mutually exclusive with credentials_file .",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.authorization.credentials",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.authorization.credentials_file",
                "desc": "Sets the credentials to the credentials read from the configuredfile. It is mutually exclusive with  credentials .",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.authorization.credentials_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.authorization.type",
                "desc": "Sets the authentication type.  Defaults to  Bearer  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.authorization.type",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.basic_auth",
                "desc": "Optional HTTP basic authentication information.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.basic_auth",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.basic_auth.password",
                "desc": "HTTP password",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.basic_auth.password",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.basic_auth.password_file",
                "desc": "HTTP password file",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.basic_auth.password_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.basic_auth.username",
                "desc": "HTTP username",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.basic_auth.username",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.entitlement",
                "desc": "The entitlement string to filter eligible systems.  Defaults to  monitoring_entitled  in prometheus when setto  null .",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.entitlement",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.follow_redirects",
                "desc": "Configure whether HTTP requests follow HTTP 3xx redirects.  Defaults to  true  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.follow_redirects",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2",
                "desc": "Optional OAuth 2.0 configuration. Cannot be used at the same time asbasic_auth or authorization.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.client_id",
                "desc": "OAuth client ID.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.client_id",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.client_secret",
                "desc": "OAuth client secret.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.client_secret",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.client_secret_file",
                "desc": "Read the client secret from a file. It is mutually exclusive with client_secret .",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.client_secret_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.endpoint_params",
                "desc": "Optional parameters to append to the token URL.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.endpoint_params",
                "type": "null or (attribute set of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.scopes",
                "desc": "Scopes for the token request.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.scopes",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.token_url",
                "desc": "The URL to fetch the token from.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.oauth2.token_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.password",
                "desc": "Credentials are used to authenticate the requests to Uyuni API.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.password",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.proxy_url",
                "desc": "Optional proxy URL.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.proxy_url",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.refresh_interval",
                "desc": "Refresh interval to re-read the managed targets list.  Defaults to  60s  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.refresh_interval",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.separator",
                "desc": "The string by which Uyuni group names are joined into the groupslabel  Defaults to  ,  in prometheus when set to null .",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.separator",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.server",
                "desc": "The URL to connect to the Uyuni server.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.server",
                "type": "string",
                "value": null
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config",
                "desc": "TLS configuration.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config",
                "type": "null or (submodule)",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.ca_file",
                "desc": "CA certificate to validate API server certificate with.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.ca_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.cert_file",
                "desc": "Certificate file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.cert_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.insecure_skip_verify",
                "desc": "Disable validation of the server certificate.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.insecure_skip_verify",
                "type": "null or boolean",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.key_file",
                "desc": "Key file for client cert authentication to the server.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.key_file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.server_name",
                "desc": "ServerName extension to indicate the name of the server.  http://tools.ietf.org/html/rfc4366#section-3.1",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.tls_config.server_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "scrapeConfigs.*.uyuni_sd_configs.*.username",
                "desc": "Credentials are used to authenticate the requests to Uyuni API.",
                "nixName": "scrapeConfigs.*.uyuni_sd_configs.*.username",
                "type": "string",
                "value": null
            },
            {
                "name": "stateDir",
                "desc": "Directory below  /var/lib  to store Prometheus metricsdata. This directory will be created automatically using systemd\u2019sStateDirectory mechanism.",
                "nixName": "stateDir",
                "type": "string",
                "value": "\"prometheus2\""
            },
            {
                "name": "webConfigFile",
                "desc": "Specifies which file should be used as web.config.file and be passedon startup. See  https://prometheus.io/docs/prometheus/latest/configuration/https/ for valid options.",
                "nixName": "webConfigFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "webExternalUrl",
                "desc": "The URL under which Prometheus is externally reachable (for example,if Prometheus is served via a reverse proxy).",
                "nixName": "webExternalUrl",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "xmpp-alerts.enable",
                "desc": "Whether to enable XMPP Web hook service for Alertmanager.",
                "nixName": "xmpp-alerts.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "xmpp-alerts.settings",
                "desc": "Configuration for prometheus xmpp-alerts, see  https://github.com/jelmer/prometheus-xmpp-alerts/blob/master/xmpp-alerts.yml.example for supported values.",
                "nixName": "xmpp-alerts.settings",
                "type": "YAML value",
                "value": "{ }"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "iodine",
        "desc": "Tool to tunnel IPv4 data through a DNS server",
        "tags": [
            "Proxy"
        ],
        "website": "http://code.kryo.se/iodine/",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "iodine",
        "options": [
            {
                "name": "clients",
                "desc": "Each attribute of this option defines a systemd service that runsiodine. Many or none may be defined. The name of each service is iodine-\u00abname\u00bb  where \u00abname\u00bb is the name of the correspondingattribute name.",
                "nixName": "clients",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "clients.<name>.extraConfig",
                "desc": "Additional command line parameters",
                "nixName": "clients.<name>.extraConfig",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "clients.<name>.passwordFile",
                "desc": "Path to a file containing the password.",
                "nixName": "clients.<name>.passwordFile",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "clients.<name>.relay",
                "desc": "DNS server to use as an intermediate relay to the iodined server",
                "nixName": "clients.<name>.relay",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "clients.<name>.server",
                "desc": "Hostname of server running iodined",
                "nixName": "clients.<name>.server",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "server.domain",
                "desc": "Domain or subdomain of which nameservers point to us",
                "nixName": "server.domain",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "server.enable",
                "desc": "enable iodined server",
                "nixName": "server.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "server.extraConfig",
                "desc": "Additional command line parameters",
                "nixName": "server.extraConfig",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "server.ip",
                "desc": "The assigned ip address or ip range",
                "nixName": "server.ip",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "server.passwordFile",
                "desc": "File that contains password",
                "nixName": "server.passwordFile",
                "type": "string",
                "value": "\"\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Pomerium",
        "desc": "Authenticating reverse proxy",
        "tags": [
            "Proxy"
        ],
        "website": "https://pomerium.io",
        "logo": "https://pomerium.io/static-img/favicon.svg",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "pomerium",
        "options": [
            {
                "name": "configFile",
                "desc": "Path to Pomerium config YAML. If set, overridesservices.pomerium.settings.",
                "nixName": "configFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable the Pomerium authenticating reverse proxy.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "secretsFile",
                "desc": "Path to file containing secrets for Pomerium, in systemdEnvironmentFile format. See the systemd.exec(5) man page.",
                "nixName": "secretsFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "settings",
                "desc": "The contents of Pomerium\u2019s config.yaml, in Nix expressions.  Specifying configFile will override this in its entirety.  See  the Pomeriumconfiguration reference  for more information about what to puthere.",
                "nixName": "settings",
                "type": "YAML value",
                "value": "{ }"
            },
            {
                "name": "useACMEHost",
                "desc": "If set, use a NixOS-generated ACME certificate with the specifiedname.  Note that this will require you to use a non-HTTP-based challenge, ordisable Pomerium\u2019s in-built HTTP redirect server by settinghttp_redirect_addr to null and use a different HTTP server for servingthe challenge response.  If you\u2019re using an HTTP-based challenge, you should use thePomerium-native autocert option instead.",
                "nixName": "useACMEHost",
                "type": "null or string",
                "value": "null"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Privoxy",
        "desc": "Non-caching web proxy with advanced filtering capabilities",
        "tags": [
            "Proxy"
        ],
        "website": "https://www.privoxy.org/",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "privoxy",
        "options": [
            {
                "name": "certsLifetime",
                "desc": "If  inspectHttps  is enabled, the time generated HTTPScertificates will be stored in a temporary directory for reuse. Once thelifetime has expired the directory will cleared and the certificate willhave to be generated again, on-demand.  Depending on the traffic, you may want to reduce the lifetime tolimit the disk usage, since Privoxy itself never deletes thecertificates.   The format is that of the  tmpfiles.d(5)  Ageparameter.",
                "nixName": "certsLifetime",
                "type": "tmpfiles.d(5) age format",
                "value": "\"10d\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Privoxy, non-caching filtering proxy.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableTor",
                "desc": "Whether to configure Privoxy to use Tor\u2019s faster SOCKS port, suitablefor HTTP.",
                "nixName": "enableTor",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "inspectHttps",
                "desc": "Whether to configure Privoxy to inspect HTTPS requests, meaning allencrypted traffic will be filtered as well. This works by decrypting andre-encrypting the requests using a per-domain generated certificate.  To issue per-domain certificates, Privoxy must be provided with a CAcertificate, using the  ca-cert-file , ca-key-file  settings.   The CA certificate must also be added to the system trust roots,otherwise browsers will reject all Privoxy certificates as invalid. Youcan do so by using the option  security.pki.certificateFiles .",
                "nixName": "inspectHttps",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings",
                "desc": "This option is mapped to the main Privoxy configuration file. Checkout the Privoxy user manual at  https://www.privoxy.org/user-manual/config.html for available settings and documentation.   Repeated settings can be represented by using a list.",
                "nixName": "settings",
                "type": "privoxy configuration type. The format consists of an attribute\nset of settings. Each setting can be either a value (integer, string,\nboolean or path) or a list of such values.\n",
                "value": "{ }"
            },
            {
                "name": "settings.actionsfile",
                "desc": "List of paths to Privoxy action files. These paths may either beabsolute or relative to the privoxy configuration directory.",
                "nixName": "settings.actionsfile",
                "type": "list of string",
                "value": "[\n  \"match-all.action\"\n  \"default.action\"\n]"
            },
            {
                "name": "settings.enable-edit-actions",
                "desc": "Whether the web-based actions file editor may be used.",
                "nixName": "settings.enable-edit-actions",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.filterfile",
                "desc": "List of paths to Privoxy filter files. These paths may either beabsolute or relative to the privoxy configuration directory.",
                "nixName": "settings.filterfile",
                "type": "list of string",
                "value": "[\n  \"default.filter\"\n]"
            },
            {
                "name": "settings.listen-address",
                "desc": "Pair of address:port the proxy server is listening to.",
                "nixName": "settings.listen-address",
                "type": "string",
                "value": "\"127.0.0.1:8118\""
            },
            {
                "name": "userActions",
                "desc": "Actions to be included in a  user.action  file. This willhave a higher priority and can be used to override all otheractions.",
                "nixName": "userActions",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "userFilters",
                "desc": "Filters to be included in a  user.filter  file. This willhave a higher priority and can be used to override all other filtersdefinitions.",
                "nixName": "userFilters",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Squid",
        "desc": "A caching proxy for the Web supporting HTTP, HTTPS, FTP, and more",
        "tags": [
            "Proxy"
        ],
        "website": "http://www.squid-cache.org",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "squid",
        "options": [
            {
                "name": "configText",
                "desc": "Verbatim contents of squid.conf. If null (default), use theautogenerated file from NixOS instead.",
                "nixName": "configText",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to run squid web proxy.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraConfig",
                "desc": "Squid configuration. Contents will be added verbatim to theconfiguration file.",
                "nixName": "extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "package",
                "desc": "The squid package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.squid"
            },
            {
                "name": "proxyAddress",
                "desc": "IP address on which squid will listen.",
                "nixName": "proxyAddress",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "proxyPort",
                "desc": "TCP port on which squid will listen.",
                "nixName": "proxyPort",
                "type": "signed integer",
                "value": "3128"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Tinyproxy",
        "desc": "A light-weight HTTP/HTTPS proxy daemon for POSIX operating systems",
        "tags": [
            "Proxy"
        ],
        "website": "https://tinyproxy.github.io/",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "tinyproxy",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable Tinyproxy daemon.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The tinyproxy package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.tinyproxy"
            },
            {
                "name": "settings",
                "desc": "Configuration for  tinyproxy .",
                "nixName": "settings",
                "type": "attribute set of (atom (null, bool, int, float or string) or a list of them for duplicate keys)",
                "value": "{ }"
            },
            {
                "name": "settings.Anonymous",
                "desc": "If an  Anonymous  keyword is present, then anonymousproxying is enabled. The headers listed with  Anonymous  areallowed through, while all others are denied. If no Anonymous keyword ispresent, then all headers are allowed through. You must include quotesaround the headers.",
                "nixName": "settings.Anonymous",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "settings.Filter",
                "desc": "Tinyproxy supports filtering of web sites based on URLs or domains.This option specifies the location of the file containing the filterrules, one rule per line.",
                "nixName": "settings.Filter",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "settings.Listen",
                "desc": "Specify which address to listen to.",
                "nixName": "settings.Listen",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "settings.Port",
                "desc": "Specify which port to listen to.",
                "nixName": "settings.Port",
                "type": "signed integer",
                "value": "8888"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Guacamole",
        "desc": "Clientless remote desktop gateway",
        "tags": [
            "Remote Access\r"
        ],
        "website": "https://guacamole.apache.org/",
        "logo": "https://guacamole.apache.org/images/logos/guac-classic-logo.svg",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "guacamole-server",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable Apache Guacamole Server (guacd).",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraEnvironment",
                "desc": "Environment variables to pass to guacd.",
                "nixName": "extraEnvironment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "host",
                "desc": "The host name or IP address the server should listen to.",
                "nixName": "host",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "logbackXml",
                "desc": "Configuration file that correspond to  logback.xml .",
                "nixName": "logbackXml",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "package",
                "desc": "The guacamole-server package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.guacamole-server"
            },
            {
                "name": "port",
                "desc": "The port the guacd server should listen to.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "4822"
            },
            {
                "name": "userMappingXml",
                "desc": "Configuration file that correspond to user-mapping.xml .",
                "nixName": "userMappingXml",
                "type": "null or path",
                "value": "null"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "MeshCentral",
        "desc": "Computer management web app",
        "tags": [
            "Remote Access\r"
        ],
        "website": "https://meshcentral.com/",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "meshcentral",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable MeshCentral computer management server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The meshcentral package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.meshcentral"
            },
            {
                "name": "settings",
                "desc": "Settings for MeshCentral. Refer to upstream documentation fordetails:    JSONSchema definition    simplesample configuration    complexsample configuration    Old homepagewith documentation link",
                "nixName": "settings",
                "type": "JSON value",
                "value": null
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "ShellHub",
        "desc": "Enables easy access any Linux device behind firewall and NAT",
        "tags": [
            "Remote Access\r"
        ],
        "website": "https://shellhub.io/",
        "logo": "https://shellhub.io/favicon-32x32.png?v=b7691a4d022678a921902ece55ea2058",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "shellhub-agent",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable ShellHub Agent daemon.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "keepAliveInterval",
                "desc": "Determine the interval to send the keep alive message to the server.This has a direct impact of the bandwidth used by the device.",
                "nixName": "keepAliveInterval",
                "type": "signed integer",
                "value": "30"
            },
            {
                "name": "package",
                "desc": "The shellhub-agent package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.shellhub-agent"
            },
            {
                "name": "preferredHostname",
                "desc": "Set the device preferred hostname. This provides a hint to the serverto use this as hostname if it is available.",
                "nixName": "preferredHostname",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "privateKey",
                "desc": "Location where to store the ShellHub Agent private key.",
                "nixName": "privateKey",
                "type": "path",
                "value": "\"/var/lib/shellhub-agent/private.key\""
            },
            {
                "name": "server",
                "desc": "Server address of ShellHub Gateway to connect.",
                "nixName": "server",
                "type": "string",
                "value": "\"https://cloud.shellhub.io\""
            },
            {
                "name": "tenantId",
                "desc": "The tenant ID to use when connecting to the ShellHub Gateway.",
                "nixName": "tenantId",
                "type": "string",
                "value": null
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Hound",
        "desc": "Lightning fast code searching made easy",
        "tags": [
            "Search Engines\r"
        ],
        "website": "https://github.com/hound-search/hound",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "hound",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable hound.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group the hound daemon should execute under.",
                "nixName": "group",
                "type": "string",
                "value": "\"hound\""
            },
            {
                "name": "home",
                "desc": "The path to use as hound\u2019s $HOME. If the default user \u201chound\u201d isconfigured then this is the home of the \u201chound\u201d user.",
                "nixName": "home",
                "type": "path",
                "value": "\"/var/lib/hound\""
            },
            {
                "name": "listen",
                "desc": "Listen on this [IP]:port",
                "nixName": "listen",
                "type": "string",
                "value": "\"0.0.0.0:6080\""
            },
            {
                "name": "package",
                "desc": "The hound package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.hound"
            },
            {
                "name": "settings",
                "desc": "The full configuration of the Hound daemon. See the upstreamdocumentation  https://github.com/hound-search/hound/blob/main/docs/config-options.md for details.   The  dbpath  should be an absolute path to a writabledirectory.",
                "nixName": "settings",
                "type": "JSON value",
                "value": null
            },
            {
                "name": "user",
                "desc": "User the hound daemon should execute under.",
                "nixName": "user",
                "type": "string",
                "value": "\"hound\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "OpenSearch",
        "desc": "Open Source, Distributed, RESTful Search Engine",
        "tags": [
            "Search Engines\r"
        ],
        "website": "https://github.com/opensearch-project/OpenSearch",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "opensearch",
        "options": [
            {
                "name": "dataDir",
                "desc": "Data directory for OpenSearch. If you change this, you need tomanually create the directory. You also need to create the opensearch  user and group, or change  services.opensearch.user and  services.opensearch.group to existing ones with access to the directory.",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/opensearch\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable OpenSearch.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraCmdLineOptions",
                "desc": "Extra command line options for the OpenSearch launcher.",
                "nixName": "extraCmdLineOptions",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "extraJavaOptions",
                "desc": "Extra command line options for Java.",
                "nixName": "extraJavaOptions",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "The group OpenSearch runs as. Should be left at default unless youhave very specific needs.",
                "nixName": "group",
                "type": "string",
                "value": "\"opensearch\""
            },
            {
                "name": "logging",
                "desc": "opensearch logging configuration.",
                "nixName": "logging",
                "type": "string",
                "value": "''\n  logger.action.name = org.opensearch.action\n  logger.action.level = info\n  \n  appender.console.type = Console\n  appender.console.name = console\n  appender.console.layout.type = PatternLayout\n  appender.console.layout.pattern = [%d{ISO8601}][%-5p][%-25c{1.}] %marker%m%n\n  \n  rootLogger.level = info\n  rootLogger.appenderRef.console.ref = console\n''"
            },
            {
                "name": "package",
                "desc": "The OpenSearch package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.opensearch"
            },
            {
                "name": "restartIfChanged",
                "desc": "Automatically restart the service on config change. This can be setto false to defer restarts on a server or cluster. Please consider thesecurity implications of inadvertently running an older version, and thepossibility of unexpected behavior caused by inconsistent versionsacross a cluster when disabling this option.",
                "nixName": "restartIfChanged",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings",
                "desc": "OpenSearch configuration.",
                "nixName": "settings",
                "type": "YAML value",
                "value": "{ }"
            },
            {
                "name": "settings.\"cluster.name\"",
                "desc": "The name of the cluster.",
                "nixName": "settings.\"cluster.name\"",
                "type": "string",
                "value": "\"opensearch\""
            },
            {
                "name": "settings.\"discovery.type\"",
                "desc": "The type of discovery to use.",
                "nixName": "settings.\"discovery.type\"",
                "type": "string",
                "value": "\"single-node\""
            },
            {
                "name": "settings.\"http.port\"",
                "desc": "The port to listen on for HTTP traffic.",
                "nixName": "settings.\"http.port\"",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9200"
            },
            {
                "name": "settings.\"network.host\"",
                "desc": "Which port this service should listen on.",
                "nixName": "settings.\"network.host\"",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "settings.\"plugins.security.disabled\"",
                "desc": "Whether to enable the security plugin, plugins.security.ssl.transport.keystore_filepath  or plugins.security.ssl.transport.server.pemcert_filepath  and plugins.security.ssl.transport.client.pemcert_filepath  mustbe set for this plugin to be enabled.",
                "nixName": "settings.\"plugins.security.disabled\"",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings.\"transport.port\"",
                "desc": "The port to listen on for transport traffic.",
                "nixName": "settings.\"transport.port\"",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "9300"
            },
            {
                "name": "user",
                "desc": "The user OpenSearch runs as. Should be left at default unless youhave very specific needs.",
                "nixName": "user",
                "type": "string",
                "value": "\"opensearch\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Typesense",
        "desc": "Typesense is a fast, typo-tolerant search engine for building delightful search experiences.",
        "tags": [
            "Search Engines\r"
        ],
        "website": "https://typesense.org",
        "logo": "https://typesense.org/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "typesense",
        "options": [
            {
                "name": "apiKeyFile",
                "desc": "Sets the admin api key for typesense. Always use this option insteadof  settings.server.api-key  to prevent the key frombeing written to the world-readable nix store.",
                "nixName": "apiKeyFile",
                "type": "path",
                "value": null
            },
            {
                "name": "enable",
                "desc": "Whether to enable typesense.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The typesense package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.typesense"
            },
            {
                "name": "settings",
                "desc": "Typesense configuration. Refer to  thedocumentation  for supported values.",
                "nixName": "settings",
                "type": "attribute set of section of an INI file (attrs of INI atom (null, bool, int, float or string) or a non-empty list of them)",
                "value": "{ }"
            },
            {
                "name": "settings.server.api-address",
                "desc": "Address to which Typesense API service binds.",
                "nixName": "settings.server.api-address",
                "type": "string",
                "value": null
            },
            {
                "name": "settings.server.api-port",
                "desc": "Port on which the Typesense API service listens.",
                "nixName": "settings.server.api-port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8108"
            },
            {
                "name": "settings.server.data-dir",
                "desc": "Path to the directory where data will be stored on disk.",
                "nixName": "settings.server.data-dir",
                "type": "string",
                "value": "\"/var/lib/typesense\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "GitLab CI",
        "desc": "Interact with GitLab API",
        "tags": [
            "Software Development - Continuous Integration & Continuous Deployment"
        ],
        "website": "https://github.com/python-gitlab/python-gitlab",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "gitlab",
        "options": [
            {
                "name": "backup.keepTime",
                "desc": "How long to keep the backups around, in hours.  0  means\u201ckeep forever\u201d.",
                "nixName": "backup.keepTime",
                "type": "signed integer",
                "value": "0"
            },
            {
                "name": "backup.path",
                "desc": "GitLab path for backups.",
                "nixName": "backup.path",
                "type": "string",
                "value": "config.services.gitlab.statePath + \"/backup\""
            },
            {
                "name": "backup.skip",
                "desc": "Directories to exclude from the backup. The example excludes CIartifacts and LFS objects from the backups. The  tar  optionskips the creation of a tar file.  Refer to  https://docs.gitlab.com/ee/raketasks/backup_restore.html#excluding-specific-directories-from-the-backup for more information.",
                "nixName": "backup.skip",
                "type": "one of \"db\", \"uploads\", \"builds\", \"artifacts\", \"lfs\", \"registry\", \"pages\", \"repositories\", \"tar\" or list of (one of \"db\", \"uploads\", \"builds\", \"artifacts\", \"lfs\", \"registry\", \"pages\", \"repositories\", \"tar\")",
                "value": "[ ]"
            },
            {
                "name": "backup.startAt",
                "desc": "The time(s) to run automatic backup of GitLab state. Specified insystemd\u2019s time format; see   systemd.time(7)  .",
                "nixName": "backup.startAt",
                "type": "string or list of string",
                "value": "[ ]"
            },
            {
                "name": "backup.uploadOptions",
                "desc": "GitLab automatic upload specification. Tells GitLab to upload thebackup to a remote location when done.  Attributes specified here are added under production -> backup -> upload  in  config/gitlab.yml .",
                "nixName": "backup.uploadOptions",
                "type": "attribute set",
                "value": "{ }"
            },
            {
                "name": "databaseCreateLocally",
                "desc": "Whether a database should be automatically created on the local host.Set this to  false  if you plan on provisioning a localdatabase yourself. This has no effect if  services.gitlab.databaseHost  is customized.",
                "nixName": "databaseCreateLocally",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "databaseHost",
                "desc": "GitLab database hostname. An empty string means \u201cuse local unixsocket connection\u201d.",
                "nixName": "databaseHost",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "databaseName",
                "desc": "GitLab database name.",
                "nixName": "databaseName",
                "type": "string",
                "value": "\"gitlab\""
            },
            {
                "name": "databasePasswordFile",
                "desc": "File containing the GitLab database user password.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "databasePasswordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "databasePool",
                "desc": "Database connection pool size.",
                "nixName": "databasePool",
                "type": "signed integer",
                "value": "5"
            },
            {
                "name": "databaseUsername",
                "desc": "GitLab database user.",
                "nixName": "databaseUsername",
                "type": "string",
                "value": "\"gitlab\""
            },
            {
                "name": "enable",
                "desc": "Enable the gitlab service.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraConfig",
                "desc": "Extra options to be added under  production  in  config/gitlab.yml , as a nixattribute set.  Options containing secret data should be set to an attribute setcontaining the attribute  _secret  - a string pointing to afile containing the value the option should be set to. See the exampleto get a better picture of this: in the resulting  config/gitlab.yml  file, the production.omniauth.providers[0].args.client_options.secret key will be set to the contents of the  /var/keys/gitlab_oidc_secret  file.",
                "nixName": "extraConfig",
                "type": "YAML value",
                "value": "{ }"
            },
            {
                "name": "extraDatabaseConfig",
                "desc": "Extra configuration in config/database.yml.",
                "nixName": "extraDatabaseConfig",
                "type": "attribute set",
                "value": "{ }"
            },
            {
                "name": "extraEnv",
                "desc": "Additional environment variables for the GitLab environment.",
                "nixName": "extraEnv",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "extraGitlabRb",
                "desc": "Extra configuration to be placed in config/extra-gitlab.rb. This canbe used to add configuration not otherwise exposed through this module\u2019soptions.",
                "nixName": "extraGitlabRb",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "extraShellConfig",
                "desc": "Extra configuration to merge into shell-config.yml",
                "nixName": "extraShellConfig",
                "type": "attribute set",
                "value": "{ }"
            },
            {
                "name": "group",
                "desc": "Group to run gitlab and all related services.",
                "nixName": "group",
                "type": "string",
                "value": "\"gitlab\""
            },
            {
                "name": "host",
                "desc": "GitLab host name. Used e.g. for copy-paste URLs.",
                "nixName": "host",
                "type": "string",
                "value": "config.networking.hostName"
            },
            {
                "name": "https",
                "desc": "Whether gitlab prints URLs with https as scheme.",
                "nixName": "https",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "initialRootEmail",
                "desc": "Initial email address of the root account if this is a newinstall.",
                "nixName": "initialRootEmail",
                "type": "string",
                "value": "\"admin@local.host\""
            },
            {
                "name": "initialRootPasswordFile",
                "desc": "File containing the initial password of the root account if this is anew install.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "initialRootPasswordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "logrotate.enable",
                "desc": "Enable rotation of log files.",
                "nixName": "logrotate.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "logrotate.frequency",
                "desc": "How often to rotate the logs.",
                "nixName": "logrotate.frequency",
                "type": "string",
                "value": "\"daily\""
            },
            {
                "name": "logrotate.keep",
                "desc": "How many rotations to keep.",
                "nixName": "logrotate.keep",
                "type": "signed integer",
                "value": "30"
            },
            {
                "name": "packages.gitaly",
                "desc": "The gitaly package to use.",
                "nixName": "packages.gitaly",
                "type": "package",
                "value": "pkgs.gitaly"
            },
            {
                "name": "packages.gitlab",
                "desc": "The gitlab package to use.",
                "nixName": "packages.gitlab",
                "type": "package",
                "value": "pkgs.gitlab"
            },
            {
                "name": "packages.gitlab-shell",
                "desc": "The gitlab-shell package to use.",
                "nixName": "packages.gitlab-shell",
                "type": "package",
                "value": "pkgs.gitlab-shell"
            },
            {
                "name": "packages.gitlab-workhorse",
                "desc": "The gitlab-workhorse package to use.",
                "nixName": "packages.gitlab-workhorse",
                "type": "package",
                "value": "pkgs.gitlab-workhorse"
            },
            {
                "name": "packages.pages",
                "desc": "The gitlab-pages package to use.",
                "nixName": "packages.pages",
                "type": "package",
                "value": "pkgs.gitlab-pages"
            },
            {
                "name": "pages.enable",
                "desc": "Whether to enable the GitLab Pages service.",
                "nixName": "pages.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "pages.settings",
                "desc": "Configuration options to set in the GitLab Pages config file.  Options containing secret data should be set to an attribute setcontaining the attribute  _secret  - a string pointing to afile containing the value the option should be set to. See the exampleto get a better picture of this: in the resulting configuration file,the  auth-client-secret  and  auth-secret  keyswill be set to the contents of the  /var/keys/auth-client-secret  and  /var/keys/auth-secret  filesrespectively.",
                "nixName": "pages.settings",
                "type": "attribute set of (null or string or signed integer or boolean or (attribute set))",
                "value": null
            },
            {
                "name": "pages.settings.artifacts-server",
                "desc": "API URL to proxy artifact requests to.",
                "nixName": "pages.settings.artifacts-server",
                "type": "null or string",
                "value": "\"http(s)://<services.gitlab.host>/api/v4\""
            },
            {
                "name": "pages.settings.gitlab-server",
                "desc": "Public GitLab server URL.",
                "nixName": "pages.settings.gitlab-server",
                "type": "null or string",
                "value": "\"http(s)://<services.gitlab.host>\""
            },
            {
                "name": "pages.settings.internal-gitlab-server",
                "desc": "Internal GitLab server used for API requests, useful if you want tosend that traffic over an internal load balancer. By default, the valueof  services.gitlab.pages.settings.gitlab-server  isused.",
                "nixName": "pages.settings.internal-gitlab-server",
                "type": "null or string",
                "value": "\"http(s)://<services.gitlab.host>\""
            },
            {
                "name": "pages.settings.listen-http",
                "desc": "The address(es) to listen on for HTTP requests.",
                "nixName": "pages.settings.listen-http",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "pages.settings.listen-https",
                "desc": "The address(es) to listen on for HTTPS requests.",
                "nixName": "pages.settings.listen-https",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "pages.settings.listen-proxy",
                "desc": "The address(es) to listen on for proxy requests.",
                "nixName": "pages.settings.listen-proxy",
                "type": "list of string",
                "value": "[\n  \"127.0.0.1:8090\"\n]"
            },
            {
                "name": "pages.settings.pages-domain",
                "desc": "The domain to serve static pages on.",
                "nixName": "pages.settings.pages-domain",
                "type": "null or string",
                "value": null
            },
            {
                "name": "pages.settings.pages-root",
                "desc": "The directory where pages are stored.",
                "nixName": "pages.settings.pages-root",
                "type": "string",
                "value": "config.services.gitlab.extraConfig.production.shared.path + \"/pages\""
            },
            {
                "name": "port",
                "desc": "GitLab server port for copy-paste URLs, e.g. 80 or 443 if you\u2019reservice over https.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            },
            {
                "name": "puma.threadsMax",
                "desc": "The maximum number of threads Puma should use per worker. This limitshow many threads Puma will automatically spawn in response to requests.In contrast to workers, threads will never be able to run Ruby code inparallel, but give higher IO parallelism.   Each thread consumes memory and contributes to Global VM Lockcontention, so be careful when increasing this.",
                "nixName": "puma.threadsMax",
                "type": "signed integer",
                "value": "4"
            },
            {
                "name": "puma.threadsMin",
                "desc": "The minimum number of threads Puma should use per worker.   Each thread consumes memory and contributes to Global VM Lockcontention, so be careful when increasing this.",
                "nixName": "puma.threadsMin",
                "type": "signed integer",
                "value": "0"
            },
            {
                "name": "puma.workers",
                "desc": "The number of worker processes Puma should spawn. This controls theamount of parallel Ruby code can be executed. GitLab recommends Number of CPU cores - 1 , but at least two.   Each worker consumes quite a bit of memory, so be careful whenincreasing this.",
                "nixName": "puma.workers",
                "type": "signed integer",
                "value": "2"
            },
            {
                "name": "redisUrl",
                "desc": "Redis URL for all GitLab services.",
                "nixName": "redisUrl",
                "type": "string",
                "value": "\"unix:/run/gitlab/redis.sock\""
            },
            {
                "name": "registry.certFile",
                "desc": "Path to GitLab container registry certificate.",
                "nixName": "registry.certFile",
                "type": "path",
                "value": null
            },
            {
                "name": "registry.defaultForProjects",
                "desc": "If GitLab container registry should be enabled by default forprojects.",
                "nixName": "registry.defaultForProjects",
                "type": "boolean",
                "value": "config.services.gitlab.registry.enable"
            },
            {
                "name": "registry.enable",
                "desc": "Enable GitLab container registry.",
                "nixName": "registry.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "registry.externalAddress",
                "desc": "External address used to access registry from the internet",
                "nixName": "registry.externalAddress",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "registry.externalPort",
                "desc": "External port used to access registry from the internet",
                "nixName": "registry.externalPort",
                "type": "signed integer",
                "value": null
            },
            {
                "name": "registry.host",
                "desc": "GitLab container registry host name.",
                "nixName": "registry.host",
                "type": "string",
                "value": "config.services.gitlab.host"
            },
            {
                "name": "registry.issuer",
                "desc": "GitLab container registry issuer.",
                "nixName": "registry.issuer",
                "type": "string",
                "value": "\"gitlab-issuer\""
            },
            {
                "name": "registry.keyFile",
                "desc": "Path to GitLab container registry certificate-key.",
                "nixName": "registry.keyFile",
                "type": "path",
                "value": null
            },
            {
                "name": "registry.package",
                "desc": "Container registry package to use.  External container registries such as pkgs.docker-distribution  are not supported anymore sinceGitLab 16.0.0.",
                "nixName": "registry.package",
                "type": "package",
                "value": "pkgs.docker-distribution"
            },
            {
                "name": "registry.port",
                "desc": "GitLab container registry port.",
                "nixName": "registry.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "4567"
            },
            {
                "name": "registry.serviceName",
                "desc": "GitLab container registry service name.",
                "nixName": "registry.serviceName",
                "type": "string",
                "value": "\"container_registry\""
            },
            {
                "name": "secrets.dbFile",
                "desc": "A file containing the secret used to encrypt variables in the DB. Ifyou change or lose this key you will be unable to access variablesstored in database.  Make sure the secret is at least 32 characters and all random, noregular words or you\u2019ll be exposed to dictionary attacks.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "secrets.dbFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "secrets.jwsFile",
                "desc": "A file containing the secret used to encrypt session keys. If youchange or lose this key, users will be disconnected.  Make sure the secret is an RSA private key in PEM format. You cangenerate one with  openssl genrsa 2048  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "secrets.jwsFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "secrets.otpFile",
                "desc": "A file containing the secret used to encrypt secrets for OTP tokens.If you change or lose this key, users which have 2FA enabled for loginwon\u2019t be able to login anymore.  Make sure the secret is at least 32 characters and all random, noregular words or you\u2019ll be exposed to dictionary attacks.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "secrets.otpFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "secrets.secretFile",
                "desc": "A file containing the secret used to encrypt variables in the DB. Ifyou change or lose this key you will be unable to access variablesstored in database.  Make sure the secret is at least 32 characters and all random, noregular words or you\u2019ll be exposed to dictionary attacks.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "secrets.secretFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "sidekiq.concurrency",
                "desc": "How many processor threads to use for processing sidekiq backgroundjob queues. When null, the GitLab default is used.  See  https://docs.gitlab.com/ee/administration/sidekiq/extra_sidekiq_processes.html#manage-thread-counts-explicitly for details.",
                "nixName": "sidekiq.concurrency",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "sidekiq.memoryKiller.enable",
                "desc": "Whether the Sidekiq MemoryKiller should be turned on. MemoryKillerkills Sidekiq when its memory consumption exceeds a certain limit.  See  https://docs.gitlab.com/ee/administration/operations/sidekiq_memory_killer.html for details.",
                "nixName": "sidekiq.memoryKiller.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "sidekiq.memoryKiller.graceTime",
                "desc": "The time MemoryKiller waits after noticing excessive memoryconsumption before killing Sidekiq.",
                "nixName": "sidekiq.memoryKiller.graceTime",
                "type": "signed integer",
                "value": "900"
            },
            {
                "name": "sidekiq.memoryKiller.maxMemory",
                "desc": "The maximum amount of memory, in MiB, a Sidekiq worker is allowed toconsume before being killed.",
                "nixName": "sidekiq.memoryKiller.maxMemory",
                "type": "signed integer",
                "value": "2000"
            },
            {
                "name": "sidekiq.memoryKiller.shutdownWait",
                "desc": "The time allowed for all jobs to finish before Sidekiq is killedforcefully.",
                "nixName": "sidekiq.memoryKiller.shutdownWait",
                "type": "signed integer",
                "value": "30"
            },
            {
                "name": "smtp.address",
                "desc": "Address of the SMTP server for GitLab.",
                "nixName": "smtp.address",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "smtp.authentication",
                "desc": "Authentication type to use, see  http://api.rubyonrails.org/classes/ActionMailer/Base.html",
                "nixName": "smtp.authentication",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "smtp.domain",
                "desc": "HELO domain to use for outgoing mail.",
                "nixName": "smtp.domain",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "smtp.enable",
                "desc": "Enable gitlab mail delivery over SMTP.",
                "nixName": "smtp.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "smtp.enableStartTLSAuto",
                "desc": "Whether to try to use StartTLS.",
                "nixName": "smtp.enableStartTLSAuto",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "smtp.opensslVerifyMode",
                "desc": "How OpenSSL checks the certificate, see  http://api.rubyonrails.org/classes/ActionMailer/Base.html",
                "nixName": "smtp.opensslVerifyMode",
                "type": "string",
                "value": "\"peer\""
            },
            {
                "name": "smtp.passwordFile",
                "desc": "File containing the password of the SMTP server for GitLab.  This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "smtp.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "smtp.port",
                "desc": "Port of the SMTP server for GitLab.",
                "nixName": "smtp.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "25"
            },
            {
                "name": "smtp.tls",
                "desc": "Whether to use TLS wrapper-mode.",
                "nixName": "smtp.tls",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "smtp.username",
                "desc": "Username of the SMTP server for GitLab.",
                "nixName": "smtp.username",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "statePath",
                "desc": "GitLab state directory. Configuration, repositories and logs, amongother things, are stored here.  The directory will be created automatically if it doesn\u2019t existalready. Its parent directories must be owned by either root  or the user set in  services.gitlab.user .",
                "nixName": "statePath",
                "type": "string",
                "value": "\"/var/gitlab/state\""
            },
            {
                "name": "user",
                "desc": "User to run gitlab and all related services.",
                "nixName": "user",
                "type": "string",
                "value": "\"gitlab\""
            },
            {
                "name": "workhorse.config",
                "desc": "Configuration options to add to Workhorse\u2019s configuration file.  See  https://gitlab.com/gitlab-org/gitlab/-/blob/master/workhorse/config.toml.example and  https://docs.gitlab.com/ee/development/workhorse/configuration.html for examples and option documentation.  Options containing secret data should be set to an attribute setcontaining the attribute  _secret  - a string pointing to afile containing the value the option should be set to. See the exampleto get a better picture of this: in the resulting configuration file,the  object_storage.s3.aws_secret_access_key  key will be setto the contents of the  /var/keys/aws_secret_access_key  file.",
                "nixName": "workhorse.config",
                "type": "TOML value",
                "value": "{ }"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "GoCD",
        "desc": "A continuous delivery server specializing in advanced workflow modeling and visualization",
        "tags": [
            "Software Development - Continuous Integration & Continuous Deployment"
        ],
        "website": "http://www.go.cd",
        "logo": "http://www.go.cd/assets/images/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "gocd-server",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable gocd-server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "environment",
                "desc": "Additional environment variables to be passed to the gocd-serverprocess. As a base environment, gocd-server receives NIX_PATH from  environment.sessionVariables , NIX_REMOTE is set to\u201cdaemon\u201d.",
                "nixName": "environment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "extraGroups",
                "desc": "List of extra groups that the \u201cgocd-server\u201d user should be a partof.",
                "nixName": "extraGroups",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "extraOptions",
                "desc": "Specifies additional command line arguments to pass to Go.CD server\u2019sjava process. Example contains debug and gcLog arguments.",
                "nixName": "extraOptions",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "If the default user \u201cgocd-server\u201d is configured then this is theprimary group of that user.",
                "nixName": "group",
                "type": "string",
                "value": "\"gocd-server\""
            },
            {
                "name": "initialJavaHeapSize",
                "desc": "Specifies the initial java heap memory size for the Go.CD server\u2019sjava process.",
                "nixName": "initialJavaHeapSize",
                "type": "string",
                "value": "\"512m\""
            },
            {
                "name": "listenAddress",
                "desc": "Specifies the bind address on which the Go.CD server HTTP interfacelistens.",
                "nixName": "listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "maxJavaHeapMemory",
                "desc": "Specifies the java maximum heap memory size for the Go.CD server\u2019sjava process.",
                "nixName": "maxJavaHeapMemory",
                "type": "string",
                "value": "\"1024m\""
            },
            {
                "name": "packages",
                "desc": "Packages to add to PATH for the Go.CD server\u2019s process.",
                "nixName": "packages",
                "type": "list of package",
                "value": "[ pkgs.stdenv pkgs.jre pkgs.git config.programs.ssh.package pkgs.nix ]"
            },
            {
                "name": "port",
                "desc": "Specifies port number on which the Go.CD server HTTP interfacelistens.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8153"
            },
            {
                "name": "sslPort",
                "desc": "Specifies port number on which the Go.CD server HTTPS interfacelistens.",
                "nixName": "sslPort",
                "type": "signed integer",
                "value": "8154"
            },
            {
                "name": "startupOptions",
                "desc": "Specifies startup command line arguments to pass to Go.CD server javaprocess.",
                "nixName": "startupOptions",
                "type": "list of string",
                "value": "[\n  \"-Xms${config.services.gocd-server.initialJavaHeapSize}\"\n  \"-Xmx${config.services.gocd-server.maxJavaHeapMemory}\"\n  \"-Dcruise.listen.host=${config.services.gocd-server.listenAddress}\"\n  \"-Duser.language=en\"\n  \"-Djruby.rack.request.size.threshold.bytes=30000000\"\n  \"-Duser.country=US\"\n  \"-Dcruise.config.dir=${config.services.gocd-server.workDir}/conf\"\n  \"-Dcruise.config.file=${config.services.gocd-server.workDir}/conf/cruise-config.xml\"\n  \"-Dcruise.server.port=${toString config.services.gocd-server.port}\"\n  \"-Dcruise.server.ssl.port=${toString config.services.gocd-server.sslPort}\"\n  \"--add-opens=java.base/java.lang=ALL-UNNAMED\"\n  \"--add-opens=java.base/java.util=ALL-UNNAMED\"\n]\n"
            },
            {
                "name": "user",
                "desc": "User the Go.CD server should execute under.",
                "nixName": "user",
                "type": "string",
                "value": "\"gocd-server\""
            },
            {
                "name": "workDir",
                "desc": "Specifies the working directory in which the Go.CD server javaarchive resides.",
                "nixName": "workDir",
                "type": "string",
                "value": "\"/var/lib/go-server\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Jenkins",
        "desc": "An extendable open source continuous integration server",
        "tags": [
            "Software Development - Continuous Integration & Continuous Deployment"
        ],
        "website": "https://jenkins.io/",
        "logo": "https://jenkins.io/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "jenkins",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable the jenkins continuous integration server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "environment",
                "desc": "Additional environment variables to be passed to the jenkins process.As a base environment, jenkins receives NIX_PATH from  environment.sessionVariables , NIX_REMOTE is set to\u201cdaemon\u201d and JENKINS_HOME is set to the value of  services.jenkins.home .This option has precedence and can be used to override those mentionedvariables.",
                "nixName": "environment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "extraGroups",
                "desc": "List of extra groups that the \u201cjenkins\u201d user should be a part of.",
                "nixName": "extraGroups",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "extraJavaOptions",
                "desc": "Additional command line arguments to pass to the Java run time (asopposed to Jenkins).",
                "nixName": "extraJavaOptions",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "extraOptions",
                "desc": "Additional command line arguments to pass to Jenkins.",
                "nixName": "extraOptions",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "If the default user \u201cjenkins\u201d is configured then this is the primarygroup of that user.",
                "nixName": "group",
                "type": "string",
                "value": "\"jenkins\""
            },
            {
                "name": "home",
                "desc": "The path to use as JENKINS_HOME. If the default user \u201cjenkins\u201d isconfigured then this is the home of the \u201cjenkins\u201d user.",
                "nixName": "home",
                "type": "path",
                "value": "\"/var/lib/jenkins\""
            },
            {
                "name": "jobBuilder.accessToken",
                "desc": "User token in Jenkins used to reload config. WARNING: This token willbe world readable in the Nix store. To keep it secret, use the  accessTokenFile  optioninstead.",
                "nixName": "jobBuilder.accessToken",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "jobBuilder.accessTokenFile",
                "desc": "File containing the API token for the  accessUser  user.",
                "nixName": "jobBuilder.accessTokenFile",
                "type": "string",
                "value": "\"${config.services.jenkins.home}/secrets/initialAdminPassword\""
            },
            {
                "name": "jobBuilder.accessUser",
                "desc": "User id in Jenkins used to reload config.",
                "nixName": "jobBuilder.accessUser",
                "type": "string",
                "value": "\"admin\""
            },
            {
                "name": "jobBuilder.enable",
                "desc": "Whether to enable the Jenkins Job Builder (JJB) service. It allowsdefining jobs for Jenkins in a declarative manner.  Jobs managed through the Jenkins WebUI (or by other means) are leftunchanged.  Note that it really is declarative configuration; if you remove apreviously defined job, the corresponding job directory will bedeleted.  Please see the Jenkins Job Builder documentation for more info:  https://jenkins-job-builder.readthedocs.io/ .",
                "nixName": "jobBuilder.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "jobBuilder.jsonJobs",
                "desc": "Job descriptions for Jenkins Job Builder in JSON format.",
                "nixName": "jobBuilder.jsonJobs",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "jobBuilder.nixJobs",
                "desc": "Job descriptions for Jenkins Job Builder in Nix format.  This is a trivial wrapper around jsonJobs, using builtins.toJSONbehind the scene.",
                "nixName": "jobBuilder.nixJobs",
                "type": "list of (attribute set)",
                "value": "[ ]"
            },
            {
                "name": "jobBuilder.yamlJobs",
                "desc": "Job descriptions for Jenkins Job Builder in YAML format.",
                "nixName": "jobBuilder.yamlJobs",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "listenAddress",
                "desc": "Specifies the bind address on which the jenkins HTTP interfacelistens. The default is the wildcard address.",
                "nixName": "listenAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "package",
                "desc": "The jenkins package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.jenkins"
            },
            {
                "name": "packages",
                "desc": "Packages to add to PATH for the jenkins process.",
                "nixName": "packages",
                "type": "list of package",
                "value": "[ pkgs.stdenv pkgs.git pkgs.jdk17 config.programs.ssh.package pkgs.nix ]"
            },
            {
                "name": "plugins",
                "desc": "A set of plugins to activate. Note that this will completely removeand replace any previously installed plugins. If you havemanually-installed plugins that you want to keep while using thismodule, set this option to  null . You can generate this setwith a tool such as  jenkinsPlugins2nix .",
                "nixName": "plugins",
                "type": "null or (attribute set of package)",
                "value": "null"
            },
            {
                "name": "port",
                "desc": "Specifies port number on which the jenkins HTTP interface listens.The default is 8080.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            },
            {
                "name": "prefix",
                "desc": "Specifies a urlPrefix to use with jenkins. If the example /jenkins isgiven, the jenkins server will be accessible usinglocalhost:8080/jenkins.",
                "nixName": "prefix",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "user",
                "desc": "User the jenkins server should execute under.",
                "nixName": "user",
                "type": "string",
                "value": "\"jenkins\""
            },
            {
                "name": "withCLI",
                "desc": "Whether to make the CLI available.  More info about the CLI available at [  https://www.jenkins.io/doc/book/managing/cli](https://www.jenkins.io/doc/book/managing/cli) .",
                "nixName": "withCLI",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "code-server",
        "desc": "Run VS Code on a remote machine",
        "tags": [
            "Software Development - IDE & Tools\r"
        ],
        "website": "https://github.com/gitpod-io/openvscode-server",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "openvscode-server",
        "options": [
            {
                "name": "connectionToken",
                "desc": "A secret that must be included with all requests.",
                "nixName": "connectionToken",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "connectionTokenFile",
                "desc": "Path to a file that contains the connection token.",
                "nixName": "connectionTokenFile",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable openvscode-server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extensionsDir",
                "desc": "Set the root path for extensions.",
                "nixName": "extensionsDir",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "extraArguments",
                "desc": "Additional arguments to pass to openvscode-server.",
                "nixName": "extraArguments",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "extraEnvironment",
                "desc": "Additional environment variables to pass to openvscode-server.",
                "nixName": "extraEnvironment",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "extraGroups",
                "desc": "An array of additional groups for the  openvscode-server user.",
                "nixName": "extraGroups",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "extraPackages",
                "desc": "Additional packages to add to the openvscode-server  PATH .",
                "nixName": "extraPackages",
                "type": "list of package",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "The group to run openvscode-server under. By default, a group named openvscode-server  will be created.",
                "nixName": "group",
                "type": "string",
                "value": "\"openvscode-server\""
            },
            {
                "name": "host",
                "desc": "The host name or IP address the server should listen to.",
                "nixName": "host",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "package",
                "desc": "The openvscode-server package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.openvscode-server"
            },
            {
                "name": "port",
                "desc": "The port the server should listen to. If 0 is passed a random freeport is picked. If a range in the format num-num is passed, a free portfrom the range (end inclusive) is selected.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "3000"
            },
            {
                "name": "serverDataDir",
                "desc": "Specifies the directory that server data is kept in.",
                "nixName": "serverDataDir",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "socketPath",
                "desc": "The path to a socket file for the server to listen to.",
                "nixName": "socketPath",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "telemetryLevel",
                "desc": "Sets the initial telemetry level. Valid levels are: \u2018off\u2019, \u2018crash\u2019,\u2018error\u2019 and \u2018all\u2019.",
                "nixName": "telemetryLevel",
                "type": "null or one of \"off\", \"crash\", \"error\", \"all\"",
                "value": "null"
            },
            {
                "name": "user",
                "desc": "The user to run openvscode-server as. By default, a user named openvscode-server  will be created.",
                "nixName": "user",
                "type": "string",
                "value": "\"openvscode-server\""
            },
            {
                "name": "userDataDir",
                "desc": "Specifies the directory that user data is kept in. Can be used toopen multiple distinct instances of Code.",
                "nixName": "userDataDir",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "withoutConnectionToken",
                "desc": "Run without a connection token. Only use this if the connection issecured by other means.",
                "nixName": "withoutConnectionToken",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "RStudio Server",
        "desc": "Set of integrated tools for the R language",
        "tags": [
            "Software Development - IDE & Tools\r"
        ],
        "website": "https://www.rstudio.com/",
        "logo": "https://posit.co/wp-content/themes/Posit/dist/images/favicon/favicon-32x32.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "rstudio-server",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable RStudio server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "listenAddr",
                "desc": "Address to listen on (www-address in rserver.conf).",
                "nixName": "listenAddr",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "package",
                "desc": "The rstudio-server package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.rstudio-server"
            },
            {
                "name": "rserverExtraConfig",
                "desc": "Extra contents for rserver.conf.",
                "nixName": "rserverExtraConfig",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "rsessionExtraConfig",
                "desc": "Extra contents for resssion.conf.",
                "nixName": "rsessionExtraConfig",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "serverWorkingDir",
                "desc": "Default working directory for server (server-working-dir inrserver.conf).",
                "nixName": "serverWorkingDir",
                "type": "string",
                "value": "\"/var/lib/rstudio-server\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Cgit",
        "desc": "Web frontend for git repositories",
        "tags": [
            "Software Development - Project Management\r"
        ],
        "website": "https://git.zx2c4.com/cgit/about/",
        "logo": "https://git.zx2c4.com/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "cgit",
        "options": [
            {
                "name": "<name>.enable",
                "desc": "Whether to enable cgit.",
                "nixName": "<name>.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "<name>.extraConfig",
                "desc": "These lines go to the end of cgitrc verbatim.",
                "nixName": "<name>.extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "<name>.nginx.location",
                "desc": "Location to serve cgit under.",
                "nixName": "<name>.nginx.location",
                "type": "string",
                "value": "\"/\""
            },
            {
                "name": "<name>.nginx.virtualHost",
                "desc": "VirtualHost to serve cgit on, defaults to the attribute name.",
                "nixName": "<name>.nginx.virtualHost",
                "type": "string",
                "value": "\"\u2039name\u203a\""
            },
            {
                "name": "<name>.package",
                "desc": "The cgit package to use.",
                "nixName": "<name>.package",
                "type": "package",
                "value": "pkgs.cgit"
            },
            {
                "name": "<name>.repos",
                "desc": "cgit repository settings, see cgitrc(5)",
                "nixName": "<name>.repos",
                "type": "attribute set of attribute set of (boolean or signed integer or string)",
                "value": "{ }"
            },
            {
                "name": "<name>.scanPath",
                "desc": "A path which will be scanned for repositories.",
                "nixName": "<name>.scanPath",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "<name>.settings",
                "desc": "cgit configuration, see cgitrc(5)",
                "nixName": "<name>.settings",
                "type": "attribute set of (boolean or signed integer or string)",
                "value": "{ }"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Forgejo",
        "desc": "A self-hosted lightweight software forge",
        "tags": [
            "Software Development - Project Management\r"
        ],
        "website": "https://forgejo.org",
        "logo": "https://forgejo.org/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "forgejo",
        "options": [
            {
                "name": "customDir",
                "desc": "Base directory for custom templates and other options.  If  services.forgejo.useWizard  is disabled (default),this directory will also hold secrets and the resulting  app.ini  config atruntime.",
                "nixName": "customDir",
                "type": "string",
                "value": "\"${config.services.forgejo.stateDir}/custom\""
            },
            {
                "name": "database.createDatabase",
                "desc": "Whether to create a local database automatically.",
                "nixName": "database.createDatabase",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "database.host",
                "desc": "Database host address.",
                "nixName": "database.host",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "database.name",
                "desc": "Database name.",
                "nixName": "database.name",
                "type": "string",
                "value": "\"forgejo\""
            },
            {
                "name": "database.passwordFile",
                "desc": "A file containing the password corresponding to  services.forgejo.database.user .",
                "nixName": "database.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "database.path",
                "desc": "Path to the sqlite3 database file.",
                "nixName": "database.path",
                "type": "string",
                "value": "\"${config.services.forgejo.stateDir}/data/forgejo.db\""
            },
            {
                "name": "database.port",
                "desc": "Database host port.",
                "nixName": "database.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "if config.services.forgejo.database.type != \"postgresql\"\nthen 3306\nelse 5432\n"
            },
            {
                "name": "database.socket",
                "desc": "Path to the unix socket file to use for authentication.",
                "nixName": "database.socket",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "database.type",
                "desc": "Database engine to use.",
                "nixName": "database.type",
                "type": "one of \"sqlite3\", \"mysql\", \"postgres\"",
                "value": "\"sqlite3\""
            },
            {
                "name": "database.user",
                "desc": "Database user.",
                "nixName": "database.user",
                "type": "string",
                "value": "\"forgejo\""
            },
            {
                "name": "dump.backupDir",
                "desc": "Path to the directory where the dump archives will be stored.",
                "nixName": "dump.backupDir",
                "type": "string",
                "value": "\"${config.services.forgejo.stateDir}/dump\""
            },
            {
                "name": "dump.enable",
                "desc": "Whether to enable periodic dumps via the  built-in dump command .",
                "nixName": "dump.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "dump.file",
                "desc": "Filename to be used for the dump. If  null  a default nameis chosen by forgejo.",
                "nixName": "dump.file",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "dump.interval",
                "desc": "Run a Forgejo dump at this interval. Runs by default at 04:31 everyday.  The format is described in   systemd.time(7)  .",
                "nixName": "dump.interval",
                "type": "string",
                "value": "\"04:31\""
            },
            {
                "name": "dump.type",
                "desc": "Archive format used to store the dump file.",
                "nixName": "dump.type",
                "type": "one of \"zip\", \"tar\", \"tar.sz\", \"tar.gz\", \"tar.xz\", \"tar.bz2\", \"tar.br\", \"tar.lz4\", \"tar.zst\"",
                "value": "\"zip\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Forgejo, a software forge.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which Forgejo runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"forgejo\""
            },
            {
                "name": "lfs.contentDir",
                "desc": "Where to store LFS files.",
                "nixName": "lfs.contentDir",
                "type": "string",
                "value": "\"${config.services.forgejo.stateDir}/data/lfs\""
            },
            {
                "name": "lfs.enable",
                "desc": "Enables git-lfs support.",
                "nixName": "lfs.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The forgejo package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.forgejo"
            },
            {
                "name": "repositoryRoot",
                "desc": "Path to the git repositories.",
                "nixName": "repositoryRoot",
                "type": "string",
                "value": "\"${config.services.forgejo.stateDir}/repositories\""
            },
            {
                "name": "secrets",
                "desc": "This is a small wrapper over systemd\u2019s LoadCredential .  It takes the same sections and keys as  services.forgejo.settings , but the value of eachkey is a path instead of a string or bool.  The path is then loaded as credential, exported as environmentvariable and then feed through  https://codeberg.org/forgejo/forgejo/src/branch/forgejo/contrib/environment-to-ini/environment-to-ini.go .  It does the required environment variable escaping for you.   Keys specified here take priority over the ones in  services.forgejo.settings !",
                "nixName": "secrets",
                "type": "attribute set of attribute set of path",
                "value": "{ }"
            },
            {
                "name": "settings",
                "desc": "Free-form settings written directly to the  app.ini configfile file. Refer to  https://forgejo.org/docs/latest/admin/config-cheat-sheet/ for supported values.",
                "nixName": "settings",
                "type": "attribute set of section of an INI file (attrs of INI atom (null, bool, int, float or string))",
                "value": "{ }"
            },
            {
                "name": "settings.log.LEVEL",
                "desc": "General log level.",
                "nixName": "settings.log.LEVEL",
                "type": "one of \"Trace\", \"Debug\", \"Info\", \"Warn\", \"Error\", \"Critical\"",
                "value": "\"Info\""
            },
            {
                "name": "settings.log.ROOT_PATH",
                "desc": "Root path for log files.",
                "nixName": "settings.log.ROOT_PATH",
                "type": "string",
                "value": "\"${config.services.forgejo.stateDir}/log\""
            },
            {
                "name": "settings.server.DISABLE_SSH",
                "desc": "Disable external SSH feature.",
                "nixName": "settings.server.DISABLE_SSH",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.server.DOMAIN",
                "desc": "Domain name of your server.",
                "nixName": "settings.server.DOMAIN",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "settings.server.HTTP_ADDR",
                "desc": "Listen address. Must be a path when using a unix socket.",
                "nixName": "settings.server.HTTP_ADDR",
                "type": "string or path",
                "value": "if lib.hasSuffix \"+unix\" cfg.settings.server.PROTOCOL then \"/run/forgejo/forgejo.sock\" else \"0.0.0.0\""
            },
            {
                "name": "settings.server.HTTP_PORT",
                "desc": "Listen port. Ignored when using a unix socket.",
                "nixName": "settings.server.HTTP_PORT",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "3000"
            },
            {
                "name": "settings.server.PROTOCOL",
                "desc": "Listen protocol.  +unix  means \u201cover unix\u201d, not \u201cinaddition to.\u201d",
                "nixName": "settings.server.PROTOCOL",
                "type": "one of \"http\", \"https\", \"fcgi\", \"http+unix\", \"fcgi+unix\"",
                "value": "\"http\""
            },
            {
                "name": "settings.server.ROOT_URL",
                "desc": "Full public URL of Forgejo server.",
                "nixName": "settings.server.ROOT_URL",
                "type": "string",
                "value": "\"http://${config.services.forgejo.settings.server.DOMAIN}:${toString config.services.forgejo.settings.server.HTTP_PORT}/\""
            },
            {
                "name": "settings.server.SSH_PORT",
                "desc": "SSH port displayed in clone URL. The option is required to configurea service when the external visible port differs from the locallistening port i.e. if port forwarding is used.",
                "nixName": "settings.server.SSH_PORT",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "22"
            },
            {
                "name": "settings.server.STATIC_ROOT_PATH",
                "desc": "Upper level of template and static files path.",
                "nixName": "settings.server.STATIC_ROOT_PATH",
                "type": "string or path",
                "value": "config.services.forgejo.package.data"
            },
            {
                "name": "settings.session.COOKIE_SECURE",
                "desc": "Marks session cookies as \u201csecure\u201d as a hint for browsers to only sendthem via HTTPS. This option is recommend, if Forgejo is being servedover HTTPS.",
                "nixName": "settings.session.COOKIE_SECURE",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "stateDir",
                "desc": "Forgejo data directory.",
                "nixName": "stateDir",
                "type": "string",
                "value": "\"/var/lib/forgejo\""
            },
            {
                "name": "useWizard",
                "desc": "Whether to use the built-in installation wizard instead ofdeclaratively managing the  app.ini  config file in nix.",
                "nixName": "useWizard",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "user",
                "desc": "User account under which Forgejo runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"forgejo\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Gerrit",
        "desc": "A Kubernetes based CI/CD system",
        "tags": [
            "Software Development - Project Management\r"
        ],
        "website": "https://github.com/kubernetes/test-infra/tree/master/prow",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "gerrit",
        "options": [
            {
                "name": "builtinPlugins",
                "desc": "List of builtins plugins to install. Those are shipped in the gerrit.war  file.",
                "nixName": "builtinPlugins",
                "type": "list of (one of \"codemirror-editor\", \"commit-message-length-validator\", \"delete-project\", \"download-commands\", \"gitiles\", \"hooks\", \"plugin-manager\", \"replication\", \"reviewnotes\", \"singleusergroup\", \"webhooks\")",
                "value": "[ ]"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Gerrit service.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "jvmHeapLimit",
                "desc": "How much memory to allocate to the JVM heap",
                "nixName": "jvmHeapLimit",
                "type": "string",
                "value": "\"1024m\""
            },
            {
                "name": "jvmOpts",
                "desc": "A list of JVM options to start gerrit with.",
                "nixName": "jvmOpts",
                "type": "list of string",
                "value": "[\n  \"-Dflogger.backend_factory=com.google.common.flogger.backend.log4j.Log4jBackendFactory#getInstance\"\n  \"-Dflogger.logging_context=com.google.gerrit.server.logging.LoggingContext#getInstance\"\n]"
            },
            {
                "name": "jvmPackage",
                "desc": "The jre_headless package to use.",
                "nixName": "jvmPackage",
                "type": "package",
                "value": "pkgs.jre_headless"
            },
            {
                "name": "listenAddress",
                "desc": "hostname:port  to listen for HTTP traffic.  This is bound using the systemd socket activation.",
                "nixName": "listenAddress",
                "type": "string",
                "value": "\"[::]:8080\""
            },
            {
                "name": "package",
                "desc": "The gerrit package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.gerrit"
            },
            {
                "name": "plugins",
                "desc": "List of plugins to add to Gerrit. Each derivation is a jar fileitself where the name of the derivation is the name of plugin.",
                "nixName": "plugins",
                "type": "list of package",
                "value": "[ ]"
            },
            {
                "name": "replicationSettings",
                "desc": "Replication configuration. This will be generated to the etc/replication.config  file.",
                "nixName": "replicationSettings",
                "type": "lazy attribute set of lazy attribute set of (string or boolean or signed integer or list of (string or boolean or signed integer) or lazy attribute set of (string or boolean or signed integer or list of (string or boolean or signed integer)))",
                "value": "{ }"
            },
            {
                "name": "serverId",
                "desc": "Set a UUID that uniquely identifies the server.  This can be generated with nix-shell -p util-linux --run uuidgen .",
                "nixName": "serverId",
                "type": "string",
                "value": null
            },
            {
                "name": "settings",
                "desc": "Gerrit configuration. This will be generated to the etc/gerrit.config  file.",
                "nixName": "settings",
                "type": "lazy attribute set of lazy attribute set of (string or boolean or signed integer or list of (string or boolean or signed integer) or lazy attribute set of (string or boolean or signed integer or list of (string or boolean or signed integer)))",
                "value": "{ }"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Gitolite",
        "desc": "Finely-grained git repository hosting",
        "tags": [
            "Software Development - Project Management\r"
        ],
        "website": "https://gitolite.com/gitolite/index.html",
        "logo": "https://gitolite.com/gitolite/img/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "gitolite",
        "options": [
            {
                "name": "adminPubkey",
                "desc": "Initial administrative public key for Gitolite. This should be an SSHPublic Key. Note that this key will only be used once, upon the firstinitialization of the Gitolite user. The key string cannot have any linebreaks in it.",
                "nixName": "adminPubkey",
                "type": "string",
                "value": null
            },
            {
                "name": "commonHooks",
                "desc": "A list of custom git hooks that get copied to ~/.gitolite/hooks/common .",
                "nixName": "commonHooks",
                "type": "list of path",
                "value": "[ ]"
            },
            {
                "name": "dataDir",
                "desc": "The gitolite home directory used to store all repositories. If leftas the default value this directory will automatically be created beforethe gitolite server starts, otherwise the sysadmin is responsible forensuring the directory exists with appropriate ownership andpermissions.",
                "nixName": "dataDir",
                "type": "string",
                "value": "\"/var/lib/gitolite\""
            },
            {
                "name": "description",
                "desc": "Gitolite user account\u2019s description.",
                "nixName": "description",
                "type": "string",
                "value": "\"Gitolite user\""
            },
            {
                "name": "enable",
                "desc": "Enable gitolite management under the  gitolite  user.After switching to a configuration with Gitolite enabled, you can thenrun  git clone gitolite@host:gitolite-admin.git  to manage itfurther.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableGitAnnex",
                "desc": "Enable git-annex support. Uses the  extraGitoliteRc option to apply the necessary configuration.",
                "nixName": "enableGitAnnex",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraGitoliteRc",
                "desc": "Extra configuration to append to the default ~/.gitolite.rc .  This should be Perl code that modifies the  %RC configuration variable. The default  ~/.gitolite.rc  contentis generated by invoking  gitolite print-default-rc , andextra configuration from this option is appended to it. The result isplaced to Nix store, and the  ~/.gitolite.rc  file becomes asymlink to it.  If you already have a customized (or otherwise changed) ~/.gitolite.rc  file, NixOS will refuse to replace it with asymlink, and the  gitolite-init  initialization service willfail. In this situation, in order to use this option, you will need totake any customizations you may have in  ~/.gitolite.rc ,convert them to appropriate Perl statements, add them to this option,and remove the file.  See also the  enableGitAnnex  option.",
                "nixName": "extraGitoliteRc",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "group",
                "desc": "Primary group of the Gitolite user account.",
                "nixName": "group",
                "type": "string",
                "value": "\"gitolite\""
            },
            {
                "name": "user",
                "desc": "Gitolite user account. This is the username of the gitoliteendpoint.",
                "nixName": "user",
                "type": "string",
                "value": "\"gitolite\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Gogs",
        "desc": "A painless self-hosted Git service",
        "tags": [
            "Software Development - Project Management\r"
        ],
        "website": "https://gogs.io",
        "logo": "https://gogs.io/img/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "gogs",
        "options": [
            {
                "name": "appName",
                "desc": "Application name.",
                "nixName": "appName",
                "type": "string",
                "value": "\"Gogs: Go Git Service\""
            },
            {
                "name": "cookieSecure",
                "desc": "Marks session cookies as \u201csecure\u201d as a hint for browsers to only sendthem via HTTPS. This option is recommend, if Gogs is being served overHTTPS.",
                "nixName": "cookieSecure",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "database.host",
                "desc": "Database host address.",
                "nixName": "database.host",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "database.name",
                "desc": "Database name.",
                "nixName": "database.name",
                "type": "string",
                "value": "\"gogs\""
            },
            {
                "name": "database.password",
                "desc": "The password corresponding to  database.user . Warning: this is stored in cleartextin the Nix store! Use  database.passwordFile  instead.",
                "nixName": "database.password",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "database.passwordFile",
                "desc": "A file containing the password corresponding to  database.user .",
                "nixName": "database.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "database.path",
                "desc": "Path to the sqlite3 database file.",
                "nixName": "database.path",
                "type": "string",
                "value": "\"${config.services.gogs.stateDir}/data/gogs.db\""
            },
            {
                "name": "database.port",
                "desc": "Database host port.",
                "nixName": "database.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "3306"
            },
            {
                "name": "database.type",
                "desc": "Database engine to use.",
                "nixName": "database.type",
                "type": "one of \"sqlite3\", \"mysql\", \"postgres\"",
                "value": "\"sqlite3\""
            },
            {
                "name": "database.user",
                "desc": "Database user.",
                "nixName": "database.user",
                "type": "string",
                "value": "\"gogs\""
            },
            {
                "name": "domain",
                "desc": "Domain name of your server.",
                "nixName": "domain",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "enable",
                "desc": "Enable Go Git Service.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraConfig",
                "desc": "Configuration lines appended to the generated Gogs configurationfile.",
                "nixName": "extraConfig",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "group",
                "desc": "Group account under which Gogs runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"gogs\""
            },
            {
                "name": "httpAddress",
                "desc": "HTTP listen address.",
                "nixName": "httpAddress",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "httpPort",
                "desc": "HTTP listen port.",
                "nixName": "httpPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "3000"
            },
            {
                "name": "repositoryRoot",
                "desc": "Path to the git repositories.",
                "nixName": "repositoryRoot",
                "type": "string",
                "value": "\"${config.services.gogs.stateDir}/repositories\""
            },
            {
                "name": "rootUrl",
                "desc": "Full public URL of Gogs server.",
                "nixName": "rootUrl",
                "type": "string",
                "value": "\"http://localhost:3000/\""
            },
            {
                "name": "stateDir",
                "desc": "Gogs data directory.",
                "nixName": "stateDir",
                "type": "string",
                "value": "\"/var/lib/gogs\""
            },
            {
                "name": "useWizard",
                "desc": "Do not generate a configuration and use Gogs\u2019 installation wizardinstead. The first registered user will be administrator.",
                "nixName": "useWizard",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "user",
                "desc": "User account under which Gogs runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"gogs\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Zammad",
        "desc": "Zammad, a web-based, open source user support/ticketing solution.",
        "tags": [
            "Ticketing\r"
        ],
        "website": "https://zammad.org",
        "logo": "https://zammad.org/assets/images/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "zammad",
        "options": [
            {
                "name": "dataDir",
                "desc": "Path to a folder that will contain Zammad working directory.",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/zammad\""
            },
            {
                "name": "database.createLocally",
                "desc": "Whether to create a local database automatically.",
                "nixName": "database.createLocally",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "database.host",
                "desc": "Database host address.",
                "nixName": "database.host",
                "type": "null or string",
                "value": "{\n  PostgreSQL = \"/run/postgresql\";\n  MySQL = \"localhost\";\n}.${config.services.zammad.database.type};\n"
            },
            {
                "name": "database.name",
                "desc": "Database name.",
                "nixName": "database.name",
                "type": "string",
                "value": "\"zammad\""
            },
            {
                "name": "database.passwordFile",
                "desc": "A file containing the password for  services.zammad.database.user .",
                "nixName": "database.passwordFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "database.port",
                "desc": "Database port. Use  null  for default port.",
                "nixName": "database.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "database.settings",
                "desc": "The  database.yml configuration file as key value set. See <TODO> for list ofconfiguration parameters.",
                "nixName": "database.settings",
                "type": "YAML value",
                "value": "{ }"
            },
            {
                "name": "database.type",
                "desc": "Database engine to use.",
                "nixName": "database.type",
                "type": "one of \"PostgreSQL\", \"MySQL\"",
                "value": "\"PostgreSQL\""
            },
            {
                "name": "database.user",
                "desc": "Database user.",
                "nixName": "database.user",
                "type": "null or string",
                "value": "\"zammad\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable Zammad, a web-based, open source usersupport/ticketing solution.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "host",
                "desc": "Host address.",
                "nixName": "host",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "openPorts",
                "desc": "Whether to open firewall ports for Zammad",
                "nixName": "openPorts",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The zammad package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.zammad"
            },
            {
                "name": "port",
                "desc": "Web service port.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "3000"
            },
            {
                "name": "redis.createLocally",
                "desc": "Whether to create a local redis automatically.",
                "nixName": "redis.createLocally",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "redis.host",
                "desc": "Redis server address.",
                "nixName": "redis.host",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "redis.name",
                "desc": "Name of the redis server. Only used if  createLocally  isset to true.",
                "nixName": "redis.name",
                "type": "string",
                "value": "\"zammad\""
            },
            {
                "name": "redis.port",
                "desc": "Port of the redis server.",
                "nixName": "redis.port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "6379"
            },
            {
                "name": "secretKeyBaseFile",
                "desc": "The path to a file containing the  secret_key_base secret.  Zammad uses  secret_key_base  to encrypt the cookie store,which contains session data, and to digest user auth tokens.  Needs to be a 64 byte long string of hexadecimal characters. You cangenerate one by running   openssl rand -hex 64 >/path/to/secret_key_base_file   This should be a string, not a nix path, since nix paths are copiedinto the world-readable nix store.",
                "nixName": "secretKeyBaseFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "websocketPort",
                "desc": "Websocket service port.",
                "nixName": "websocketPort",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "6042"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Zoneminder",
        "desc": "Video surveillance software system",
        "tags": [
            "Video Surveillance\r"
        ],
        "website": "https://zoneminder.com",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "zoneminder",
        "options": [
            {
                "name": "cameras",
                "desc": "Set this to the number of cameras you expect to support.",
                "nixName": "cameras",
                "type": "signed integer",
                "value": "1"
            },
            {
                "name": "database.createLocally",
                "desc": "Create the database and database user locally.",
                "nixName": "database.createLocally",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "database.host",
                "desc": "Hostname hosting the database.",
                "nixName": "database.host",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "database.name",
                "desc": "Name of database.",
                "nixName": "database.name",
                "type": "string",
                "value": "\"zm\""
            },
            {
                "name": "database.password",
                "desc": "Username for accessing the database. Not used if createLocally  is set.",
                "nixName": "database.password",
                "type": "string",
                "value": "\"zmpass\""
            },
            {
                "name": "database.username",
                "desc": "Username for accessing the database.",
                "nixName": "database.username",
                "type": "string",
                "value": "\"zmuser\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable ZoneMinder.  If you intend to run the database locally, you should set config.services.zoneminder.database.createLocally  to true.Otherwise, when set to  false  (the default), you will haveto create the database and database user as well as populate thedatabase yourself. Additionally, you will need to run zmupdate.pl  yourself when upgrading to a newer version.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraConfig",
                "desc": "Additional configuration added verbatim to the configurationfile.",
                "nixName": "extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "hostname",
                "desc": "The hostname on which to listen.",
                "nixName": "hostname",
                "type": "string",
                "value": "\"localhost\""
            },
            {
                "name": "openFirewall",
                "desc": "Open the firewall port(s).",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "port",
                "desc": "The port on which to listen.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8095"
            },
            {
                "name": "storageDir",
                "desc": "ZoneMinder can generate quite a lot of data, so in case you don\u2019twant to use the default /var/lib/zoneminder, you can override the pathhere.",
                "nixName": "storageDir",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "webserver",
                "desc": "The webserver to configure for the PHP frontend.  Set it to  none  if you want to configure it yourself. PRsare welcome for support for other web servers.",
                "nixName": "webserver",
                "type": "one of \"nginx\", \"none\"",
                "value": "\"nginx\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Headscale",
        "desc": "An open source, self-hosted implementation of the Tailscale control server",
        "tags": [
            "VPN"
        ],
        "website": "https://github.com/juanfont/headscale",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "headscale",
        "options": [
            {
                "name": "address",
                "desc": "Listening address of headscale.",
                "nixName": "address",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable headscale, Open Source coordination server forTailscale.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group under which headscale runs.   If left as the default value this group will automatically be createdon system activation, otherwise you are responsible for ensuring theuser exists before the headscale service starts.",
                "nixName": "group",
                "type": "string",
                "value": "\"headscale\""
            },
            {
                "name": "package",
                "desc": "The headscale package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.headscale"
            },
            {
                "name": "port",
                "desc": "Listening port of headscale.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            },
            {
                "name": "settings",
                "desc": "Overrides to  config.yaml  as a Nix attribute set. Check the  exampleconfig  for possible options.",
                "nixName": "settings",
                "type": "YAML value",
                "value": null
            },
            {
                "name": "settings.acl_policy_path",
                "desc": "Path to a file containing ACL policies.",
                "nixName": "settings.acl_policy_path",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "settings.db_host",
                "desc": "Database host address.",
                "nixName": "settings.db_host",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "settings.db_name",
                "desc": "Database name.",
                "nixName": "settings.db_name",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "settings.db_password_file",
                "desc": "A file containing the password corresponding to  database.user .",
                "nixName": "settings.db_password_file",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "settings.db_path",
                "desc": "Path to the sqlite3 database file.",
                "nixName": "settings.db_path",
                "type": "null or string",
                "value": "\"/var/lib/headscale/db.sqlite\""
            },
            {
                "name": "settings.db_port",
                "desc": "Database host port.",
                "nixName": "settings.db_port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "null"
            },
            {
                "name": "settings.db_type",
                "desc": "Database engine to use.",
                "nixName": "settings.db_type",
                "type": "one of \"sqlite3\", \"postgres\"",
                "value": "\"sqlite3\""
            },
            {
                "name": "settings.db_user",
                "desc": "Database user.",
                "nixName": "settings.db_user",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "settings.derp.auto_update_enable",
                "desc": "Whether to automatically update DERP maps on a set frequency.",
                "nixName": "settings.derp.auto_update_enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings.derp.paths",
                "desc": "List of file paths containing DERP maps. See  How Tailscaleworks  for more information on DERP maps.",
                "nixName": "settings.derp.paths",
                "type": "list of path",
                "value": "[ ]"
            },
            {
                "name": "settings.derp.update_frequency",
                "desc": "Frequency to update DERP maps.",
                "nixName": "settings.derp.update_frequency",
                "type": "string",
                "value": "\"24h\""
            },
            {
                "name": "settings.derp.urls",
                "desc": "List of urls containing DERP maps. See  How Tailscaleworks  for more information on DERP maps.",
                "nixName": "settings.derp.urls",
                "type": "list of string",
                "value": "[\n  \"https://controlplane.tailscale.com/derpmap/default\"\n]"
            },
            {
                "name": "settings.dns_config.base_domain",
                "desc": "Defines the base domain to create the hostnames for MagicDNS.  baseDomain  must be aFQDNs, without the trailing dot. The FQDN of the hosts will be hostname.namespace.base_domain  (e.g. myhost.mynamespace.example.com ).",
                "nixName": "settings.dns_config.base_domain",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "settings.dns_config.domains",
                "desc": "Search domains to inject to Tailscale clients.",
                "nixName": "settings.dns_config.domains",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "settings.dns_config.magic_dns",
                "desc": "Whether to use  MagicDNS . Only worksif there is at least a nameserver defined.",
                "nixName": "settings.dns_config.magic_dns",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings.dns_config.nameservers",
                "desc": "List of nameservers to pass to Tailscale clients.",
                "nixName": "settings.dns_config.nameservers",
                "type": "list of string",
                "value": "[\n  \"1.1.1.1\"\n]"
            },
            {
                "name": "settings.dns_config.override_local_dns",
                "desc": "Whether to use  Overridelocal DNS .",
                "nixName": "settings.dns_config.override_local_dns",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings.ephemeral_node_inactivity_timeout",
                "desc": "Time before an inactive ephemeral node is deleted.",
                "nixName": "settings.ephemeral_node_inactivity_timeout",
                "type": "string",
                "value": "\"30m\""
            },
            {
                "name": "settings.log.format",
                "desc": "headscale log format.",
                "nixName": "settings.log.format",
                "type": "string",
                "value": "\"text\""
            },
            {
                "name": "settings.log.level",
                "desc": "headscale log level.",
                "nixName": "settings.log.level",
                "type": "string",
                "value": "\"info\""
            },
            {
                "name": "settings.noise.private_key_path",
                "desc": "Path to noise private key file, generated automatically if it doesnot exist.",
                "nixName": "settings.noise.private_key_path",
                "type": "path",
                "value": "\"/var/lib/headscale/noise_private.key\""
            },
            {
                "name": "settings.oidc.allowed_domains",
                "desc": "Allowed principal domains. if an authenticated user\u2019s domain is notin this list authentication request will be rejected.",
                "nixName": "settings.oidc.allowed_domains",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "settings.oidc.allowed_users",
                "desc": "Users allowed to authenticate even if not in allowedDomains.",
                "nixName": "settings.oidc.allowed_users",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "settings.oidc.client_id",
                "desc": "OpenID Connect client ID.",
                "nixName": "settings.oidc.client_id",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "settings.oidc.client_secret_path",
                "desc": "Path to OpenID Connect client secret file. Expands environmentvariables in format ${VAR}.",
                "nixName": "settings.oidc.client_secret_path",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "settings.oidc.extra_params",
                "desc": "Custom query parameters to send with the Authorize Endpointrequest.",
                "nixName": "settings.oidc.extra_params",
                "type": "attribute set of string",
                "value": "{ }"
            },
            {
                "name": "settings.oidc.issuer",
                "desc": "URL to OpenID issuer.",
                "nixName": "settings.oidc.issuer",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "settings.oidc.scope",
                "desc": "Scopes used in the OIDC flow.",
                "nixName": "settings.oidc.scope",
                "type": "list of string",
                "value": "[\n  \"openid\"\n  \"profile\"\n  \"email\"\n]"
            },
            {
                "name": "settings.oidc.strip_email_domain",
                "desc": "Whether the domain part of the email address should be removed whengenerating namespaces.",
                "nixName": "settings.oidc.strip_email_domain",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "settings.private_key_path",
                "desc": "Path to private key file, generated automatically if it does notexist.",
                "nixName": "settings.private_key_path",
                "type": "path",
                "value": "\"/var/lib/headscale/private.key\""
            },
            {
                "name": "settings.server_url",
                "desc": "The url clients will connect to.",
                "nixName": "settings.server_url",
                "type": "string",
                "value": "\"http://127.0.0.1:8080\""
            },
            {
                "name": "settings.tls_cert_path",
                "desc": "Path to already created certificate.",
                "nixName": "settings.tls_cert_path",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "settings.tls_key_path",
                "desc": "Path to key for already created certificate.",
                "nixName": "settings.tls_key_path",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "settings.tls_letsencrypt_challenge_type",
                "desc": "Type of ACME challenge to use, currently supported types: HTTP-01  or  TLS-ALPN-01 .",
                "nixName": "settings.tls_letsencrypt_challenge_type",
                "type": "one of \"TLS-ALPN-01\", \"HTTP-01\"",
                "value": "\"HTTP-01\""
            },
            {
                "name": "settings.tls_letsencrypt_hostname",
                "desc": "Domain name to request a TLS certificate for.",
                "nixName": "settings.tls_letsencrypt_hostname",
                "type": "null or string",
                "value": "\"\""
            },
            {
                "name": "settings.tls_letsencrypt_listen",
                "desc": "When HTTP-01 challenge is chosen, letsencrypt must set up averification endpoint, and it will be listening on: :http = port 80 .",
                "nixName": "settings.tls_letsencrypt_listen",
                "type": "null or string",
                "value": "\":http\""
            },
            {
                "name": "user",
                "desc": "User account under which headscale runs.   If left as the default value this user will automatically be createdon system activation, otherwise you are responsible for ensuring theuser exists before the headscale service starts.",
                "nixName": "user",
                "type": "string",
                "value": "\"headscale\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Nebula",
        "desc": "Overlay networking tool with a focus on performance, simplicity and security",
        "tags": [
            "VPN"
        ],
        "website": "https://github.com/slackhq/nebula",
        "logo": "https://github.githubassets.com/favicons/favicon.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "nebula",
        "options": [
            {
                "name": "networks",
                "desc": "Nebula network definitions.",
                "nixName": "networks",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "networks.<name>.ca",
                "desc": "Path to the certificate authority certificate.",
                "nixName": "networks.<name>.ca",
                "type": "path",
                "value": null
            },
            {
                "name": "networks.<name>.cert",
                "desc": "Path to the host certificate.",
                "nixName": "networks.<name>.cert",
                "type": "path",
                "value": null
            },
            {
                "name": "networks.<name>.enable",
                "desc": "Enable or disable this network.",
                "nixName": "networks.<name>.enable",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "networks.<name>.firewall.inbound",
                "desc": "Firewall rules for inbound traffic.",
                "nixName": "networks.<name>.firewall.inbound",
                "type": "list of (attribute set)",
                "value": "[ ]"
            },
            {
                "name": "networks.<name>.firewall.outbound",
                "desc": "Firewall rules for outbound traffic.",
                "nixName": "networks.<name>.firewall.outbound",
                "type": "list of (attribute set)",
                "value": "[ ]"
            },
            {
                "name": "networks.<name>.isLighthouse",
                "desc": "Whether this node is a lighthouse.",
                "nixName": "networks.<name>.isLighthouse",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "networks.<name>.isRelay",
                "desc": "Whether this node is a relay.",
                "nixName": "networks.<name>.isRelay",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "networks.<name>.key",
                "desc": "Path to the host key.",
                "nixName": "networks.<name>.key",
                "type": "path",
                "value": null
            },
            {
                "name": "networks.<name>.lighthouses",
                "desc": "List of IPs of lighthouse hosts this node should report to and queryfrom. This should be empty on lighthouse nodes. The IPs should be thelighthouse\u2019s Nebula IPs, not their external IPs.",
                "nixName": "networks.<name>.lighthouses",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "networks.<name>.listen.host",
                "desc": "IP address to listen on.",
                "nixName": "networks.<name>.listen.host",
                "type": "string",
                "value": "\"0.0.0.0\""
            },
            {
                "name": "networks.<name>.listen.port",
                "desc": "Port number to listen on.",
                "nixName": "networks.<name>.listen.port",
                "type": "null or 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "if (config.services.nebula.networks.${name}.isLighthouse ||\n    config.services.nebula.networks.${name}.isRelay) then\n  4242\nelse\n  0;\n"
            },
            {
                "name": "networks.<name>.package",
                "desc": "The nebula package to use.",
                "nixName": "networks.<name>.package",
                "type": "package",
                "value": "pkgs.nebula"
            },
            {
                "name": "networks.<name>.relays",
                "desc": "List of IPs of relays that this node should allow traffic from.",
                "nixName": "networks.<name>.relays",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "networks.<name>.settings",
                "desc": "Nebula configuration. Refer to  https://github.com/slackhq/nebula/blob/master/examples/config.yml for details on supported values.",
                "nixName": "networks.<name>.settings",
                "type": "YAML value",
                "value": "{ }"
            },
            {
                "name": "networks.<name>.staticHostMap",
                "desc": "The static host map defines a set of hosts with fixed IP addresses onthe internet (or any network). A host can have multiple fixed IPaddresses defined here, and nebula will try each when establishing atunnel.",
                "nixName": "networks.<name>.staticHostMap",
                "type": "attribute set of list of string",
                "value": "{ }"
            },
            {
                "name": "networks.<name>.tun.device",
                "desc": "Name of the tun device. Defaults to nebula.${networkName}.",
                "nixName": "networks.<name>.tun.device",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "networks.<name>.tun.disable",
                "desc": "When tun is disabled, a lighthouse can be started without a local tuninterface (and therefore without root).",
                "nixName": "networks.<name>.tun.disable",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "ocserv",
        "desc": "OpenConnect VPN server (ocserv), a server for the OpenConnect VPN client",
        "tags": [
            "VPN"
        ],
        "website": "https://gitlab.com/openconnect/ocserv",
        "logo": "https://gitlab.com/assets/favicon-72a2cad5025aa931d6ea56c3201d1f18e68a8cd39788c7c80d5b2b82aa5143ef.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "ocserv",
        "options": [
            {
                "name": "config",
                "desc": "Configuration content to start an OCServ server.  For a full configuration reference,please refer to the onlinedocumentation ( https://ocserv.gitlab.io/www/manual.html ),the openconnect recipes ( https://github.com/openconnect/recipes )or  man ocserv .",
                "nixName": "config",
                "type": "strings concatenated with \"\\n\"",
                "value": null
            },
            {
                "name": "enable",
                "desc": "Whether to enable ocserv.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "SoftEther",
        "desc": "An Open-Source Free Cross-platform Multi-protocol VPN Program",
        "tags": [
            "VPN"
        ],
        "website": "https://www.softether.org/",
        "logo": "https://www.softether.org/favicon.ico",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "softether",
        "options": [
            {
                "name": "dataDir",
                "desc": "Data directory for SoftEther VPN.",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/softether\""
            },
            {
                "name": "enable",
                "desc": "Whether to enable SoftEther VPN services.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The softether package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.softether"
            },
            {
                "name": "vpnbridge.enable",
                "desc": "Whether to enable SoftEther VPN Bridge.",
                "nixName": "vpnbridge.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "vpnclient.down",
                "desc": "Shell commands executed when the Virtual Network Adapter(s) is/areshutting down.",
                "nixName": "vpnclient.down",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "vpnclient.enable",
                "desc": "Whether to enable SoftEther VPN Client.",
                "nixName": "vpnclient.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "vpnclient.up",
                "desc": "Shell commands executed when the Virtual Network Adapter(s) is/arestarting.",
                "nixName": "vpnclient.up",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "vpnserver.enable",
                "desc": "Whether to enable SoftEther VPN Server.",
                "nixName": "vpnserver.enable",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "strongSwan",
        "desc": "OpenSource IPsec-based VPN Solution",
        "tags": [
            "VPN"
        ],
        "website": "https://www.strongswan.org",
        "logo": "https://www.strongswan.org/favicon-32x32.png",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "strongswan",
        "options": [
            {
                "name": "ca",
                "desc": "A set of CAs (certification authorities) and their options for the\u2018ca xxx\u2019 sections of the  ipsec.conf  file.",
                "nixName": "ca",
                "type": "attribute set of attribute set of string",
                "value": "{ }"
            },
            {
                "name": "connections",
                "desc": "A set of connections and their options for the \u2018conn xxx\u2019 sections ofthe  ipsec.conf file.",
                "nixName": "connections",
                "type": "attribute set of attribute set of string",
                "value": "{ }"
            },
            {
                "name": "enable",
                "desc": "Whether to enable strongSwan.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enabledPlugins",
                "desc": "A list of additional plugins to enable if  managePlugins  is true.",
                "nixName": "enabledPlugins",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "managePlugins",
                "desc": "If set to true, this option will disable automatic plugin loading andthen tell strongSwan to enable the plugins specified in the  enabledPlugins  option.",
                "nixName": "managePlugins",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "secrets",
                "desc": "A list of paths to IPSec secret files. These files will be includedinto the main ipsec.secrets file with the  include directive. It is safer if these paths are absolute.",
                "nixName": "secrets",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "setup",
                "desc": "A set of options for the \u2018config setup\u2019 section of the  ipsec.conf  file. Definesgeneral configuration parameters.",
                "nixName": "setup",
                "type": "attribute set of string",
                "value": "{ }"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Caddy",
        "desc": "Fast and extensible multi-platform HTTP/1-2-3 web server with automatic HTTPS",
        "tags": [
            "Web Servers"
        ],
        "website": "https://caddyserver.com",
        "logo": "https://caddyserver.com/resources/images/favicon.png?v=50fb678",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "caddy",
        "options": [
            {
                "name": "acmeCA",
                "desc": "Sets the   acme_ca option  in the global options block of the resulting Caddyfile.   The URL to the ACME CA\u2019s directory. It is strongly recommended to setthis to https://acme-staging-v02.api.letsencrypt.org/directory  forLet\u2019s Encrypt\u2019s  stagingendpoint  while testing or in development.  Value  null  should be prefered for production setups, asit omits the  acme_ca  option to enable  automaticissuer fallback .",
                "nixName": "acmeCA",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "adapter",
                "desc": "Name of the config adapter to use. See  https://caddyserver.com/docs/config-adapters for the full list.  If  null  is specified, the  --adapter argument is omitted when starting or restarting Caddy. Notably, thisallows specification of a configuration file in Caddy\u2019s native JSONformat, as long as the filename does not start with Caddyfile  (in which case the  caddyfile  adapteris implicitly enabled). See  https://caddyserver.com/docs/command-line#caddy-run for details.   Any value other than  null  or  caddyfile  isonly valid when providing your own  configFile .",
                "nixName": "adapter",
                "type": "null or string",
                "value": "if ((cfg.configFile != configFile) || (builtins.baseNameOf cfg.configFile) == \"Caddyfile\") then \"caddyfile\" else null\n"
            },
            {
                "name": "configFile",
                "desc": "Override the configuration file used by Caddy. By default, NixOSgenerates one automatically.  The configuration file is exposed at  /etc/caddy/caddy_config .",
                "nixName": "configFile",
                "type": "path",
                "value": "\"A Caddyfile automatically generated by values from services.caddy.*\""
            },
            {
                "name": "dataDir",
                "desc": "The data directory for caddy.   If left as the default value this directory will automatically becreated before the Caddy server starts, otherwise you are responsiblefor ensuring the directory exists with appropriate ownership andpermissions.  Caddy v2 replaced  CADDYPATH  with XDG directories. See  https://caddyserver.com/docs/conventions#file-locations .",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/caddy\""
            },
            {
                "name": "email",
                "desc": "Your email address. Mainly used when creating an ACME account withyour CA, and is highly recommended in case there are problems with yourcertificates.",
                "nixName": "email",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Caddy web server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableReload",
                "desc": "Reload Caddy instead of restarting it when configuration filechanges.  Note that enabling this option requires the  adminAPI  to not be turned off.  If you enable this option, consider setting   grace_period  to a non-infinite value in  services.caddy.globalConfig  to prevent Caddywaiting for active connections to finish, which could delay the reloadessentially indefinitely.",
                "nixName": "enableReload",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "extraConfig",
                "desc": "Additional lines of configuration appended to the automaticallygenerated  Caddyfile .",
                "nixName": "extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "globalConfig",
                "desc": "Additional lines of configuration appended to the global configsection of the  Caddyfile .  Refer to  https://caddyserver.com/docs/caddyfile/options#global-options for details on supported values.",
                "nixName": "globalConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "group",
                "desc": "Group account under which caddy runs.   If left as the default value this user will automatically be createdon system activation, otherwise you are responsible for ensuring theuser exists before the Caddy service starts.",
                "nixName": "group",
                "type": "string",
                "value": "\"caddy\""
            },
            {
                "name": "logDir",
                "desc": "Directory for storing Caddy access logs.   If left as the default value this directory will automatically becreated before the Caddy server starts, otherwise the sysadmin isresponsible for ensuring the directory exists with appropriate ownershipand permissions.",
                "nixName": "logDir",
                "type": "path",
                "value": "\"/var/log/caddy\""
            },
            {
                "name": "logFormat",
                "desc": "Configuration for the default logger. See  https://caddyserver.com/docs/caddyfile/options#log for details.",
                "nixName": "logFormat",
                "type": "strings concatenated with \"\\n\"",
                "value": "''\n  level ERROR\n''"
            },
            {
                "name": "package",
                "desc": "The caddy package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.caddy"
            },
            {
                "name": "resume",
                "desc": "Use saved config, if any (and prefer over any specified configurationpassed with  --config ).",
                "nixName": "resume",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "settings",
                "desc": "Structured configuration for Caddy to generate a Caddy JSONconfiguration file. See  https://caddyserver.com/docs/json/ for available options.   Using a  Caddyfile  instead of aJSON config is highly recommended by upstream. There are only very fewexception to this.  Please use a Caddyfile via  services.caddy.configFile ,  services.caddy.virtualHosts  or  services.caddy.extraConfig with  services.caddy.globalConfig  instead.    Takes presence over most  services.caddy.*  options, suchas  services.caddy.configFile  and  services.caddy.virtualHosts , if specified.",
                "nixName": "settings",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "user",
                "desc": "User account under which caddy runs.   If left as the default value this user will automatically be createdon system activation, otherwise you are responsible for ensuring theuser exists before the Caddy service starts.",
                "nixName": "user",
                "type": "string",
                "value": "\"caddy\""
            },
            {
                "name": "virtualHosts",
                "desc": "Declarative specification of virtual hosts served by Caddy.",
                "nixName": "virtualHosts",
                "type": "attribute set of (submodule)",
                "value": "{ }"
            },
            {
                "name": "virtualHosts.<name>.extraConfig",
                "desc": "Additional lines of configuration appended to this virtual host inthe automatically generated  Caddyfile .",
                "nixName": "virtualHosts.<name>.extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "virtualHosts.<name>.hostName",
                "desc": "Canonical hostname for the server.",
                "nixName": "virtualHosts.<name>.hostName",
                "type": "string",
                "value": "\"\u2039name\u203a\""
            },
            {
                "name": "virtualHosts.<name>.listenAddresses",
                "desc": "A list of host interfaces to bind to for this virtual host.",
                "nixName": "virtualHosts.<name>.listenAddresses",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "virtualHosts.<name>.logFormat",
                "desc": "Configuration for HTTP request logging (also known as access logs).See  https://caddyserver.com/docs/caddyfile/directives/log#log for details.",
                "nixName": "virtualHosts.<name>.logFormat",
                "type": "strings concatenated with \"\\n\"",
                "value": "''\n  output file ''${config.services.caddy.logDir}/access-''${hostName}.log\n''"
            },
            {
                "name": "virtualHosts.<name>.serverAliases",
                "desc": "Additional names of virtual hosts served by this virtual hostconfiguration.",
                "nixName": "virtualHosts.<name>.serverAliases",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "virtualHosts.<name>.useACMEHost",
                "desc": "A host of an existing Let\u2019s Encrypt certificate to use. This ismostly useful if you use DNS challenges but Caddy does not currentlysupport your provider.   Note that this option does not create any certificates, nor doesit add subdomains to existing ones \u2013 you will need to create themmanually using  security.acme.certs .",
                "nixName": "virtualHosts.<name>.useACMEHost",
                "type": "null or string",
                "value": "null"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "HAProxy",
        "desc": "Reliable, high performance TCP/HTTP load balancer",
        "tags": [
            "Web Servers"
        ],
        "website": "https://haproxy.org",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEX////n5+dRUf//AAAA5+fn5wAA5wCtv7miAAAAUUlEQVQI12PABhgFBQUFQAwmIUFDCENJWBgqImwMZUBFFASAECTAyMTIyMTAIAgFDEoijmKiooaGDIoqIomJgUAGUATIEBZkUBQRAUoBGRgAALrGCAzjYWFDAAAAAElFTkSuQmCC",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "haproxy",
        "options": [
            {
                "name": "config",
                "desc": "Contents of the HAProxy configuration file,  haproxy.conf .",
                "nixName": "config",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable HAProxy, the reliable, high performance TCP/HTTPload balancer.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "group",
                "desc": "Group account under which haproxy runs.",
                "nixName": "group",
                "type": "string",
                "value": "\"haproxy\""
            },
            {
                "name": "package",
                "desc": "The haproxy package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.haproxy"
            },
            {
                "name": "user",
                "desc": "User account under which haproxy runs.",
                "nixName": "user",
                "type": "string",
                "value": "\"haproxy\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Lighttpd",
        "desc": "Lightweight high-performance web server",
        "tags": [
            "Web Servers"
        ],
        "website": "http://www.lighttpd.net/",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "lighttpd",
        "options": [
            {
                "name": "cgit.configText",
                "desc": "Verbatim contents of the cgit runtime configuration file.Documentation (with cgitrc example file) is available in \u201cman cgitrc\u201d.Or online:  http://git.zx2c4.com/cgit/tree/cgitrc.5.txt",
                "nixName": "cgit.configText",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "cgit.enable",
                "desc": "If true, enable cgit (fast web interface for git repositories) as asub-service in lighttpd.",
                "nixName": "cgit.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "cgit.subdir",
                "desc": "The subdirectory in which to serve cgit. The web application will beaccessible at http://yourserver/${subdir}",
                "nixName": "cgit.subdir",
                "type": "string",
                "value": "\"cgit\""
            },
            {
                "name": "collectd.collectionCgi",
                "desc": "Path to collection.cgi script from (collectdsources)/contrib/collection.cgi This option allows to use a customizedversion",
                "nixName": "collectd.collectionCgi",
                "type": "path",
                "value": "<rendered-html><p><code>config.services.collectd.package</code> configured for\nlighttpd</p>\n</rendered-html>"
            },
            {
                "name": "collectd.enable",
                "desc": "Whether to enable collectd subservice accessible athttp://yourserver/collectd.",
                "nixName": "collectd.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "configText",
                "desc": "Overridable config file contents to use for lighttpd. By default, usethe contents automatically generated by NixOS.",
                "nixName": "configText",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "document-root",
                "desc": "Document-root of the web server. Must be readable by the \u201clighttpd\u201duser.",
                "nixName": "document-root",
                "type": "path",
                "value": "\"/srv/www\""
            },
            {
                "name": "enable",
                "desc": "Enable the lighttpd web server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableModules",
                "desc": "List of lighttpd modules to enable. Sub-services take care ofenabling modules as needed, so this option is mainly for when you wantto add custom stuff to  services.lighttpd.extraConfig  that depends on acertain module.",
                "nixName": "enableModules",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "enableUpstreamMimeTypes",
                "desc": "Whether to include the list of mime types bundled with lighttpd(upstream). If you disable this, no mime types will be added by NixOSand you will have to add your own mime types in  services.lighttpd.extraConfig .",
                "nixName": "enableUpstreamMimeTypes",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "extraConfig",
                "desc": "These configuration lines will be appended to the generated lighttpdconfig file. Note that this mechanism does not work when the manual configText  option isused.",
                "nixName": "extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "gitweb.enable",
                "desc": "If true, enable gitweb in lighttpd. Access it athttp://yourserver/gitweb",
                "nixName": "gitweb.enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "mod_status",
                "desc": "Show server status overview at /server-status, statistics at/server-statistics and list of loaded modules at /server-config.",
                "nixName": "mod_status",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "mod_userdir",
                "desc": "If true, requests in the form /~user/page.html are rewritten to takethe file public_html/page.html from the home directory of the user.",
                "nixName": "mod_userdir",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The lighttpd package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.lighttpd"
            },
            {
                "name": "port",
                "desc": "TCP port number for lighttpd to bind to.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "80"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Static Web Server",
        "desc": "An asynchronous web server for static files-serving",
        "tags": [
            "Web Servers"
        ],
        "website": "https://static-web-server.net/",
        "logo": "https://static-web-server.net/assets/sws.svg",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "static-web-server",
        "options": [
            {
                "name": "configuration",
                "desc": "Configuration for Static Web Server. See  https://static-web-server.net/configuration/config-file/ .NOTE: Don\u2019t set \u201chost\u201d, \u201cport\u201d, or \u201croot\u201d here. They will be ignored.Use the top-level \u201clisten\u201d and \u201croot\u201d options instead.",
                "nixName": "configuration",
                "type": "TOML value",
                "value": "{ }"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Static Web Server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "listen",
                "desc": "The \u201cListenStream\u201d used in static-web-server.socket. This isequivalent to SWS\u2019s \u201chost\u201d and \u201cport\u201d options. See here for specificsyntax:  https://www.freedesktop.org/software/systemd/man/systemd.socket.html#ListenStream=",
                "nixName": "listen",
                "type": "string",
                "value": "\"[::]:8787\""
            },
            {
                "name": "root",
                "desc": "The location of files for SWS to serve. Equivalent to SWS\u2019s \u201croot\u201dconfig value. NOTE: This folder must exist before starting SWS.",
                "nixName": "root",
                "type": "path",
                "value": null
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Traefik",
        "desc": "A modern reverse proxy",
        "tags": [
            "Web Servers"
        ],
        "website": "https://traefik.io",
        "logo": "https://traefik.io/favicon.svg",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "traefik",
        "options": [
            {
                "name": "dataDir",
                "desc": "Location for any persistent data traefik creates, ie. acme",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/traefik\""
            },
            {
                "name": "dynamicConfigFile",
                "desc": "Path to traefik\u2019s dynamic configuration to use. (Using that optionhas precedence over  dynamicConfigOptions )",
                "nixName": "dynamicConfigFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "dynamicConfigOptions",
                "desc": "Dynamic configuration for Traefik.",
                "nixName": "dynamicConfigOptions",
                "type": "JSON value",
                "value": "{ }"
            },
            {
                "name": "enable",
                "desc": "Whether to enable Traefik web server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "environmentFiles",
                "desc": "Files to load as environment file. Environment variables from thisfile will be substituted into the static configuration file usingenvsubst.",
                "nixName": "environmentFiles",
                "type": "list of path",
                "value": "[ ]"
            },
            {
                "name": "group",
                "desc": "Set the group that traefik runs under. For the docker backend thisneeds to be set to  docker  instead.",
                "nixName": "group",
                "type": "string",
                "value": "\"traefik\""
            },
            {
                "name": "package",
                "desc": "The traefik package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.traefik"
            },
            {
                "name": "staticConfigFile",
                "desc": "Path to traefik\u2019s static configuration to use. (Using that option hasprecedence over  staticConfigOptions  and dynamicConfigOptions )",
                "nixName": "staticConfigFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "staticConfigOptions",
                "desc": "Static configuration for Traefik.",
                "nixName": "staticConfigOptions",
                "type": "JSON value",
                "value": "{\n  entryPoints = {\n    http = {\n      address = \":80\";\n    };\n  };\n}"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Varnish",
        "desc": "Web application accelerator also known as a caching HTTP reverse proxy",
        "tags": [
            "Web Servers"
        ],
        "website": "https://www.varnish-cache.org",
        "logo": "",
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "varnish",
        "options": [
            {
                "name": "config",
                "desc": "Verbatim default.vcl configuration.",
                "nixName": "config",
                "type": "strings concatenated with \"\\n\"",
                "value": null
            },
            {
                "name": "enable",
                "desc": "Whether to enable Varnish Server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enableConfigCheck",
                "desc": "Whether to enable checking the config during build time.",
                "nixName": "enableConfigCheck",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "extraCommandLine",
                "desc": "Command line switches for varnishd (run \u2018varnishd -?\u2019 to get list ofoptions)",
                "nixName": "extraCommandLine",
                "type": "string",
                "value": "\"\""
            },
            {
                "name": "extraModules",
                "desc": "Varnish modules (except \u2018std\u2019).",
                "nixName": "extraModules",
                "type": "list of package",
                "value": "[ ]"
            },
            {
                "name": "http_address",
                "desc": "HTTP listen address and port.",
                "nixName": "http_address",
                "type": "string",
                "value": "\"*:6081\""
            },
            {
                "name": "package",
                "desc": "The varnish package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.varnish"
            },
            {
                "name": "stateDir",
                "desc": "Directory holding all state for Varnish to run.",
                "nixName": "stateDir",
                "type": "path",
                "value": "\"/var/spool/varnish/${config.networking.hostName}\""
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Minecraft Server",
        "desc": "Server for Minecraft java edition",
        "logo": "<URL to image>",
        "tags": [
            "Game",
            "Server",
            "Proprietary"
        ],
        "specs": {
            "ram": 1024,
            "storage": 1024
        },
        "nixName": "minecraft-server",
        "options": [
            {
                "name": "dataDir",
                "desc": "Directory to store Minecraft database and other state/data files.",
                "nixName": "dataDir",
                "type": "path",
                "value": "\"/var/lib/minecraft\""
            },
            {
                "name": "declarative",
                "desc": "Whether to use a declarative Minecraft server configuration. Only ifset to  true , the options  services.minecraft-server.whitelist  and  services.minecraft-server.serverProperties  will beapplied.",
                "nixName": "declarative",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "enable",
                "desc": "If enabled, start a Minecraft Server. The server data will be loadedfrom and saved to  services.minecraft-server.dataDir .",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "eula",
                "desc": "Whether you agree to   MojangsEULA . This option must be set to  true  to run Minecraftserver.",
                "nixName": "eula",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "jvmOpts",
                "desc": "JVM options for the Minecraft server.",
                "nixName": "jvmOpts",
                "type": "strings concatenated with \" \"",
                "value": "\"-Xmx2048M -Xms2048M\""
            },
            {
                "name": "openFirewall",
                "desc": "Whether to open ports in the firewall for the server.",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The minecraft-server package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.minecraft-server"
            },
            {
                "name": "serverProperties",
                "desc": "Minecraft server properties for the server.properties file. Only hasan effect when  services.minecraft-server.declarative  is set to true . See  https://minecraft.gamepedia.com/Server.properties#Java_Edition_3 for documentation on these values.",
                "nixName": "serverProperties",
                "type": "attribute set of (boolean or signed integer or string)",
                "value": "{ }"
            },
            {
                "name": "whitelist",
                "desc": "Whitelisted players, only has an effect when  services.minecraft-server.declarative  is true  and the whitelist is enabled via  services.minecraft-server.serverProperties  bysetting  white-list  to  true . This is a mappingfrom Minecraft usernames to UUIDs. You can use  https://mcuuid.net/  to get a MinecraftUUID for a username.",
                "nixName": "whitelist",
                "type": "attribute set of Minecraft UUID",
                "value": "{ }"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "OpenSSH Server",
        "desc": "SSH tunnel for manual tweaking and access to your machine. Warning: If you break the Xnode-Admin service you will need to fix it yourself or factory reset to regain control from the Studio.",
        "logo": "<URL to image>",
        "tags": [
            "Administration",
            "Access-control"
        ],
        "specs": {
            "ram": 0,
            "storage": 0
        },
        "nixName": "openssh",
        "options": [
            {
                "name": "allowSFTP",
                "desc": "Whether to enable the SFTP subsystem in the SSH daemon. This enablesthe use of commands such as  sftp  and  sshfs .",
                "nixName": "allowSFTP",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "authorizedKeysCommand",
                "desc": "Specifies a program to be used to look up the user\u2019s public keys. Theprogram must be owned by root, not writable by group or others andspecified by an absolute path.",
                "nixName": "authorizedKeysCommand",
                "type": "string",
                "value": "\"none\""
            },
            {
                "name": "authorizedKeysCommandUser",
                "desc": "Specifies the user under whose account the AuthorizedKeysCommand isrun. It is recommended to use a dedicated user that has no other role onthe host than running authorized keys commands.",
                "nixName": "authorizedKeysCommandUser",
                "type": "string",
                "value": "\"nobody\""
            },
            {
                "name": "authorizedKeysFiles",
                "desc": "Specify the rules for which files to read on the host.  This is an advanced option. If you\u2019re looking to configure user keys,you can generally use  users.users.<name>.openssh.authorizedKeys.keys or  users.users.<name>.openssh.authorizedKeys.keyFiles .  These are paths relative to the host root file system or homedirectories and they are subject to certain token expansion rules. SeeAuthorizedKeysFile in man sshd_config for details.",
                "nixName": "authorizedKeysFiles",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "authorizedKeysInHomedir",
                "desc": "Enables the use of the  ~/.ssh/authorized_keys  file.  Otherwise, the only files trusted by default are those in /etc/ssh/authorized_keys.d ,  i.e.  SSH keys from  users.users.<name>.openssh.authorizedKeys.keys .",
                "nixName": "authorizedKeysInHomedir",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "banner",
                "desc": "Message to display to the remote user before authentication isallowed.",
                "nixName": "banner",
                "type": "null or strings concatenated with \"\\n\"",
                "value": "null"
            },
            {
                "name": "enable",
                "desc": "Whether to enable the OpenSSH secure shell daemon, which allowssecure remote logins.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "extraConfig",
                "desc": "Verbatim contents of  sshd_config .",
                "nixName": "extraConfig",
                "type": "strings concatenated with \"\\n\"",
                "value": "\"\""
            },
            {
                "name": "hostKeys",
                "desc": "NixOS can automatically generate SSH host keys. This option specifiesthe path, type and size of each key. See  ssh-keygen(1)  for supported types and sizes.",
                "nixName": "hostKeys",
                "type": "list of (attribute set)",
                "value": "[\n  {\n    bits = 4096;\n    path = \"/etc/ssh/ssh_host_rsa_key\";\n    type = \"rsa\";\n  }\n  {\n    path = \"/etc/ssh/ssh_host_ed25519_key\";\n    type = \"ed25519\";\n  }\n]"
            },
            {
                "name": "knownHosts",
                "desc": "Alias of  programs.ssh.knownHosts .",
                "nixName": "knownHosts",
                "type": "attribute set of (submodule)",
                "value": null
            },
            {
                "name": "knownHosts.<name>.certAuthority",
                "desc": "This public key is an SSH certificate authority, rather than anindividual host\u2019s key.",
                "nixName": "knownHosts.<name>.certAuthority",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "knownHosts.<name>.extraHostNames",
                "desc": "A list of additional host names and/or IP numbers used for accessingthe host\u2019s ssh service. This list is ignored if  hostNames is set explicitly.",
                "nixName": "knownHosts.<name>.extraHostNames",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "knownHosts.<name>.hostNames",
                "desc": "A list of host names and/or IP numbers used for accessing the host\u2019sssh service. This list includes the name of the containing knownHosts  attribute by default for convenience. If youwish to configure multiple host keys for the same host use multiple knownHosts  entries with different attribute names and thesame  hostNames  list.",
                "nixName": "knownHosts.<name>.hostNames",
                "type": "list of string",
                "value": "[ \u2039name\u203a ] ++ config.services.openssh.knownHosts.<name>.extraHostNames"
            },
            {
                "name": "knownHosts.<name>.publicKey",
                "desc": "The public key data for the host. You can fetch a public key from arunning SSH server with the  ssh-keyscan  command. The public key should notinclude any host names, only the key type and the key itself.",
                "nixName": "knownHosts.<name>.publicKey",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "knownHosts.<name>.publicKeyFile",
                "desc": "The path to the public key file for the host. The public key file isread at build time and saved in the Nix store. You can fetch a publickey file from a running SSH server with the  ssh-keyscan  command. Thecontent of the file should follow the same format as described for the publicKey  option. Only a single key is supported. If a hosthas multiple keys, use  programs.ssh.knownHostsFiles  instead.",
                "nixName": "knownHosts.<name>.publicKeyFile",
                "type": "null or path",
                "value": "null"
            },
            {
                "name": "listenAddresses",
                "desc": "List of addresses and ports to listen on (ListenAddress directive inconfig). If port is not specified for address sshd will listen on allports specified by  ports  option. NOTE: this will overridedefault listening on all local addresses and port 22. NOTE: setting thisoption won\u2019t automatically enable given ports in firewallconfiguration.",
                "nixName": "listenAddresses",
                "type": "list of (submodule)",
                "value": "[ ]"
            },
            {
                "name": "listenAddresses.*.addr",
                "desc": "Host, IPv4 or IPv6 address to listen to.",
                "nixName": "listenAddresses.*.addr",
                "type": "null or string",
                "value": "null"
            },
            {
                "name": "listenAddresses.*.port",
                "desc": "Port to listen to.",
                "nixName": "listenAddresses.*.port",
                "type": "null or signed integer",
                "value": "null"
            },
            {
                "name": "moduliFile",
                "desc": "Path to  moduli  file to install in /etc/ssh/moduli . If this option is unset, then the moduli  file shipped with OpenSSH will be used.",
                "nixName": "moduliFile",
                "type": "path",
                "value": null
            },
            {
                "name": "openFirewall",
                "desc": "Whether to automatically open the specified ports in thefirewall.",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "true"
            },
            {
                "name": "package",
                "desc": "OpenSSH package to use for sshd.",
                "nixName": "package",
                "type": "package",
                "value": "programs.ssh.package"
            },
            {
                "name": "ports",
                "desc": "Specifies on which ports the SSH daemon listens.",
                "nixName": "ports",
                "type": "list of 16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "[\n  22\n]"
            },
            {
                "name": "settings",
                "desc": "Configuration for  sshd_config(5) .",
                "nixName": "settings",
                "type": "attribute set of (atom (null, bool, int, float or string))",
                "value": "{ }"
            },
            {
                "name": "settings.AllowGroups",
                "desc": "If specified, login is allowed only for users part of the listedgroups. See  sshd_config(5)  for details.",
                "nixName": "settings.AllowGroups",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "settings.AllowUsers",
                "desc": "If specified, login is allowed only for the listed users. See  sshd_config(5)  fordetails.",
                "nixName": "settings.AllowUsers",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "settings.AuthorizedPrincipalsFile",
                "desc": "Specifies a file that lists principal names that are accepted forcertificate authentication. The default is  \"none\" , i.e. notto use a principals file.",
                "nixName": "settings.AuthorizedPrincipalsFile",
                "type": "null or string",
                "value": "\"none\""
            },
            {
                "name": "settings.Ciphers",
                "desc": "Allowed ciphers  Defaults to recommended settings from both  https://stribika.github.io/2015/01/04/secure-secure-shell.html and  https://infosec.mozilla.org/guidelines/openssh#modern-openssh-67",
                "nixName": "settings.Ciphers",
                "type": "null or (list of string)",
                "value": "[\n  \"chacha20-poly1305@openssh.com\"\n  \"aes256-gcm@openssh.com\"\n  \"aes128-gcm@openssh.com\"\n  \"aes256-ctr\"\n  \"aes192-ctr\"\n  \"aes128-ctr\"\n]"
            },
            {
                "name": "settings.DenyGroups",
                "desc": "If specified, login is denied for all users part of the listedgroups. Takes precedence over  services.openssh.settings.AllowGroups .See  sshd_config(5) for details.",
                "nixName": "settings.DenyGroups",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "settings.DenyUsers",
                "desc": "If specified, login is denied for all listed users. Takes precedenceover  services.openssh.settings.AllowUsers .See  sshd_config(5) for details.",
                "nixName": "settings.DenyUsers",
                "type": "null or (list of string)",
                "value": "null"
            },
            {
                "name": "settings.GatewayPorts",
                "desc": "Specifies whether remote hosts are allowed to connect to portsforwarded for the client. See  sshd_config(5) .",
                "nixName": "settings.GatewayPorts",
                "type": "null or string",
                "value": "\"no\""
            },
            {
                "name": "settings.KbdInteractiveAuthentication",
                "desc": "Specifies whether keyboard-interactive authentication is allowed.",
                "nixName": "settings.KbdInteractiveAuthentication",
                "type": "null or boolean",
                "value": "true"
            },
            {
                "name": "settings.KexAlgorithms",
                "desc": "Allowed key exchange algorithms  Uses the lower bound recommended in both  https://stribika.github.io/2015/01/04/secure-secure-shell.html and  https://infosec.mozilla.org/guidelines/openssh#modern-openssh-67",
                "nixName": "settings.KexAlgorithms",
                "type": "null or (list of string)",
                "value": "[\n  \"sntrup761x25519-sha512@openssh.com\"\n  \"curve25519-sha256\"\n  \"curve25519-sha256@libssh.org\"\n  \"diffie-hellman-group-exchange-sha256\"\n]"
            },
            {
                "name": "settings.LogLevel",
                "desc": "Gives the verbosity level that is used when logging messages fromsshd(8). Logging with a DEBUG level violates the privacy of users and isnot recommended.",
                "nixName": "settings.LogLevel",
                "type": "null or one of \"QUIET\", \"FATAL\", \"ERROR\", \"INFO\", \"VERBOSE\", \"DEBUG\", \"DEBUG1\", \"DEBUG2\", \"DEBUG3\"",
                "value": "\"INFO\""
            },
            {
                "name": "settings.Macs",
                "desc": "Allowed MACs  Defaults to recommended settings from both  https://stribika.github.io/2015/01/04/secure-secure-shell.html and  https://infosec.mozilla.org/guidelines/openssh#modern-openssh-67",
                "nixName": "settings.Macs",
                "type": "null or (list of string)",
                "value": "[\n  \"hmac-sha2-512-etm@openssh.com\"\n  \"hmac-sha2-256-etm@openssh.com\"\n  \"umac-128-etm@openssh.com\"\n]"
            },
            {
                "name": "settings.PasswordAuthentication",
                "desc": "Specifies whether password authentication is allowed.",
                "nixName": "settings.PasswordAuthentication",
                "type": "null or boolean",
                "value": "true"
            },
            {
                "name": "settings.PermitRootLogin",
                "desc": "Whether the root user can login using ssh.",
                "nixName": "settings.PermitRootLogin",
                "type": "null or one of \"yes\", \"without-password\", \"prohibit-password\", \"forced-commands-only\", \"no\"",
                "value": "\"prohibit-password\""
            },
            {
                "name": "settings.PrintMotd",
                "desc": "Whether to enable printing /etc/motd when a user logs ininteractively.",
                "nixName": "settings.PrintMotd",
                "type": "null or boolean",
                "value": "false"
            },
            {
                "name": "settings.StrictModes",
                "desc": "Whether sshd should check file modes and ownership of directories",
                "nixName": "settings.StrictModes",
                "type": "null or boolean",
                "value": "true"
            },
            {
                "name": "settings.UseDns",
                "desc": "Specifies whether sshd(8) should look up the remote host name, and tocheck that the resolved host name for the remote IP address maps back tothe very same IP address. If this option is set to no (the default) thenonly addresses and not host names may be used in ~/.ssh/authorized_keysfrom and sshd_config Match Host directives.",
                "nixName": "settings.UseDns",
                "type": "null or boolean",
                "value": "false"
            },
            {
                "name": "settings.UsePAM",
                "desc": "Whether to enable PAM authentication.",
                "nixName": "settings.UsePAM",
                "type": "null or boolean",
                "value": "true"
            },
            {
                "name": "settings.X11Forwarding",
                "desc": "Whether to allow X11 connections to be forwarded.",
                "nixName": "settings.X11Forwarding",
                "type": "null or boolean",
                "value": "false"
            },
            {
                "name": "sftpFlags",
                "desc": "Commandline flags to add to sftp-server.",
                "nixName": "sftpFlags",
                "type": "list of string",
                "value": "[ ]"
            },
            {
                "name": "sftpServerExecutable",
                "desc": "The sftp server executable. Can be a path or \u201cinternal-sftp\u201d to usethe sftp server built into the sshd binary.",
                "nixName": "sftpServerExecutable",
                "type": "string",
                "value": null
            },
            {
                "name": "startWhenNeeded",
                "desc": "If set,  sshd  issocket-activated; that is, instead of having it permanently running as adaemon, systemd will start an instance for each incoming connection.",
                "nixName": "startWhenNeeded",
                "type": "boolean",
                "value": "false"
            }
        ],
        "show": false,
        "tested": false
    },
    {
        "name": "Open WebUI",
        "desc": "Play around with AI in a web-based GUI! Runs alongside Ollama.",
        "logo": "https://docs.openwebui.com/img/favicon.png",
        "tags": [
            "AI",
            "LLM",
            "GPU",
            "Open-source",
            "Web Application"
        ],
        "specs": {
            "ram": 12000,
            "storage": 12000
        },
        "nixName": "open-webui",
        "options": [
            {
                "name": "enable",
                "desc": "Whether to enable Open-WebUI server.",
                "nixName": "enable",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "environment",
                "desc": "Extra environment variables for Open-WebUI",
                "nixName": "environment",
                "type": "attribute set of string",
                "value": "{\n  ANONYMIZED_TELEMETRY = \"False\";\n  DO_NOT_TRACK = \"True\";\n  SCARF_NO_ANALYTICS = \"True\";\n}"
            },
            {
                "name": "host",
                "desc": "The host address which the Open-WebUI server HTTP interface listensto.",
                "nixName": "host",
                "type": "string",
                "value": "\"127.0.0.1\""
            },
            {
                "name": "openFirewall",
                "desc": "Whether to open the firewall for Open-WebUI. This adds services.open-webui.port  to networking.firewall.allowedTCPPorts .",
                "nixName": "openFirewall",
                "type": "boolean",
                "value": "false"
            },
            {
                "name": "package",
                "desc": "The open-webui package to use.",
                "nixName": "package",
                "type": "package",
                "value": "pkgs.open-webui"
            },
            {
                "name": "port",
                "desc": "Which port the Open-WebUI server listens to.",
                "nixName": "port",
                "type": "16 bit unsigned integer; between 0 and 65535 (both inclusive)",
                "value": "8080"
            },
            {
                "name": "stateDir",
                "desc": "State directory of Open-WebUI.",
                "nixName": "stateDir",
                "type": "path",
                "value": "\"/var/lib/open-webui\""
            }
        ],
        "show": false,
        "tested": false
    }
]